window.searchIndex = [{"Url":"/docs/1.1/core/build-applications/accounts.md","Body":"# Accounts\n\n## Introduction\n\nAn account is an object in Chain Core that tracks ownership of assets on a blockchain by creating and tracking control programs.\n\nA control program appears in each output of each transaction, defining a set of conditions that must be satisfied in order to spend the output - typically, that the spending transaction be signed by one or more specific keys.\n\nWhen you create an account, you provide one or more “root” keys and a quorum. Each separate deposit to your account (i.e., each transaction output transferring assets to you) uses a new control program generated by your account. Each control program is unique, using newly derived child keys of the account’s root keys. For more information, see [Control Programs](control-programs.md#account-control-programs).\n\nYour account balance is the sum of all assets in the set of unspent transaction outputs using any of your derived-key control programs. When you build an asset-transfer transaction, your account locates a sufficient quantity of unspent outputs that you control to be used as inputs to the new transaction.\n\nThe account object does not exist on the blockchain - it is local to Chain Core. Only the control programs created in the account are visible on the blockchain. However, when a new transactions is processed by Chain Core, it is annotated with local account data to enable powerful queries. For more information, see [Global vs. Local Data](../learn-more/global-vs-local-data.md).\n\n## Overview\n\nThis guide will walk you through the basic functions of an account:\n\n* [Create account](#create-account)\n* [List accounts by tags](#list-accounts-by-tags)\n* [Transfer asset units between local accounts](#transfer-asset-units-between-local-accounts) (within the same Chain Core)\n* [Receive asset units from an external party](#receive-asset-units-from-an-external-party)\n* [Transfer asset units to an external party](#transfer-asset-units-to-an-external-party)\n* [List account transactions](#list-account-transactions)\n* [List account balances](#list-account-balances)\n\nThis guide assumes you know the basic functions presented in the [5-Minute Guide](../get-started/five-minute-guide.md).\n\n### Sample Code\n\nAll code samples in this guide can be viewed in a single, runnable script. Available languages:\n\n- [Java](../examples/java/Accounts.java)\n- [Node](../examples/node/accounts.js)\n- [Ruby](../examples/ruby/accounts.rb)\n\n## Create account\n\n* The `alias` is an optional, user-supplied, unique identifier that you can use to operate on the account. We will use this later to build transactions.\n* The `quorum` is the threshold of keys that must sign a transaction to spend asset units controlled by the account.\n* The `tag` is an optional key-value field used for arbitrary storage or queries. We will add several tags.\n\nCreate an account for Alice.\n\n$code create-account-alice ../examples/java/Accounts.java ../examples/ruby/accounts.rb ../examples/node/accounts.js\n\nCreate an account for Bob.\n\n$code create-account-bob ../examples/java/Accounts.java ../examples/ruby/accounts.rb ../examples/node/accounts.js\n\n## List accounts by tags\n\nTo list all savings accounts, we build an accounts query, filtering on the `type` tag.\n\n$code list-accounts-by-tag ../examples/java/Accounts.java ../examples/ruby/accounts.rb ../examples/node/accounts.js\n\n## Transfer asset units between local accounts\n\nTo transfer assets between accounts within a Chain Core, we can build a transaction using an `account_id` or `account_alias`. This automatically creates a control program for the recipient account.\n\nWe will build a transaction transferring to units of gold from Alice’s account to Bob’s account.\n\n$code build-transfer ../examples/java/Accounts.java ../examples/ruby/accounts.rb ../examples/node/accounts.js\n\nOnce we have built the transaction, we need to sign it with the key used to create Alice’s account. Note: We do not need to sign on behalf of Bob’s account, because Bob is not spending any assets - only receiving.\n\n$code sign-transfer ../examples/java/Accounts.java ../examples/ruby/accounts.rb ../examples/node/accounts.js\n\nOnce we have signed the transaction, we can submit it for inclusion in the blockchain.\n\n$code submit-transfer ../examples/java/Accounts.java ../examples/ruby/accounts.rb ../examples/node/accounts.js\n\n## Receive asset units from an external party\n\nWhen an external party wishes to transfer assets to your account, you must first create a **receiver** for the account. A receiver is a one-time-use payment object similar to an invoice. It contains a new control program derived from the account's root keys, as well as supplementary payment information such as an expiration date.\n\nWe will create a receiver for Bob’s account, which we can then serialize and send to an external party (see following example).\n\n$code create-receiver ../examples/java/Accounts.java ../examples/ruby/accounts.rb ../examples/node/accounts.js\n\n## Transfer asset units to an external party\n\nIf you wish to transfer asset units to an external party, you must first request a receiver from them. You can then build, sign, and submit a transaction sending asset units to their control program. We will use the receiver we created in Bob’s account to demonstrate this external facing functionality.\n\n$code transfer-to-receiver ../examples/java/Accounts.java ../examples/ruby/accounts.rb ../examples/node/accounts.js\n\n## List account transactions\n\nChain Core keeps a time-ordered list of all transactions in the blockchain. These transactions are locally annotated with account and asset data to enable intelligent queries. Note: local data is not present in the blockchain, see: [Global vs. Local Data](../learn-more/global-vs-local-data.md).\n\nTo list transactions involving Alice’s account, we build a transaction query, filtering on transactions where Alice spent or controlled any asset units.\n\n$code list-account-txs ../examples/java/Accounts.java ../examples/ruby/accounts.rb ../examples/node/accounts.js\n\n## List account balances\n\nThe balance of an asset in an account is the sum of all units in unspent outputs controlled by one of the account’s control programs. A helpful analogy is a pocketbook that contains one $10 bill and one $5 bill. The “balance” of the pocketbook is $15.\n\nTo list the balances of all assets in Alice’s account, we build a balance query, filtering on Alice’s account alias.\n\n$code list-account-balances ../examples/java/Accounts.java ../examples/ruby/accounts.rb ../examples/node/accounts.js\n\nTo list all the unspent outputs that comprise the balance of gold in Alice’s account, we build an unspent outputs query, filtering on Alice’s account alias and the gold asset alias.\n\n$code list-account-unspent-outputs ../examples/java/Accounts.java ../examples/ruby/accounts.rb ../examples/node/accounts.js\n"},{"Url":"/docs/1.1/core/build-applications/assets.md","Body":"# Assets\n\n## Introduction\n\nAn asset is a type of value that can be issued on a blockchain. All units of a given asset are fungible.\n\nUnits of an asset can be transacted directly between parties without the involvement of the issuer.\n\nEach asset has a globally unique asset ID that is derived from an issuance program. The issuance program typically defines a set of possible signing keys and a threshold number of signatures that must be provided to authorize issuance of new units of the asset. Chain Core automatically creates the issuance program when the asset is created. The issuer can issue as many units as they want, as many times as they want. Custom issuance programs are possible that enforce further limits on when, whether, and by whom new units may be issued.\n\nEach asset can optionally include an asset definition consisting of arbitrary key-value data. The asset definition is committed to the blockchain for all participants to see. Additionally, an asset can be tagged locally with private data for convenient queries and operations. For more information, see [Global vs. Local Data](../learn-more/global-vs-local-data.md).\n\n## Overview\n\nThis guide will walk you through the basic functions of an asset:\n\n* [Create asset](#create-asset)\n* [List assets](#list-assets) (by asset definition, tags, and origin)\n* [Issue asset units to a local account](#issue-asset-units-to-a-local-account) (in the same Chain Core)\n* [Issue asset units to an external party](#issue-asset-units-to-an-external-party)\n* [Retire asset units](#retire-asset-units)\n* [List transactions](#list-asset-transactions) (for issuance, transfer, and retirement)\n* [Get asset circulation](#get-asset-circulation)\n\nThis guide assumes you know the basic functions presented in the [5-Minute Guide](../get-started/five-minute-guide.md).\n\n### Sample Code\n\nAll code samples in this guide can be viewed in a single, runnable script. Available languages:\n\n- [Java](../examples/java/Assets.java)\n- [Node](../examples/node/assets.js)\n- [Ruby](../examples/ruby/assets.rb)\n\n## Create asset\n\nCreating an asset defines the asset object locally in the Chain Core. It does not exist on the blockchain until units are issued in a transaction.\n\n* The `alias` is an optional, user-supplied, unique identifier that you can use to operate on the asset. We will use this later to build a transaction issuing units of the asset.\n* The `quorum` is the threshold number of the possible signing keys that must sign a transaction to issue units of this asset.\n* The `definition` is global data about the asset that is visible in the blockchain. We will create several fields in the definition.\n* The `tag` is an optional key-value field used for arbitrary storage or queries. This data is local to the Chain Core and *not* visible in the blockchain. We will add several tags.\n\nCreate an asset for Acme Common stock:\n\n$code create-asset-acme-common ../examples/java/Assets.java ../examples/ruby/assets.rb ../examples/node/assets.js\n\nCreate an asset for Acme Preferred stock:\n\n$code create-asset-acme-preferred ../examples/java/Assets.java ../examples/ruby/assets.rb ../examples/node/assets.js\n\n## List assets\n\nChain Core keeps a list of all assets in the blockchain, whether or not they were issued by the local Chain Core. Each asset can be locally annotated with an alias and tags to enable efficient actions and intelligent queries. Note: local data is not present in the blockchain, see: [Global vs Local Data](../learn-more/global-vs-local-data.md).\n\nTo list all assets created in the local Core, we build an assets query, filtering on the `is_local` tag.\n\n$code list-local-assets ../examples/java/Assets.java ../examples/ruby/assets.rb ../examples/node/assets.js\n\nTo list all assets defined as preferred stock of a private security, we build an assets query, filtering on several tags.\n\n$code list-private-preferred-securities ../examples/java/Assets.java ../examples/ruby/assets.rb ../examples/node/assets.js\n\n## Issue asset units to a local account\n\nTo issue units of an asset into an account within the Chain Core, we can build a transaction using an `asset_alias` and an `account_alias`.\n\nWe first build a transaction issuing 1000 units of Acme Common stock to the Acme treasury account.\n\n$code build-issue ../examples/java/Assets.java ../examples/ruby/assets.rb ../examples/node/assets.js\n\nOnce we have built the transaction, we need to sign it with the key used to create the Acme Common stock asset.\n\n$code sign-issue ../examples/java/Assets.java ../examples/ruby/assets.rb ../examples/node/assets.js\n\nOnce we have signed the transaction, we can submit it for inclusion in the blockchain.\n\n$code submit-issue ../examples/java/Assets.java ../examples/ruby/assets.rb ../examples/node/assets.js\n\n## Issue asset units to an external party\n\nIf you wish to issue asset units to an external party, you must first request a receiver from them. You can then build, sign, and submit a transaction issuing asset units to their receiver.\n\nWe will issue 2000 units of Acme Common stock to an external party.\n\n$code external-issue ../examples/java/Assets.java ../examples/ruby/assets.rb ../examples/node/assets.js\n\n## Retire asset units\n\nTo retire units of an asset from an account, we can build a transaction using an `account_alias` and `asset_alias`.\n\nWe first build a transaction retiring 50 units of Acme Common stock from Acme’s treasury account.\n\n$code build-retire ../examples/java/Assets.java ../examples/ruby/assets.rb ../examples/node/assets.js\n\nOnce we have built the transaction, we need to sign it with the key used to create Acme’s treasury account.\n\n$code sign-retire ../examples/java/Assets.java ../examples/ruby/assets.rb ../examples/node/assets.js\n\nOnce we have signed the transaction, we can submit it for inclusion in the blockchain. The asset units in this transaction become permanently unavailable for further spending.\n\n$code submit-retire ../examples/java/Assets.java ../examples/ruby/assets.rb ../examples/node/assets.js\n\n## List asset transactions\n\nChain Core keeps a time-ordered list of all transactions in the blockchain. These transactions are locally annotated with asset aliases and asset tags to enable intelligent queries. Note: local data is not present in the blockchain, see: [Global vs Local Data](../learn-more/global-vs-local-data.md).\n\n### Issuance transactions\n\nTo list transactions where Acme Common stock was issued, we build an assets query, filtering on inputs with the `issue` action and the Acme Common stock `asset_alias`.\n\n$code list-issuances ../examples/java/Assets.java ../examples/ruby/assets.rb ../examples/node/assets.js\n\n### Transfer transactions\n\nTo list transactions where Acme Common stock was transferred, we build an assets query, filtering on inputs with the `spend` action and the Acme Common stock `asset_alias`.\n\n$code list-transfers ../examples/java/Assets.java ../examples/ruby/assets.rb ../examples/node/assets.js\n\n### Retirement transactions\n\nTo list transactions where Acme Common stock was retired, we build an assets query, filtering on outputs with the `retire` action and the Acme Common stock `asset_alias`.\n\n$code list-retirements ../examples/java/Assets.java ../examples/ruby/assets.rb ../examples/node/assets.js\n\n## Get asset circulation\n\nThe circulation of an asset is the sum of all non-retired units of that asset existing in unspent transaction outputs in the blockchain.\n\nTo list the circulation of Acme Common stock, we build a balance query, filtering on the Acme Common stock `asset_alias`.\n\n$code list-acme-common-balance ../examples/java/Assets.java ../examples/ruby/assets.rb ../examples/node/assets.js\n\nTo list the circulation of all classes of Acme stock, we build a balance query, filtering on the `issuer` field in the `definition`.\n\n$code list-acme-balance ../examples/java/Assets.java ../examples/ruby/assets.rb ../examples/node/assets.js\n\nTo list all the unspent outputs that hold a portion of the circulation of Acme Common stock, we build an unspent outputs query, filtering on the Acme Common stock `asset_alias`.\n\n$code list-acme-common-unspents ../examples/java/Assets.java ../examples/ruby/assets.rb ../examples/node/assets.js\n"},{"Url":"/docs/1.1/core/build-applications/balances.md","Body":"# Balances\n\n## Introduction\n\nAny balance on the blockchain is simply a summation of unspent outputs. For example, the balance of Alice’s account is a summation of all the unspent outputs whose control programs were created from the keys in Alice’s account.\n\nUnlike other queries in Chain Core, balance queries do not return Chain Core objects, only simple sums over the `amount` fields in a specified list of unspent output objects.\n\n### Sum By\n\nBalance sums are totalled by `asset_id` and `asset_alias` by default, but it is also possible to query more complex sums. For example, if you have a network of counterparty-issued IOUs, you may wish to calculate the account balance of all IOUs from different counterparties that represent the same underlying currency.\n\n## Overview\n\nThis guide will walk you through a few basic balance queries:\n\n* [List account balances](#list-account-balances)\n* [Get asset circulation](#get-asset-circulation)\n* [List account balances, with custom summation](#list-account-balances-with-custom-summation)\n\n### Sample Code\n\nAll code samples in this guide can be viewed in a single, runnable script. Available languages:\n\n- [Java](../examples/java/Balances.java)\n- [Node](../examples/node/balances.js)\n- [Ruby](../examples/ruby/balances.rb)\n\n## List account balances\n\nList the asset IOU balances in Bank1's account:\n\n$code account-balance ../examples/java/Balances.java ../examples/ruby/balances.rb\n\n## Get asset circulation\n\nGet the circulation of the Bank 1 USD IOU on the blockchain:\n\n$code usd-iou-circulation ../examples/java/Balances.java ../examples/ruby/balances.rb\n\n## List account balances with custom summation\n\nList the asset IOU balances in Bank1's account, summed by currency:\n\n$code account-balance-sum-by-currency ../examples/java/Balances.java ../examples/ruby/balances.rb\n"},{"Url":"/docs/1.1/core/build-applications/batch-operations.md","Body":"# Batch Operations\n\n## Overview\n\nBatch operations are an advanced feature of the Chain Core API that allow you to bundle many similar operations into a single API call. Not only does this reduce network overhead, it also allows Chain Core to process the operations in your request in parallel.\n\nOperations that support batching include:\n\n* Creating assets\n* Creating accounts\n* Creating receivers\n* Building transactions\n* Signing transactions\n* Submitting transactions\n\n### Sample Code\n\nAll code samples in this guide can be viewed in a single, runnable script. Available languages:\n\n- [Java](../examples/java/BatchOperations.java)\n- [Node](../examples/node/batchOperations.js)\n- [Ruby](../examples/ruby/batch_operations.rb)\n\n## Example: Creating assets in a batch\n\nAll batch operations share a common workflow. To illustrate this, we’ll walk through an example application that creates several assets as a batch.\n\n#### Preparing the request\n\nBatch operations take similar input to their non-batch analogs, except that in batch calls you pass a _list_ of parameter objects, rather than a single object.\n\nFor our example, we’ll create a list of builder objects for our assets, one for each asset we want to create:\n\n$code asset-builders ../examples/java/BatchOperations.java ../examples/ruby/batch_operations.rb ../examples/node/batchOperations.js\n\nNote that we’re attempting to create the `bronze` asset with an invalid value for the `quorum` parameter. This will generate an API error, and since we’re performing a batch operation, we’ll have to handle the error in a special way.\n\n#### Making the batch call\n\nAll batch method names in the SDK end with `Batch`, and they return a special batch response object:\n\n$code asset-create-batch ../examples/java/BatchOperations.java ../examples/ruby/batch_operations.rb ../examples/node/batchOperations.js\n\n#### Handling the response\n\nIf there is a problem affecting the entire batch request, such as a network error, then the SDK will ensure that an exception is thrown. However, if there is a problem with an _individual_ item in your batch request, no exception will be thrown. Some of the items in your batch request may have succeeded, while others might have failed.\n\nThe `BatchResponse` object provides an easy interface for determining which items in the request successed, and which ones resulted in an error. We can iterate over the items in the batch response (there is one for every parameter object in the original request) and print out whether the operation succeeded or failed.\n\n$code asset-create-handle-errors ../examples/java/BatchOperations.java ../examples/ruby/batch_operations.rb ../examples/node/batchOperations.js\n\nIn our example, we expect at least one of the items in the batch request to fail, since we provided an invalid value for the `bronze` asset’s `quorum` parameter. This produces the following output:\n\n```\nasset 0 created, ID: f7cfb9604bc53b2ad44d2b61764cf77b4ffbcc16fd25206ce1ff4c2022f914dd\nasset 1 created, ID: 25217326f04305cbd83e809eeb95d325b4e6bacc30aa7d46a08406bc4e20579a\nasset 2 error: com.chain.exception.APIException: Code: CH200 Message: Quorum must be greater than 1 and less than or equal to the length of xpubs\n```\n\n#### Parallelization and errors\n\nBatch operations are parallelized on the server side, so there may be some non-deterministic error behavior if items in your batch request conflict with each other. Consider the following example:\n\n$code nondeterministic-errors ../examples/java/BatchOperations.java ../examples/ruby/batch_operations.rb ../examples/node/batchOperations.js\n\nHere, all three asset builders are attempting to create an asset with the alias `platinum`. Aliases must be unique, so only one will succeed. Due to parallelization, it’s possible to get results that appear to be out-of-order relative to the original request. For example, it’s possible for the last item in the request to succeed while the first two produce errors:\n\n```\nasset 0 error: com.chain.exception.APIException: Code: CH003 Message: Invalid request body Detail: non-unique alias\nasset 1 error: com.chain.exception.APIException: Code: CH003 Message: Invalid request body Detail: non-unique alias\nasset 2 created, ID: 9f7e068bf207faf60f08e78f8ae2834ac35340c217ee2b2329fe25724f246f42\n```\n\n## Example: Batch transactions\n\nEach of the three primary steps of transacting in Chain Core--building, signing, and submitting--can be performed as a batch operation. We’ll experiment with this by attempting to issue three different assets to Alice in three separate transactions as a batch.\n\n#### Building\n\nFirst, we’ll put together a list of transaction builders:\n\n$code batch-build-builders ../examples/java/BatchOperations.java ../examples/ruby/batch_operations.rb ../examples/node/batchOperations.js\n\nThe second transaction (index `1`) in our list is attempting to issue a non-existent asset, so we expect it to fail. If we make the batch request, we can iterate over the response errors and display any errors.\n\n$code batch-build-handle-errors ../examples/java/BatchOperations.java ../examples/ruby/batch_operations.rb ../examples/node/batchOperations.js\n\nThis error handling loop should produce the following output:\n\n```\nError building transaction 1: com.chain.exception.APIException: Code: CH002 Message: Not found Detail: invalid asset alias not-a-real-asset on action 0\n```\n\n#### Signing\n\nLet’s move on and try to sign and submit the transactions that we successfully built. We can extract the successful responses using the `successes()` method and pass them to `signBatch`:\n\n$code batch-sign ../examples/java/BatchOperations.java ../examples/ruby/batch_operations.rb ../examples/node/batchOperations.js\n\n#### Submitting\n\nAssuming there are no errors in signing, we can submit our batch of transactions:\n\n$code batch-submit ../examples/java/BatchOperations.java ../examples/ruby/batch_operations.rb ../examples/node/batchOperations.js\n\nFinally, assuming there are no errors during submission, we should see the following output:\n\n```\nTransaction 0 submitted, ID: 25dea2cb088586b46184556ffedc4c481b5e34b28e6f6f176731a9aecd1286ea\nTransaction 1 submitted, ID: 10666b27f303ed52f90381edd945fff5298251867dc398e7fe4bc3e2d5ccba52\n```\n"},{"Url":"/docs/1.1/core/build-applications/control-programs.md","Body":"# Control Programs\n\n## Introduction\n\nA control program is the mechanism that secures asset units on a blockchain. When you first issue units of an asset, you issue them into a control program. When you spend units of an asset, you spend them from an existing control program to a new control program. When you retire units of an asset, you spend them from an existing control program to a special retirement control program that can never be spent.\n\nEach output in a transaction contains a single control program. Each control program consists of set of predicates that must be satisfied in order to spend the output (i.e. use the output as an input to a new transaction).\n\n## Overview\n\nThis guide will walk you through the basic types of control programs available in Chain Core:\n\n* [Account control programs](#account-control-programs)\n* [Retirement control programs](#retirement-control-programs)\n* [Custom control programs](#custom-control-programs)\n\n### Sample Code\n\nAll code samples in this guide can be viewed in a single, runnable script. Available languages:\n\n- [Java](../examples/java/ControlPrograms.java)\n- [Node](../examples/node/controlPrograms.js)\n- [Ruby](../examples/ruby/control_programs.rb)\n\n## Account control programs\n\nThe most basic type of control program is an account control program, which defines a set of keys and a quorum of signatures required to spend asset units. When you create an account, you provide a set of root keys and a quorum. Then each time you deposit assets into an account, Chain Core derives a new set of child public keys from the account root keys and creates a unique, one-time-use account control program requiring the quorum of signatures you specified.\n\nAlthough all control programs in one account are controlled by keys derived from the same root keys, it is impossible for other participants on the blockchain to recognize any relationship between them. This technique (known as hierarchical deterministic key derivation) ensures that only the participant on the blockchain with whom you transact will know that a specific control program is yours. To everyone else, the creator of the control program will be unknown. For more information about key derivation, see the [Chain key derivation specification](../../protocol/specifications/chainkd.md).\n\n### Receivers\n\nSince version 1.1, the Chain Core accounts API does not expose account control programs directly. Instead, you can generate **receiver** objects, which wrap account control programs with additional payment information, such as expiration dates. If control programs are like payment addresses, then receivers are like invoices, which contain additional information on top of the addresses themselves.\n\n### Example\n\nIf Alice wishes to be paid gold by an external party (Bob), she first creates a new receiver in her account:\n\n$code create-receiver ../examples/java/ControlPrograms.java ../examples/ruby/control_programs.rb ../examples/node/controlPrograms.js\n\nThe new receiver contains a control program for the specified account. Alice then serializes the receiver and delivers it to Bob, who deserializes it and sends it to the transaction builder:\n\n$code build-transaction ../examples/java/ControlPrograms.java ../examples/ruby/control_programs.rb ../examples/node/controlPrograms.js\n\n## Retirement control programs\n\nA retirement control program is a very simple control program with a single predicate: `FAIL`. This ensures that asset units sent to this type of control can never be spent, and are thus removed from circulation on the blockchain.\n\n### Example\n\nTo retire units of gold from Alice's account, we use the `SpendFromAccount` and `Retire` actions on the `Transaction.QueryBuilder`, which prompts Chain Core to create the retirement control program and spent to it from Alice's account.\n\n$code retire ../examples/java/ControlPrograms.java ../examples/ruby/control_programs.rb ../examples/node/controlPrograms.js\n\n## Custom control programs\n\nThe [Chain Virtual Machine](../../protocol/specifications/vm1.md) supports custom control programs. We are currently developing a [high level language](../../protocol/papers/blockchain-programs.md#ivy) that will enable developers to write custom control programs in Chain Core. Additionally, we work directly with our enterprise customers to design, audit, and implement custom control programs for production deployment. For more information, visit the [Enterprise page](https://chain.com/enterprise).\n"},{"Url":"/docs/1.1/core/build-applications/keys.md","Body":"# Keys\n\n## Introduction\n\nCryptographic private keys are the primary authorization mechanism on a blockchain. They control both the issuance and transfer of assets. Each transaction is signed using the specific private keys required for the issuance or transfer it proposes, and the signature is checked against the corresponding public keys recorded in the earlier transaction being spent, or the asset type being issued, in order to determine the new transaction’s validity.\n\nIn simple cases, an asset or an account will define a single key required for issuance or for transfers. But it’s possible to define multiple keys for different usage patterns or to achieve different levels of security. For example, a high-value asset may be defined with two signing keys, requiring two separate parties to sign each issuance transaction. A joint account may also be defined with two signing keys, requiring only one, from either party, to sign each transfer. The threshold number of signatures required is called a quorum.\n\nIn a production environment, private keys are generated within an HSM (hardware security module) and never leave it. Their corresponding public keys are exported for use within Chain Core. In order to issue or transfer asset units on a blockchain, a transaction is created in Chain Core and sent to the HSM for signing. The HSM signs the transaction without ever revealing the private key. Once signed, the transaction can be submitted to the blockchain successfully.\n\nFor development environments, Chain Core provides a convenient Mock HSM. The Mock HSM API is identical to the HSM API in [Chain Core Enterprise Edition](https://chain.com/enterprise), providing a seamless transition from development to production. It is important to note that the Mock HSM does not provide the security of a real HSM.\n\n## Overview\n\nThis guide will walk you through the basic key operations:\n\n* [Create key](#create-key) (in the Mock HSM)\n* [Load key](#load-key) (into the HSM Signer)\n* [Sign transaction](#sign-transaction) (with the Mock HSM)\n\n### Sample Code\n\nAll code samples in this guide can be viewed in a single, runnable script. Available languages:\n\n- [Java](../examples/java/Keys.java)\n- [Node](../examples/node/keys.js)\n- [Ruby](../examples/ruby/keys.rb)\n\n## Create key\n\nCreate a new key in the Mock HSM. (Requires a context to have been created with `new Context()`.)\n\n$code create-key ../examples/java/Keys.java ../examples/ruby/keys.rb ../examples/node/keys.js\n\n## Load key\n\nTo be able to sign transactions, load the key into the HSM Signer, which will communicate with the Mock HSM.\n\n$code signer-add-key ../examples/java/Keys.java ../examples/ruby/keys.rb ../examples/node/keys.js\n\n## Sign transaction\n\nOnce a transaction is built, send it to the HsmSigner for signing.\n\n$code sign-transaction ../examples/java/Keys.java ../examples/ruby/keys.rb ../examples/node/keys.js\n"},{"Url":"/docs/1.1/core/build-applications/multiparty-trades.md","Body":"# Multiparty Trades\n\n## Overview\n\n This guide demonstrates how to use the Chain Core API to create complex transactions that are:\n\n- **Multi-party**: Multiple accounts--on the same core or different cores--can participate in the same transaction.\n- **Multi-asset**: Multiple assets, originating from any core, can be traded and issued in the same transaction.\n- **Risk-free**: Within a single transaction, each party can declare exactly what they will pay, and what they expect to receive. All transfers and issuances in the transaction happen atomically: together, at the same instant, and only when all conditions specified by all parties are met.\n\nPlease make sure you’ve read [Transaction Basics](../build-applications/transaction-basics.md) before continuing.\n\n### Sample Code\n\nAll code samples in this guide can be viewed in a single, runnable script. Available languages:\n\n- [Java](../examples/java/MultipartyTrades.java)\n- [Node](../examples/node/multipartyTrades.js)\n- [Ruby](../examples/ruby/multiparty_trades.rb)\n\n## Example: Trading within the same core and application\n\nIn this example, Alice and Bob both have accounts on the same core. Alice holds Alice Dollars, and Bob holds Bob Bucks. Their accounts are managed by a central application that has access to both of their HSMs.\n\nIn this setting, the application can trade Alice’s Alice Dollars for Bob’s Bob Bucks directly, within a single transaction:\n\n$code same-core-trade ../examples/java/MultipartyTrades.java ../examples/ruby/multiparty_trades.rb ../examples/node/multipartyTrades.js\n\nThis is the simplest possible scenario for a multi-asset trade between two accounts. Because the assets and accounts are local to the same core, the application can name all of the relevant accounts and assets in the space of a single `build` call. And since the application has access to both Alice’s and Bob’s HSMs, it can sign for both parties simultaneously.\n\n## Example: Trading between cores\n\nSuppose that we want to conduct a similar trade as above, but Alice’s account and Bob’s account are now on different cores, and managed by separate applications.\n\nAlice initiates the trade by building a transaction that stipulates what she will pay and what she expects to receive. Since the Bob Buck asset is not local to her core, Alice can’t refer to it by its human-readable alias. Instead, she has to know its asset ID from an out-of-band source, like an email from Bob.\n\n$code build-trade-alice ../examples/java/MultipartyTrades.java ../examples/ruby/multiparty_trades.rb ../examples/node/multipartyTrades.js\n\nUnlike the transaction in the first example, this transaction is _unbalanced_: there are 50 Alice Dollars in the inputs that appear in no output, and 100 Bob Bucks that appear in an output but no input. If Alice were to sign and submit the transaction at this point, it would be rejected by the blockchain.\n\nInstead, Alice provides a signature that commits her to her payment of Alice Dollars only if she receives Bob Bucks in the same transaction. The partial transaction will need more actions stacked on top of it to become complete, so Alice must explicitly allow additional actions to be added before she signs it:\n\n$code sign-trade-alice ../examples/java/MultipartyTrades.java ../examples/ruby/multiparty_trades.rb ../examples/node/multipartyTrades.js\n\nNow Alice has a signed, partial transaction that she can send to someone who can give her Bob Bucks in exchange for her Alice Dollars:\n\n$code base-transaction-alice ../examples/java/MultipartyTrades.java ../examples/ruby/multiparty_trades.rb ../examples/node/multipartyTrades.js\n\nAlice takes the raw transaction, `baseTransactionFromAlice`, and emails it to Bob. Now Bob can fill in the rest of the trade, using the partially-signed transaction from Alice as a base transaction:\n\n$code build-trade-bob ../examples/java/MultipartyTrades.java ../examples/ruby/multiparty_trades.rb ../examples/node/multipartyTrades.js\n\nAs was the case with Alice, Bob can’t refer to non-local assets by alias, so he refers to the Alice Dollar asset by its asset ID.\n\nNote that the transaction now has all of the components of the trade described in the first example: it contains payments from Alice and Bob of their respective currencies, and names the other party as the recipients.\n\nWith Bob’s addition, the transaction’s incoming and outgoing assets are now balanced. But it’s not a valid transaction without his signature. Since Bob is the last participant in the trade, he does _not_ allow additional actions before he signs the transaction:\n\n$code sign-trade-bob ../examples/java/MultipartyTrades.java ../examples/ruby/multiparty_trades.rb ../examples/node/multipartyTrades.js\n\nFinally, with the balanced transaction signed by both parties, Bob can submit the transaction to the blockchain network:\n\n$code submit-trade-bob ../examples/java/MultipartyTrades.java ../examples/ruby/multiparty_trades.rb ../examples/node/multipartyTrades.js\n"},{"Url":"/docs/1.1/core/build-applications/queries.md","Body":"# Queries\n\n## Introduction\n\nData structures in the Chain Core API are represented as key-value JSON objects. This includes local objects, such as accounts and keys, and global objects, such as transactions and assets. To retrieve data, you perform a query with optional parameters. By default, each query returns a time-ordered list of objects beginning with the most recent.\n\n### Filters\n\nFilters allow narrowing results to those matching a set of supplied parameters.\n\nA filter is composed of one or more **terms**, with multiple terms joined with `AND` and `OR`. Each term contains a **property**, **operator**, and **value**. Each term targets a specific field in the key-value (JSON) object (see [API Objects](../reference/api-objects.md)). Terms can be grouped together in a **scope** to target a specific array of sub-objects within an object.\n\nFor example, to list transactions where a specific account spends a specific asset, you would create a filter with two terms, scoped to the inputs:\n\n```\ninputs(account_alias='alice' AND asset_alias='gold')\n```\n\n#### Properties\n\nAny field in a JSON object can be used as a filter property. To use a field that is nested within another field, provide the path to it, starting with the outermost parent object. For example:\n\n```\nasset_definition.issuer.name\n```\n\nNote: although you can create asset definitions, tags, and reference data with any valid JSON object, you can only query fieldnames that contain **letters**, **numbers**, and **underscores**.\n\n#### Operators\n\nFilters currently support only the `=` operator, which allows you to search for exact matches of **string** and **integer** values. Other data types, such as booleans, are not supported.\n\nThere are two methods of providing search values to the `=` operator. First, you can include them inline, surrounded by single quotes:\n\n```\nalias='alice'\n```\n\nAlternatively, you can specify a parameterized filter, without single quotes:\n\n```\nalias=$1 OR alias=$2\n```\n\nWhen using parameterized filters, you should also provide an ordered set of values for the parameters:\n\n```\n[\"Bob's account\", \"Bob's dog's account\"]\n```\n\nThe SDK supports both parameterized and non-parameterized filters. The dashboard does **not** support parameterized filters.\n\n#### Scope\n\nThe transaction object contains an array of other objects: an `inputs` array and an `outputs` array. The `inputs()` and `outputs()` filter scopes allow targeting a specific object within those arrays.\n\nFor example, the following will return transactions where Alice sent gold to Bob:\n\n```\ninputs(account_alias='alice' AND asset_alias='gold') AND outputs(account_alias='bob' AND asset_alias='gold')\n```\n\n### Additional parameters\n\nTransaction queries accept time parameters to limit the results within a time window.\n\n| Method             | Description                                                    |\n|--------------------|----------------------------------------------------------------|\n| setStartTime       | Sets the earliest transaction timestamp to include in results. |\n| setEndTime         | Sets the latest transaction timestamp to include in results.   |\n\nBalance and unspent output queries accept a timestamp parameter to report ownership at a specific moment in time.\n\n| Method             | Description                                                                |\n|--------------------|----------------------------------------------------------------------------|\n| setTimestamp       | Sets a timestamp at which to calculate balances or return unspent outputs. |\n\n### Special Case: Balance queries\n\nAny balance on the blockchain is simply a summation of unspent outputs. For example, the balance of Alice’s account is a summation of all the unspent outputs whose control programs were created from the keys in Alice’s account.\n\nUnlike other queries in Chain Core, balance queries do not return Chain Core objects, only simple sums over the `amount` fields in a specified list of unspent output objects.\n\n##### Sum By\n\nBalance sums are totalled by `asset_id` and `asset_alias` by default, but it is also possible to query more complex sums. For example, if you have a network of counterparty-issued IOUs, you may wish to calculate the account balance of all IOUs from different counterparties that represent the same underlying currency.\n\n## Overview\n\nThis guide will walk you through several examples of queries:\n\n* Transactions\n* Assets\n* Accounts\n* Unspent Outputs\n* Balances\n\n### Sample Code\n\nAll code samples in this guide can be viewed in a single, runnable script. Available languages:\n\n- [Java](../examples/java/Queries.java)\n- [Node](../examples/node/queries.js)\n- [Ruby](../examples/ruby/queries.rb)\n\n## Transactions\n\nList all transactions involving Alice’s account:\n\n$code list-alice-transactions ../examples/java/Queries.java ../examples/ruby/queries.rb ../examples/node/queries.js\n\nList all transactions involving the local Core:\n\n$code list-local-transactions ../examples/java/Queries.java ../examples/ruby/queries.rb ../examples/node/queries.js\n\n## Assets\n\nList all assets created in the local Core:\n\n$code list-local-assets ../examples/java/Queries.java ../examples/ruby/queries.rb ../examples/node/queries.js\n\nList all assets with `USD` as the `currency` in the asset definition:\n\n$code list-usd-assets ../examples/java/Queries.java ../examples/ruby/queries.rb ../examples/node/queries.js\n\n## Accounts\n\nList all accounts with `checking` as the `type` in the account tags:\n\n$code list-checking-accounts ../examples/java/Queries.java ../examples/ruby/queries.rb ../examples/node/queries.js\n\n## Unspent Outputs\n\nList all unspent outputs controlled by Alice’s account:\n\n$code list-alice-unspents ../examples/java/Queries.java ../examples/ruby/queries.rb ../examples/node/queries.js\n\n## Balances\n\nList the asset IOU balances in Bank1’s account:\n\n$code account-balance ../examples/java/Queries.java ../examples/ruby/queries.rb ../examples/node/queries.js\n\nGet the circulation of the Bank 1 USD IOU on the blockchain:\n\n$code usd-iou-circulation ../examples/java/Queries.java ../examples/ruby/queries.rb ../examples/node/queries.js\n\nList the asset IOU balances in Bank1’s account, summed by currency:\n\n$code account-balance-sum-by-currency ../examples/java/Queries.java ../examples/ruby/queries.rb ../examples/node/queries.js\n"},{"Url":"/docs/1.1/core/build-applications/real-time-transaction-processing.md","Body":"# Real-time Transaction Processing\n\n## Overview\n\nYou can use **transaction feeds** to process transactions as they arrive on the blockchain. This is helpful for real-time applications such as notifications or live-updating interfaces. Transaction feeds work efficiently, without the need for polling or keeping state in your application.\n\n### Sample Code\n\nAll code samples in this guide can be viewed in a single, runnable script. Available languages:\n\n- [Java](../examples/java/RealTimeTransactionProcessing.java)\n- [Node](../examples/node/realTimeTransactionProcessing.js)\n- [Ruby](../examples/ruby/real_time_transaction_processing.rb)\n\n## Example\n\nTo illustrate how to use transaction feeds, we'll create an application that prints information about new [local](../learn-more/global-vs-local-data.md) transactions as they arrive.\n\n#### Creating and retrieving a transaction feed\n\nTransaction feeds can be created either in the Chain Core Dashboard, or from your application. When creating a feed, you can provide a [transaction filter expression](../build-applications/queries.md) so that the feed only contains transactions matching the filter. If you don't supply a filter, then the feed will contain all new transaction activity on the blockchain.\n\nFirst, we'll create a new feed programmatically, setting the filter expression to `is_local='yes'`.\n\n$code create-feed ../examples/java/RealTimeTransactionProcessing.java ../examples/ruby/real_time_transaction_processing.rb ../examples/node/realTimeTransactionProcessing.js\n\nFrom now on, we can retrieve this feed using its alias:\n\n$code get-feed ../examples/java/RealTimeTransactionProcessing.java ../examples/ruby/real_time_transaction_processing.rb ../examples/node/realTimeTransactionProcessing.js\n\nThe Chain Core will record how much of a feed has been processed, so your application doesn't have to keep track itself.\n\n#### Handling incoming transactions from the feed\n\nTo process a transaction, our example application will print out some basic information to the console:\n\n$code processor-method ../examples/java/RealTimeTransactionProcessing.java ../examples/ruby/real_time_transaction_processing.rb ../examples/node/realTimeTransactionProcessing.js\n\nNext, we'll set up an infinite loop that reads from the transaction feed, and sends each incoming transaction to our processor function:\n\n$code processing-loop ../examples/java/RealTimeTransactionProcessing.java ../examples/ruby/real_time_transaction_processing.rb ../examples/node/realTimeTransactionProcessing.js\n\nNote that the processing loop **acknowledges** consumption of the current item. (In most platforms, this is a call to an `ack` method; in Node, this is achieved by passing `true` to the `next` callback). This updates the transaction feed via an API call so that if your application terminates for any reason, it can pick back up from the point that `ack` was last called. It's safest, but not necessary, to acknowledge on every cycle of the processing loop.\n\nThe body of the processing loop will run once for every new transaction that arrives on the blockchain. If you've already processed all available transactions, then the call to `next` will **block the active thread** until a transaction matching the filter arrives. Because of this blocking behavior, we'll run the processing loop in its own thread:\n\n$code processing-thread ../examples/java/RealTimeTransactionProcessing.java ../examples/ruby/real_time_transaction_processing.rb ../examples/node/realTimeTransactionProcessing.js\n\n#### Testing the example\n\nIn order to push some transactions through the transaction feed, we'll try generating a sample transaction:\n\n$code issue ../examples/java/RealTimeTransactionProcessing.java ../examples/ruby/real_time_transaction_processing.rb ../examples/node/realTimeTransactionProcessing.js\n\nAlmost immediately, we should see the following output in the console:\n\n```\nNew transaction at Sun Oct 16 17:08:53 PDT 2016\n  ID: 7735ac967928ef04436dcaf836d22e17ab0d3fc72b769361e8506642e515ab65\n  Input 0\n    Type: issue\n    Asset: gold\n    Amount: 100\n    Account: null\n  Output 0\n    Type: control\n    Purpose: receive\n    Asset: gold\n    Amount: 100\n    Account: alice\n```\n\nLet's try submitting another transaction:\n\n$code transfer ../examples/java/RealTimeTransactionProcessing.java ../examples/ruby/real_time_transaction_processing.rb ../examples/node/realTimeTransactionProcessing.js\n\nThis should result in the following output:\n\n```\nNew transaction at Sun Oct 16 17:08:55 PDT 2016\n  ID: a934af2bef5187ad17bf51c4631aba44339478495cad11900acd95d5e510d91c\n  Input 0\n    Type: spend\n    Asset: gold\n    Amount: 100\n    Account: alice\n  Output 0\n    Type: control\n    Purpose: change\n    Asset: gold\n    Amount: 50\n    Account: alice\n  Output 1\n    Type: control\n    Purpose: receive\n    Asset: gold\n    Amount: 50\n    Account: bob\n```\n\n## Subtleties\n\n#### Order of transactions\n\nA transaction feed provides transactions in the order they are arranged on the blockchain, from earliest to most recent, starting with transactions that arrive on the blockchain immediately after the feed was created.\n\n#### Efficiency\n\nUnder the hood, the SDK reads data from a transaction feed using a long-polling mechanism. This ensures that network round trips between your application and the Chain Core are kept to a minimum.\n\n#### When to acknowledge in the processing loop\n\nAcknowledging each item as you consume it in your processing loop is the safest strategy, but it's not the only strategy. If you'd prefer to cut down on API calls to the Chain Core, you can acknowledge less frequently. The less frequently you acknowledge, the more risk you'll have of repeating some processing if your application terminates unexpectedly.\n\nTransaction feeds provide *at-least-once* delivery of transactions; occasionally, a transaction may be delivered multiple times. Regardless of how frequently you acknowledge, it's a good idea to design your transaction processing to be **idempotent**, so that your application can process a given transaction twice or more without adverse effects.\n\n#### Concurrency\n\nAs mentioned in the example, reading from a transaction feed may block your active process, so if your application does more than just consume a transaction feed, you should run the processing loop within its own thread.\n\nIn general, you should consume a transaction feed in one and only one thread. In particular, you'll want to make sure that `next` and `ack` are called serially, within a single thread.\n"},{"Url":"/docs/1.1/core/build-applications/transaction-basics.md","Body":"# Transaction Basics\n\n## Introduction\n\nA blockchain consists of an immutable set of cryptographically linked transactions. Each transaction contains one or more **inputs**, and one or more **outputs**.\n\nAn input either issues new units of an asset, or transfers existing units by naming an output of an earlier transaction as the source for the transfer.\n\nOutputs take the asset units from the inputs and define how they will be allocated. A single output indicates an asset amount along with a control program that specifies how that amount can be spent in the future. Or, an output can retire units of the asset, removing those units from circulation.\n\nA transaction can have many inputs and outputs that consist of many different types of asset, many different sources, and many different destinations. All actions within a transaction (issuing, spending, controlling, and retiring assets) occur simultaneously, as a single, atomic operation. There is never any point where a transaction is only partially applied.\n\n### Asset balancing\n\nWithin a transaction, the total amount of assets in the inputs must equal the total amount of assets in the outputs. To create new asset units, we issue in an input and control them with one or more outputs. To transfer asset units, we spend them in an input and control them with one or more outputs. To retire assets units, we spend them in an input and retire them in an output.\n\nAny combination of inputs and outputs can be used in a single transaction, as long as what goes in is what comes out.\n\n### Consuming entire unspent outputs\n\nWhen creating an input that spends an earlier transaction’s output, the entire amount in that output must be consumed. If you don't want to transfer the entire amount of the output to your intended recipient, you must make change back to your account. This is analogous to cash--if you have a twenty-dollar bill and want to spent ten dollars, you need to get change.\n\nAs a result, spending a single input often requires two outputs--one output for the intended recipient, and one output for change back to the account where the asset units came from. In general, Chain Core will automatically manage change outputs for you, so you don't have to worry about this in your application code.\n\n### Combining unspent outputs\n\nSome payments may require more asset units than are available in any single unspent output you control. When spending from an account, the Chain Core will automatically select unspent outputs to satisfy your payment as long as the account controls enough units of the asset in total.\n\n## Overview\n\nThis guide describes the structure of transactions, and how to use the Chain Core API and SDK to create and use them. There are code examples for several types of basic transactions, including:\n\n* Asset issuance\n* Simple payment\n* Multi-asset payment\n* Asset retirement\n\nIf you haven't already, you should first check out the [5-Minute Guide](../get-started/five-minute-guide.md). For advanced transaction features, see [Multiparty Trades](../build-applications/multiparty-trades.md).\n\n### Sample Code\n\nAll code samples in this guide can be viewed in a single, runnable script. Available languages:\n\n- [Java](../examples/java/TransactionBasics.java)\n- [Node](../examples/node/transactionBasics.js)\n- [Ruby](../examples/ruby/transaction_basics.rb)\n\n## Creating transactions\n\nCreating a transaction consists of three steps:\n\n1. **Build transaction**: Define what the transaction is supposed to do: issue new units of an asset, spend assets held in an account, control assets with an account, etc.\n2. **Sign transaction**: Authorize the spending of assets or the issuance of new asset units using private keys.\n3. **Submit transaction**: Submit a complete, signed transaction to the blockchain, and propagate it to other cores on the network.\n\n### Build transaction\n\nRather than forcing you to manipulate inputs, outputs and change directly, the Chain Core API allows you to build transactions using a list of high-level **actions**.\n\nThere are seven types of actions:\n\nAction                                  | Description\n----------------------------------------|------------------------------------------------------------------------------------\nIssue                                   | Issues new units of a specified asset.\nSpend from account                      | Spends units of a specified asset from a specified account. Automatically handles locating outputs with enough units, and the creation of change outputs.\nSpend an unspent output from an account | Spends an entire, specific unspent output in an account. Change must be handled manually, using other actions.\nControl with account                    | Receives units of a specified asset into a specified account.\nControl with receiver                   | Receives units of an asset into a receiver, which contains a control program and supplementary payment information, such as an expiration date. Used when making a payment to an external party/account in another Chain Core.\nRetire                                  | Retires units of a specified asset.\nSet transaction reference data          | Sets arbitrary reference data on the transaction.\n\n#### Reference data\n\nYou can annotate transactions with arbitrary reference data, which will be committed immutably to the blockchain alongside other details of the transaction. Reference data can be specified for the entire transaction, as well as for each action.\n\nAction-level metadata will surface in the relevant inputs and ouputs. For example, the sender and recipient in a simple payment may each wish to set reference data for the actions that are directly relevant to them.\n\n### Sign transaction\n\nIn order for a transaction to be accepted into the blockchain, its inputs must contain valid signatures. For issuance inputs, the signature must correspond to public keys named in the issuance program. For spending inputs, the signature must correspond to the public keys named in the control programs of the outputs being spent.\n\nTransaction signing provides the blockchain with its security. Strong cryptography prevents everyone--even the operators of the blockchain network--from producing valid transaction signatures without the relevant private keys.\n\nThe Chain Core SDK assumes that private keys are held within an HSM controlled by the user. The SDK includes an `HsmSigner` interface that communicates with HSMs to sign transactions. For development, each Chain Core provides a Mock HSM that can generate public/private keypairs and sign transactions. It is important to note that the Mock HSM does not provide the security of a real HSM and, in a production setting, the Chain Core does not hold private keys and never signs transactions.\n\n### Submit transaction\n\nOnce a transaction is balanced and all inputs are signed, it is considered valid and can be submitted to the blockchain. The local core will forward the transaction to the generator, which adds it to the blockchain and propagates it to other cores on the network.\n\nThe Chain Core API does not return a response until either the transaction has been added to the blockchain and indexed by the local core, or there was an error. This allows you to write your applications in a linear fashion. In general, if a submission responds with success, the rest of your application may proceed with the guarantee that the transaction has been committed to the blockchain.\n\n## Examples\n\n### Asset issuance\n\nIssue 1000 units of gold to Alice.\n\n#### Within a Chain Core\n\n$code issue-within-core ../examples/java/TransactionBasics.java ../examples/ruby/transaction_basics.rb ../examples/node/transactionBasics.js\n\n#### Between two Chain Cores\n\nFirst, Bob creates a receiver in his account, which he can serialize and send to the issuer of gold.\n\n$code create-bob-issue-receiver ../examples/java/TransactionBasics.java ../examples/ruby/transaction_basics.rb ../examples/node/transactionBasics.js\n\nThe issuer then builds, signs, and submits a transaction, sending gold to Bob's receiver.\n\n$code issue-to-bob-receiver ../examples/java/TransactionBasics.java ../examples/ruby/transaction_basics.rb ../examples/node/transactionBasics.js\n\n### Simple payment\n\nAlice pays 10 units of gold to Bob.\n\n#### Within a Chain Core\n\n$code pay-within-core ../examples/java/TransactionBasics.java ../examples/ruby/transaction_basics.rb ../examples/node/transactionBasics.js\n\n#### Between two Chain Cores\n\nFirst, Bob creates a receiver in his account, which he can serialize and send to Alice.\n\n$code create-bob-payment-receiver ../examples/java/TransactionBasics.java ../examples/ruby/transaction_basics.rb ../examples/node/transactionBasics.js\n\nAlice then builds, signs, and submits a transaction, sending gold to Bob's receiver.\n\n$code pay-between-cores ../examples/java/TransactionBasics.java ../examples/ruby/transaction_basics.rb ../examples/node/transactionBasics.js\n\n### Multi-asset payment\n\nAlice pays 10 units of gold and 20 units of silver to Bob.\n\n#### Within a Chain Core\n\n$code multiasset-within-core ../examples/java/TransactionBasics.java ../examples/ruby/transaction_basics.rb ../examples/node/transactionBasics.js\n\n#### Between two Chain Cores\n\nCurrently, the transaction builder API assigns each receiver to its own output, which means that a single receiver can only be used to receive a single asset type. It's important for Bob not to re-use receivers, so he creates one for each asset payment he will receive. He serializes both and sends them to Alice.\n\n$code create-bob-multiasset-receiver ../examples/java/TransactionBasics.java ../examples/ruby/transaction_basics.rb ../examples/node/transactionBasics.js\n\nAlice then builds, signs, and submits a transaction, sending gold and silver to Bob's receivers.\n\n$code multiasset-between-cores ../examples/java/TransactionBasics.java ../examples/ruby/transaction_basics.rb ../examples/node/transactionBasics.js\n\n### Asset retirement\n\nAlice retires 50 units of gold from her account.\n\n$code retire ../examples/java/TransactionBasics.java ../examples/ruby/transaction_basics.rb ../examples/node/transactionBasics.js\n\n### Multiparty trades\n\nFor examples of advanced transactions, such as trading multiple assets across multiple cores, see [Multiparty Trades](../build-applications/multiparty-trades.md).\n"},{"Url":"/docs/1.1/core/build-applications/unspent-outputs.md","Body":"# Unspent Outputs Guide\n\n## Introduction\n\nEach new transaction in the blockchain consumes some unspent outputs and creates others. An output is considered unspent when it has not yet been used as an input to a new transaction. All asset units on a blockchain exist in the unspent output set.\n\n## Overview\n\nThis guide will walk you through the basic functions of an unspent output:\n\n* [List unspent outputs](#list-unspent-outputs)\n* [Spend unspent outputs](#spend-unspent-outputs)\n\n### Sample Code\n\nAll code samples in this guide can be viewed in a single, runnable script. Available languages:\n\n- [Java](../examples/java/UnspentOutputs.java)\n- [Node](../examples/node/unspentOutputs.js)\n- [Ruby](../examples/ruby/unspent_outputs.rb)\n\n## List unspent outputs\n\nList all unspent outputs in Alice's account:\n\n$code alice-unspent-outputs ../examples/java/UnspentOutputs.java ../examples/ruby/unspent_outputs.rb ../examples/node/unspentOutputs.js\n\nList all unspent outputs of the gold asset:\n\n$code gold-unspent-outputs ../examples/java/UnspentOutputs.java ../examples/ruby/unspent_outputs.rb ../examples/node/unspentOutputs.js\n\n## Spend unspent outputs\n\nWhen building a transaction with the “spend from account” action type, Chain Core automatically selects one or more unspent outputs sufficient to cover the amount to be spent, and automatically returns any excess to your account by adding a change output to the transaction. However, if you want to spend specific unspent outputs, you can use the “spend unspent output from account” action type. You do not specify an amount or asset for the action, but rather spend the entire amount of the asset controlled in the unspent output. Unlike “spend from account,” this action type does not automatically make change. If you wish to spend only a portion of the unspent output, you must explicitly make change back to your account by adding a “control with account” action.\n\n## Example\n\n### Spend entire unspent output\n\nGiven the following unspent output in Alice's account:\n\n```\n{\n  \"id\": \"997de5f311df2828d64a62cda16425c2a957fd386ca2e332467c9a1ef98202cd\",\n  \"transaction_id\": \"ad8e8aa37b0969ec60151674c821f819371152156782f107ed49724b8edd7b24\",\n  \"position\": 1,\n  \"asset_id\": \"d02e4a4c3b260ae47ba67278ef841bbad6903bda3bd307bee2843246dae07a2d\",\n  \"asset_alias\": \"gold\",\n  \"amount\": 100,\n  \"account_id\": \"acc0KFJCM6KG0806\",\n  \"account_alias\": \"alice\",\n  \"control_program\": \"766baa2056d4bfb5fcc08a13551099e596ebb9982d2c913285ef6751767fda0d111ddc3f5151ad696c00c0\",\n}\n```\n\nBuild a transaction spending all units of gold in the unspent output to Bob's account:\n\n$code build-transaction-all ../examples/java/UnspentOutputs.java ../examples/ruby/unspent_outputs.rb ../examples/node/unspentOutputs.js\n\n### Spend partial unspent output\n\nGiven the following unspent output in Alice's account:\n\n```\n{\n  \"id\": \"997de5f311df2828d64a62cda16425c2a957fd386ca2e332467c9a1ef98202cd\",\n  \"transaction_id\": \"ad8e8aa37b0969ec60151674c821f819371152156782f107ed49724b8edd7b24\",\n  \"position\": 1,\n  \"asset_id\": \"d02e4a4c3b260ae47ba67278ef841bbad6903bda3bd307bee2843246dae07a2d\",\n  \"asset_alias\": \"gold\",\n  \"amount\": 100,\n  \"account_id\": \"acc0KFJCM6KG0806\",\n  \"account_alias\": \"alice\",\n  \"control_program\": \"766baa2056d4bfb5fcc08a13551099e596ebb9982d2c913285ef6751767fda0d111ddc3f5151ad696c00c0\",\n}\n```\n\nBuild a transaction spending 40 units of gold in the unspent output to Bob's account, and spending 60 units back to Alice's account as change:\n\n$code build-transaction-partial ../examples/java/UnspentOutputs.java ../examples/ruby/unspent_outputs.rb ../examples/node/unspentOutputs.js\n"},{"Url":"/docs/1.1/core/get-started/configure.md","Body":"# Configure Chain Core\n\n## Overview\n\nWhen you first launch your Chain Core and visit the dashboard at `http://HOST:1999/` (where HOST is the name of the computer where Chain Core is running), you will be presented with three options:\n\n1. [Create a new blockchain](#create-a-new-blockchain)\n2. [Connect to an existing blockchain](#connect-to-an-existing-blockchain)\n3. [Connect to the Chain testnet](#connect-to-the-chain-testnet)\n\nChoosing one of these options configures your Chain Core. You can reset it to its initial unconfigured state at any time by visiting Core Settings in the dashboard.\n\n## Create a new blockchain\n\nThis creates a new blockchain with the Core as the block generator and single block signer. The Core's block-signing key is automatically created in the Mock HSM. The Core's URL and blockchain ID (needed by other Cores wishing to join this network) are available in Core Settings in the dashboard.\n\nFor more information, see [operating a blockchain](../learn-more/blockchain-operators.md).\n\n## Connect to an existing blockchain\n\nThis connects to an existing blockchain whose block generator is already configured. You must supply the following information to join:\n\n* Block generator URL\n* Blockchain ID\n* Network access token (not required when connecting to localhost)\n\nOnce configured, Chain Core will begin downloading blockchain data from the block generator. Once your Core is up to date with the network it will receive new blocks as they are created.\n\nFor more information, see [participating in a blockchain](../learn-more/blockchain-participants.md).\n\n## Connect to the Chain testnet\n\nChain operates a public testnet for development purposes. When initializing Chain Core, choosing \"Connect to Chain Testnet\" will automatically connect to the Chain testnet blockchain.\n\n### Testnet resets\n\n**Chain Testnet is reset weekly**. Your Chain Core will automatically detect this and prompt you to reconnect to the new Chain testnet blockchain.\n"},{"Url":"/docs/1.1/core/get-started/five-minute-guide.md","Body":"# 5-Minute Guide\n\n## Overview\n\nThis guide will walk you through the basic functions of Chain Core:\n\n* [Initialize the SDK](#initialize-the-sdk)\n* [Create keys](#create-keys) (in the Chain Core Mock HSM)\n* [Initialize the HSM Signer](#initialize-the-hsm-signer)\n* [Create an asset](#create-an-asset)\n* [Create an account](#create-an-account)\n* [Issue asset units into an account](#issue-asset-units)\n* [Spend asset units from one account to another](#spend-asset-units)\n* [Retire asset units from an account](#retire-asset-units)\n\n### Sample Code\n\nAll code samples in this guide can be viewed in a single, runnable script. Available languages:\n\n- [Java](../examples/java/FiveMinuteGuide.java)\n- [Node](../examples/node/fiveMinuteGuide.js)\n- [Ruby](../examples/ruby/five_minute_guide.rb)\n\n## Initialize the SDK\n\nCreate an instance of the SDK. By default, the SDK will try to access a core located at `http://localhost:1999`, which is the default if you're running Chain Core locally.\n\n$code create-client ../examples/java/FiveMinuteGuide.java ../examples/ruby/five_minute_guide.rb ../examples/node/fiveMinuteGuide.js\n\n## Create Keys\n\nCreate a new key in the Mock HSM.\n\n$code create-key ../examples/java/FiveMinuteGuide.java ../examples/ruby/five_minute_guide.rb ../examples/node/fiveMinuteGuide.js\n\n## Initialize the HSM Signer\n\nTo be able to sign transactions, load the key into the HSM Signer, which will communicate with the Mock HSM.\n\n$code signer-add-key ../examples/java/FiveMinuteGuide.java ../examples/ruby/five_minute_guide.rb ../examples/node/fiveMinuteGuide.js\n\n## Create an Asset\n\nCreate a new asset, providing an alias, key, and quorum. The quorum is the threshold of keys that must sign a transaction issuing units of the asset.\n\n$code create-asset ../examples/java/FiveMinuteGuide.java ../examples/ruby/five_minute_guide.rb ../examples/node/fiveMinuteGuide.js\n\n## Create an Account\n\nCreate an account, providing an alias, key, and quorum. The quorum is the threshold of keys that must sign a transaction to spend asset units controlled by the account.\n\n$code create-account-alice ../examples/java/FiveMinuteGuide.java ../examples/ruby/five_minute_guide.rb ../examples/node/fiveMinuteGuide.js\n\nCreate a second account to interact with the first account.\n\n$code create-account-bob ../examples/java/FiveMinuteGuide.java ../examples/ruby/five_minute_guide.rb ../examples/node/fiveMinuteGuide.js\n\n## Issue Asset Units\n\nBuild, sign, and submit a transaction that issues new units of the `gold` asset into the `alice` account.\n\n$code issue ../examples/java/FiveMinuteGuide.java ../examples/ruby/five_minute_guide.rb ../examples/node/fiveMinuteGuide.js\n\n## Spend Asset Units\n\nBuild, sign, and submit a transaction that spends units of the `gold` asset from the `alice` account to the `bob` account.\n\n$code spend ../examples/java/FiveMinuteGuide.java ../examples/ruby/five_minute_guide.rb ../examples/node/fiveMinuteGuide.js\n\n## Retire Asset Units\n\nBuild, sign, and submit a transaction that retires units of the `gold` asset from the `bob` account.\n\n$code retire ../examples/java/FiveMinuteGuide.java ../examples/ruby/five_minute_guide.rb ../examples/node/fiveMinuteGuide.js\n"},{"Url":"/docs/1.1/core/get-started/introduction.md","Body":"# Introduction\n\nChain Core is software designed to operate and participate in permissioned blockchain networks. Each network maintains a cryptographically-secured multi-asset shared ledger. Using this ledger, participants can issue digital assets directly to custodians, who can then transfer them to each other in real time with no transactional intermediary. Each Chain Core holds a copy of the ledger and independently validates each update. A federation of block signers ensures global consistency of the ledger.\n\nDigital assets share a common, interoperable format and can represent any units of value that are guaranteed by a trusted issuer — such as currencies, bonds, securities, IOUs, or loyalty points.\n\n## Chain Core Developer Edition\n\nChain Core Developer Edition is a free, downloadable version of Chain Core that is [open source](https://github.com/chain/chain) and licensed under [AGPL](https://github.com/chain/chain/blob/main/LICENSE). Individuals and organizations can use Chain Core Developer Edition to learn, experiment, and build prototypes.\n\nChain Core Developer Edition can run locally on Mac, Windows, or Linux to create a new blockchain network, connect to an existing blockchain network, or connect to the public Chain Testnet, operated by Chain, Microsoft, and Cornell University’s IC3.\n\n\u003ca href=\"../get-started/install\" class=\"downloadBtn btn success\"\u003eInstall Chain Core\u003c/a\u003e\n\n\n## Join the community\n\nTalk to us on [Twitter](https://twitter.com/chain), [Linkedin](https://www.linkedin.com/company/chain-inc-), [GitHub](https://github.com/chain), and [Slack](https://slack.chain.com).\n\n##  Support\n\n### Developer forum\n\nThe [developer forum](https://support.chain.com) is a great place to ask, answer, and browse community questions.\n\n### Dedicated support\n\nChain offers a dedicated development support retainer that includes priority response times, developer training, and solution development guidance. For more information, [get in touch](https://chain.com/get-in-touch).\n\n## What is a blockchain?\n\nA blockchain, also known as a distributed ledger, is a new type of financial database whose records operate like transferable financial instruments. We refer to these records as digital assets. Unlike a traditional financial database, where one entity is responsible for updating the balances for all participants, a blockchain gives direct control of digital assets to the participants themselves. Each participant maintains a set of private keys that secures their digital assets on a blockchain. When they wish to transfer digital assets to another participant, they must create a ledger update, known as a transaction, and sign it with their private keys. Once the signed transaction is submitted to the blockchain, the ownership of the digital assets is immediately and irreversibly updated for both participants.\n\nThe initial issuance of digital assets onto a blockchain is also controlled by cryptographically signed transactions. Each issuer maintains a set of private keys required to issue a specific type of digital asset. A digital asset can represent any unit of value that is defined by the issuer. Chain Core issues all digital assets into a common, interoperable format: government currencies, corporate bonds, loyalty points, IOUs, internal deposits, and more.\n\nWhether the participants on a blockchain are individuals, companies, or systems, and whether asset transfers span countries, companies, or even divisions within a single company, a blockchain offers a secure, trustless way to issue, manage and transfer financial assets.\n"},{"Url":"/docs/1.1/core/get-started/sdk.md","Body":"# Download Chain Core SDKs\n\nClient libraries for Chain Core are available for the following platforms:\n\n- [Java](#java)\n- [Node.js](#node-js)\n- [Ruby](#ruby)\n\nTo ensure compatibility between your application and Chain Core, choose an SDK version whose major and minor components (`major.minor.x`) match your version of Chain Core.\n\n## Java\n\nThe Java SDK is available via [Maven](https://search.maven.org/#search%7Cga%7C1%7Cchain-sdk-java). Java 7 or greater is required.\n\n**Maven** users should add the following to `pom.xml`:\n\n```\n\u003cdependencies\u003e\n  \u003cdependency\u003e\n    \u003cgroupId\u003ecom.chain\u003c/groupId\u003e\n    \u003cartifactId\u003echain-sdk-java\u003c/artifactId\u003e\n    \u003cversion\u003e1.1.3\u003c/version\u003e\n  \u003c/dependency\u003e\n\u003c/dependencies\u003e\n```\n\n**Gradle** users should add the following to `build.gradle`:\n\n```\ncompile 'com.chain:chain-sdk-java:1.1.3'\n```\n\nYou can also [download the JAR](https://search.maven.org/remotecontent?filepath=com/chain/chain-sdk-java/1.1.3/chain-sdk-java-1.1.3.jar) as a binary.\n\n## Node.js\n\nThe Chain Node.js SDK is available [via npm](https://www.npmjs.com/package/chain-sdk). Node 4 or greater is required.\n\nTo install, add the `chain-sdk` NPM module to your `package.json`, using a tilde range (`~`) and specifying the patch version:\n\n```\n{\n  \"dependencies\": {\n    \"chain-sdk\": \"~1.1.1\"\n  }\n}\n```\n\n## Ruby\n\nThe Ruby SDK is available [via Rubygems](https://rubygems.org/gems/chain-sdk). Ruby 2.1 or greater is required.\n\nTo install, add the following to your `Gemfile`:\n\n```\ngem 'chain-sdk', '~\u003e 1.1.0', require: 'chain'\n```\n"},{"Url":"/docs/1.1/core/get-started/virtualbox-config.md","Body":"# Configure VirtualBox Port Forwarding\n\n\u003cimg src=\"images/virtualbox-config.gif\"/\u003e\n"},{"Url":"/docs/1.1/core/learn-more/authentication.md","Body":"# Authentication\n\n## Introduction\n\nThere are two APIs in Chain Core: the **client API** and the **network API**.\n\nThe client API is used by the SDKs and the dashboard to communicate with Chain Core. The network API is used by [network operators](blockchain-operators.md).\n\nEach API is authenticated using access tokens with HTTP Basic Authentication. \n\nFor convenience, **when accessing from localhost, neither API requires authentication**.\n\n## Creating access tokens\n\n_The instructions in this section require having the Go programming environment installed and the `PATH` variable correctly configured. See [the Chain Core Readme file](https://github.com/chain/chain/blob/main/Readme.md) for details._\n\nBoth client and network access tokens are created in the dashboard. However, when deploying Chain Core to a non-local environment, you will not be able to access the dashboard, because you will not yet have a client access token. Therefore, you must use the `corectl` command line tool to create your first client access token. After that, you can use that access token to login to the dashboard and create additional access tokens.\n\nInstall the `corectl` command line tool:\n\n```bash\ngo install ./cmd/corectl\n```\n\nCreate a **client access token** using `corectl`:\n\n```bash\ncorectl create-token \u003cname\u003e\n```\n\nThe command will return your access token:\n\n```\n\u003cname\u003e:\u003csecret\u003e\n```\n"},{"Url":"/docs/1.1/core/learn-more/blockchain-operators.md","Body":"# Operating a blockchain\n\n## Introduction\n\nThe operators of a blockchain perform four basic functions:\n\n1. Determine who can participate in the blockchain\n2. Gather valid transactions from participants\n2. Generate and sign blocks of valid transactions\n3. Distribute blocks to participants\n\nOne of the blockchain operators is designated as the block generator. The others are designated as block signers. Together, they are responsible for creating new blocks.\n\nEach block contains a consensus program that defines the requirements for creating the next valid block. The consensus program specifies the public key of the block generator (whose signature is required on the next block) and the public keys of a set of block signers with a quorum of signatures that are required on the next block.\n\n## Overview\n\nThis guide will walk you through the basic functions of the blockchain operators:\n\n1. [Creating a new blockchain](#creating-a-new-blockchain)\n2. [Creating blocks](#creating-blocks)\n3. [Permissioning the network](#network-permissions)\n4. [Adding/removing blockchain operators](#adding-removing-blockchain-operators)\n\n### Creating a new blockchain\n\nTo create a new blockchain, the blockchain operators must coordinate to create the initial consensus program and generate the first block (at height 0). The process is as follows:\n\n1. Each block signer initializes a Chain Core as a block signer, creating a network token and a private/public keypair.\n2. Each block signer distributes their block signer URL, network token, and public key to the block generator out of band.\n3. The block generator initializes a Chain Core as a block generator, creating a private/public keypair.\n4. The block generator configures the URL, network token, and public key for each block signer in Chain Core settings.\n5. The block generator creates the initial consensus program (from its public key and the public keys and quorum of the block signers) in Chain Core settings.\n6. The block generator creates the first block, including the initial consensus program, which is automatically distributed to each block signer.\n\nNote: The Chain Core dashboard does not yet support block signer configuration. However, you can use the Chain Core command line tools to configure block generator and block signers manually. See the [block signing guide](configure-block-signers.md).\n\n### Creating blocks\n\n#### Block generator\n\nThe block generator is responsible creating blocks at a defined interval through the following steps:\n\n1. Accept transactions from participants\n2. Validate each transaction to ensure it is properly signed and does not double spend asset units\n3. Generate a block of valid transactions\n4. Sign the block\n5. Gather signatures from the required quorum of block signers\n6. Distribute the block to participants\n\n#### Block signers\n\nOnce the block generator has generated a proposed block, each block signer (up to the quorum) will sign the block through the following steps:\n\n1. Accept a proposed block from the block generator\n2. Validate the block, ensuring that it has never signed a block at the same height\n2. Validate each transaction in the block, ensuring each input is properly signed and does not double spend asset units\n4. Sign the block\n5. Return the signed block to the block generator\n\n### Network permissions\n\nA blockchain can be configured to require network tokens in order to connect to the block generator to submit transactions and receive blocks. The block generator can create a unique network token for each participant that can be revoked at any time.\n\n### Adding/removing blockchain operators\n\nTo adjust the set of blockchain operators, a change must be made to the consensus program, and a quorum of existing block signers must agree to the change. This procedure requires tools still under development and coming soon.\n"},{"Url":"/docs/1.1/core/learn-more/blockchain-participants.md","Body":"# Participating in a blockchain\n\n## Overview\n\nThis guide will walk you through the three types of blockchain participants:\n\n1. [Asset issuer](#asset-issuers)\n2. [Account manager](#account-managers)\n3. [Blockchain observer](#blockchain-observers)\n\nAs well as the basic network functions of all blockchain participants:\n\n1. [Connecting to a blockchain](#connecting-to-a-blockchain)\n2. [Receiving blocks](#receiving-blocks)\n3. [Submitting transactions](#submitting-transactions)\n\n## Blockchain participants\n\n### Asset issuers\n\nAsset issuers define and issue digital assets into circulation on a blockchain. All assets are a guarantee by the issuer of some type of value or rights, from governments currencies, to corporate bonds, to loyalty points, to IOUs, to internal deposits.\n\n### Account managers\n\nAccount managers control asset units on the blockchain. Account managers are cryptographic custodians of digital assets and may be individuals, corporations, financial institutions, or governments.\n\n### Blockchain observers\n\nBlockchain observers, such as auditors, regulators, and analysts, don't issue or control assets. They simply receive blocks and view blockchain data.\n\n## Basic network functions\n\n### Connecting to a blockchain\n\nWhen initializing a Chain Core, a participant can connect to an existing blockchain by providing the following information:\n\n* Block generator URL\n* Blockchain ID\n* Network access token (not required when connecting to localhost)\n\nChain Core will begin downloading blockchain data from the block generator. Once the Core is up to date with the network it will receive new blocks as they are created.\n\n### Receiving blocks\n\nEach participant in a blockchain independently validates each block it receives from the block generator through the following steps:\n\n1. Validate that the block is signed by a quorum of block signers (as defined in the consensus program of the previous block)\n2. Validate each transaction in the block, ensuring each input is properly signed and does not double-spend asset units\n\n### Submitting transactions\n\nWhen a transaction is submitted to the Chain Core API, it is automatically relayed to the block generator for inclusion in the next block. The API does not respond until the transaction appears in a block, or an error occurs. Therefore, once a successful response is received from the API, it is guaranteed that the transaction has been included in a valid block and is final and immutable on the blockchain.\n"},{"Url":"/docs/1.1/core/learn-more/configure-block-signers.md","Body":"# Create blockchain with block signers\n\n## Introduction\n\nThe Chain Core dashboard does not yet support block signer configuration. However, you can use a Chain Core command line tool to manually configure a blockchain with block signers.\n\n### Initialize corectl\n\nIn the Chain Core Mac app, visit the `Developer` menu and select `Open Terminal`. This will initialize the `corectl` command line tool.\n\n## Configuration\n\nThe process of configuration takes a few back and forth steps between the block generator and the block signers.\n\nIn this example, we configure a blockchain with a Chain Core as a block generator on one machine and another Chain Core as a block signer on another machine.\n\n### Signer\n\n**Note**: We do not yet configure the Chain Core.\n\nOn the machine that will host the block-signing core, we first create a block-signing key in the Mock HSM and a network token so the generator can submit blocks to the signer’s network API for signing.\n\n#### Create a block signing key\n\n```bash\ncorectl create-block-keypair\n```\n\nThis prints out the pubkey as a hex string.\n\n```\ncce1791bf3d8bb5e506ec7159bad6a696740712197894336c027dec9fbfb9313\n```\n\n#### Create a network token\n\nNote: `foo` is a user-supplied network token id\n\n```bash\ncorectl create-token -net foo\n```\n\nThis prints out the network token, which can be included as basic auth in the URL when accessing the Chain Core network API.\n\n```\nfoo:25f658b749f154a790c8a3aeb57ea98968f51a991c4771fb072fcbb2fa63b6f7\n```\n\n#### Send details to the block generator\n\nThis happens out of band.\n\n```\npublic key: cce1791bf3d8bb5e506ec7159bad6a696740712197894336c027dec9fbfb9313\n\nBlock signer Chain Core URL with network token: https://foo:25f658b749f154a790c8a3aeb57ea98968f51a991c4771fb072fcbb2fa63b6f7@\u003csigner-host\u003e:\u003csigner-port\u003e\n```\n\n### Generator\n\n#### Configure Chain Core\n\nOn the machine that will host the block generator, generate a block signing key,\nusing the same method as the signer:\n\n```\n$ corectl create-block-keypair\n45ad1f1617d4c6fb8ae5119c524c6266595f0f551c5210dd9f5892b4b39f011f\n```\n\nNow, configure Chain Core to require two signatures on each block: its own, plus one from the separate block signer:\n\n```bash\ncorectl config-generator -k \u003cgenerator-pubkey\u003e \u003cquorum\u003e \u003csigner1-pubkey\u003e \u003csigner1-url-with-network-token\u003e\n```\n\n```bash\ncorectl config-generator -k 45ad1f1617d4c6fb8ae5119c524c6266595f0f551c5210dd9f5892b4b39f011f 2 cce1791bf3d8bb5e506ec7159bad6a696740712197894336c027dec9fbfb9313 https://foo:25f658b749f154a790c8a3aeb57ea98968f51a991c4771fb072fcbb2fa63b6f7@\u003csigner-host\u003e:\u003csigner-port\u003e\n```\n\nThe `-k` flag means this generator is also a block signer, and will provide its\nown signing key. The quorum value, 2, means both signatures are required\non every block.\n\nThis prints out the blockchain id\n\n```\nec95cfab939d7b8dde46e7e1dcd7cb0a7c0cea37148addd70a4a4a5aaab9616c\n```\n\n#### Create a network token for the signer\n\n```bash\ncorectl create-token -net signer\n```\n\nThis prints out the network token,  which can be included as basic auth in the URL when accessing the Chain Core network API.\n\n```\nsigner:ea8b749f154a790c8a3aeb57bb2fa98968f51a991c4771fb072fc25f6563b6f7\n```\n\n###### Send details to signer\n\nThis happens out of band.\n\n```\nBlock generator Chain Core URL: https://\u003cgenerator-url\u003e\nNetwork token: signer:ea8b749f154a790c8a3aeb57bb2fa98968f51a991c4771fb072fc25f6563b6f7\nBlockchain ID: ec95cfab939d7b8dde46e7e1dcd7cb0a7c0cea37148addd70a4a4a5aaab9616c\n```\n\n---\n\n**Note**: If the generator's `cored` process was running during configuration,\nit will need to be restarted to pick up the configuration changes made\nwith `corectl`.\n\n### Signer\n\n#### Configure Chain Core\n\nBack on the first machine, configure Chain Core as block signer.\n\n```bash\ncorectl config\\\n    -t \u003cblock generator network token\u003e \\\n    -k \u003cblock signing public key\u003e \\\n    \u003cblockchain id\u003e \\\n    \u003cblock generator URL\u003e\n```\n\n```bash\ncorectl config\\\n    -t signer:ea8b749f154a790c8a3aeb57bb2fa98968f51a991c4771fb072fc25f6563b6f7 \\\n    -k cce1791bf3d8bb5e506ec7159bad6a696740712197894336c027dec9fbfb9313 \\\n    ec95cfab939d7b8dde46e7e1dcd7cb0a7c0cea37148addd70a4a4a5aaab9616c \\\n    https://\u003cgenerator-host\u003e:\u003cgenerator-port\u003e\n```\n\n**Note**: If the signer's `cored` process was running during configuration,\nit will need to be restarted to pick up the configuration changes made\nwith `corectl`.\n\nOnce the configured cores are running, the block signer will download the initial block from the block generator, and then automatically validate and sign new blocks as the block generator delivers them.\n"},{"Url":"/docs/1.1/core/learn-more/global-vs-local-data.md","Body":"# Global vs Local Data\n\n## Introduction\n\nThere are two types of data in Chain Core: global data that is committed to the blockchain and shared by all cores in a network, and local data that is private to a specific Chain Core. Transactions and assets are the only global objects. All other objects are local.\n\nEach Chain Core privately annotates global transaction and asset objects with relevant local data, if any.\n\nFor field-specific details, see [API Objects](../reference/api-objects.md).\n\n## User-supplied global data\n\nThe transaction builder and the asset builder both include methods for providing user-supplied data that is committed to the blockchain.\n\n* Asset definition\n* Transaction reference data\n\n### Asset definition\n\nAn asset definition is data about an asset that is written to the blockchain when you first issue units of it. It can include any details that you want participants in the blockchain to see. For example:\n\n```\n{\n    \"type\": \"security\",\n    \"sub-type\": \"corporate-bond\",\n    \"entity\": \"Acme Inc.\",\n    \"maturity\": \"2016-09-01T18:24:47+00:00\"\n}\n```\n\nChain Core does not specify any semantics for the asset definition. It is up to the application to determine what data it should contain.\n\n### Transaction reference data\n\nTransaction reference data is included in a transaction when it is written to the blockchain. It is useful for any type of external data related to the transaction. For example:\n\n```\n{\n    \"external_reference\": \"123456\"\n}\n```\n\nTransaction reference data can be included at the top level of a transaction or on individual actions when building a transaction.\n\n## User-supplied local data\n\nThe account builder and the asset builder both include methods for providing user-supplied data that is saved privately in the Chain Core.\n\n### Account and asset aliases\n\nAliases are user-supplied, unique identifiers. They supplement the identifiers generated by Chain Core, which are not meant to be human readable. Using aliases when possible makes operations in the Chain Core API more convenient.\n\n### Account tags\n\nAccounts tags are local data that provide convenient storage and enable [complex queries](../build-applications/queries.md). For example:\n\n```\n{\n    \"type\": \"checking\",\n    \"first_name\": \"Alice\",\n    \"last_name\": \"Jones\",\n    \"user_id\": \"123456\",\n    \"status\": \"enabled\"\n}\n```\n\n### Asset tags\n\nAsset tags are a local-only supplement to the asset definition and can be used to [query the blockchain](../build-applications/queries.md). This is useful for information you do not wish to publish on the blockchain, but rather distribute out of band to relevant parties. Asset tags also allow you to add additional local data about an asset that you didn't create. For example:\n\n```\n{\n    \"internal_rating\": \"B\"\n}\n```\n\n## Examples\n\nAll code samples in this guide can be viewed in a single, runnable script. Available languages:\n\n- [Java](../examples/java/GlobalVsLocalData.java)\n- [Node](../examples/node/globalVsLocalData.js)\n- [Ruby](../examples/ruby/global_vs_local_data.rb)\n\n### Create accounts with tags\n\n$code create-accounts-with-tags ../examples/java/GlobalVsLocalData.java ../examples/ruby/global_vs_local_data.rb ../examples/node/globalVsLocalData.js\n\n### Create assets with tags and definition\n\n$code create-asset-with-tags-and-definition ../examples/java/GlobalVsLocalData.java ../examples/ruby/global_vs_local_data.rb ../examples/node/globalVsLocalData.js\n\n### Create transaction with transaction-level reference data\n\n$code build-tx-with-tx-ref-data ../examples/java/GlobalVsLocalData.java ../examples/ruby/global_vs_local_data.rb ../examples/node/globalVsLocalData.js\n\n### Create transaction with action-level reference data\n\n$code build-tx-with-action-ref-data ../examples/java/GlobalVsLocalData.java ../examples/ruby/global_vs_local_data.rb ../examples/node/globalVsLocalData.js\n"},{"Url":"/docs/1.1/core/reference/api-objects.md","Body":"# API Objects\n\n* [Asset](#asset)\n* [Account](#account)\n* [Transaction](#transaction)\n* [Unspent Output](#unspent-output)\n\n## Asset\n### Field Descriptions\nThe following fields are present in the asset object. Fields with **global** visibility exist as part of the immutable record on the blockchain. Fields with **local** visibility are private annotations that are only visible to the Core.\n\n| Field            | Type        | Visibility          | Description                                                                                  |\n|------------------|-------------|---------------------|----------------------------------------------------------------------------------------------|\n| id               | string      | global              | Globally unique identifier of the asset.                                                     |\n| alias            | string      | local               | User-supplied, locally unique identifier of the asset.                                       |\n| issuance_program | string      | global              | The program defining the keys and quorum of signatures required to issue units of the asset. |\n| quorum           | integer     | global              | The number of keys from which signatures are required to issue units of the asset.           |\n| definition       | JSON\u0026nbsp;object | global              | Arbitrary, user-supplied, key-value data about the asset.                                    |\n| tags             | JSON\u0026nbsp;object | local               | Arbitrary, user-supplied, key-value data about the asset.                                    |\n| is_local         | string      | local               | Denotes if the asset was created in the Core.                                                |\n| keys             | array       | (see\u0026nbsp;[Keys](#keys)) | A list of keys used to generate the `issuance_program`.                                      |\n\n#### Keys\n| Field                 | Type   | Visibility | Description                                                                                |\n|-----------------------|--------|------------|--------------------------------------------------------------------------------------------|\n| asset_pubkey          | string | global     | The public key derived from the `root_xpub` that is present in the `issuance_program`.     |\n| root_xpub             | string | local      | The root extended public key provided at time of asset creation.                           |\n| asset_derivation_path | array  | local      | The hierarchical deterministic derivation path of the `asset_pubkey` from the `root_xpub`. |\n\n\n### Example\n```\n{\n  \"id\": \"...\",\n  \"alias\": \"...\",\n  \"issuance_program: \"...\",\n  \"keys\": [\n    {\n      \"asset_pubkey\": \"...\",\n      \"root_xpub\": \"...\",\n      \"asset_derivation_path\": \"...\"\n    }\n  ],\n  \"quorum\": 1,\n  \"definition\": {},\n  \"tags\": {},\n  \"is_local\": \u003c\"yes\"|\"no\"\u003e\n}\n```\n\n## Account\n### Field Descriptions\nThe following fields are present in the account object. This object is local to Chain Core and not visible on the blockchain. Only the derived, one-time-use public keys and quorum in each account control program are visible on the blockchain (see [transaction output](#output)).\n\n| Field  | Type        | Description                                                                                  |\n|--------|-------------|----------------------------------------------------------------------------------------------|\n| id     | string      | Locally unique identifier of the account.                                                    |\n| alias  | string      | User-supplied, locally unique identifier of the account.                                     |\n| quorum | integer     | The number of keys from which signatures are required to spent asset units from the account. |\n| tags   | JSON\u0026nbsp;object | Arbitrary, user-supplied, key-value data about the account.                                  |\n| keys   | array       | A list of keys used to generate control programs in the account.                             |\n\n#### Keys\n\n| Field                 | Type   | Description                                                                                                               |\n|-----------------------|--------|---------------------------------------------------------------------------------------------------------------------------|\n| root_xpub             | string | The root extended public key provided at time of account creation.                                                        |\n| asset_derivation_path | array  | The hierarchical deterministic derivation path of the `account_xpub` from the `root_xpub`.                                |\n| account_xpub          | string | The extended public key derived from the `root_xpub` from which pubkeys for each control program will be further derived. |\n\n### Example\n\n```\n{\n  \"id\": \"...\",\n  \"alias\": \"...\",\n  \"keys\": [\n    {\n      \"root_xpub\": \"...\",\n      \"account_xpub\": \"...\",\n      \"account_derivation_path\": \"...\"\n    },\n    ...\n  ],\n  \"quorum\": 1,\n  \"tags\": {}\n}\n```\n\n## Transaction\n### Field Descriptions\nThe following fields are present in the transaction object. Fields with **global** visibility exist as part of the immutable record on the blockchain. Fields with **local** visibility are private annotations that are only visible to the Core.\n\n| Field          | Type        | Visibility | Description                                                                                                                                                                                        |\n|----------------|-------------|------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| id             | string      | global     | Globally unique identifier of the transaction.                                                                                                                                                     |\n| timestamp      | string      | global     | Time (in RFC3339 format) that the transaction was committed to the blockchain.                                                                                                                     |\n| is_local       | string      | local      | Denotes if the Core was involved in the transaction, either by: a) issuing units an asset created in the Core, b) spending from an account in the Core, or c) receiving to an account in the Core. |\n| block_id       | string      | global     | The globally unique identifier of the block in which the transaction was committed to the blockchain.                                                                                              |\n| block_height   | integer     | global     | The sequential number of the block in which the transaction was committed to the blockchain.                                                                                                       |\n| position       | integer     | global     | The sequential number of the transaction in the block in which the transaction was committed to the blockchain.                                                                                    |\n| inputs         | array       | global     | A list of source(s) of asset units in the transaction.                                                                                                                                             |\n| outputs        | array       | global     | A list of destination(s) of asset units in the transaction.                                                                                                                                        |\n| reference_data | JSON\u0026nbsp;object | global     | Arbitrary, user-supplied, key-value data about the transaction.                                                                                                                                    |\n\n#### Input\n\n| Field          | Type        | Visibility | Description                                                                                                                                  |\n|----------------|-------------|------------|----------------------------------------------------------------------------------------------------------------------------------------------|\n| type           | string      | global     | Type of input - either `issuance` or `spending`.                                                                                             |\n| is_local       | string      | local      | Denotes that the input involves the Core, either by: a) issuing units an asset created in the Core, b) spending from an account in the Core. |\n| asset_id       | string      | global     | The cryptographic, globally unique identifier of the asset being issued or spent.                                                            |\n| asset_alias    | string      | local      | User-supplied, locally unique identifier of the asset being issued or spent.                                                                 |\n| asset_tags     | JSON\u0026nbsp;object | local      | Arbitrary, user-supplied, key-value data about the asset being issued or spent.                                                              |\n| asset_is_local | string      | local      | Denotes if the asset being issued or spent was created in the Core.                                                                          |\n| amount         | integer     | global     | Amount of units of the asset being issued or spent.                                                                                          |\n| reference_data | JSON\u0026nbsp;object | global     | Arbitrary, user-supplied, key-value data about the input.                                                                                    |\n\n#### Input (if `type` is `spending`)\n\n| Field         | Type        | Visibility | Description                                                                          |\n|---------------|-------------|------------|--------------------------------------------------------------------------------------|\n| account_id    | string      | local      | Locally unique identifier of the account spending the asset units.                   |\n| account_alias | string      | local      | User-supplied, locally unique identifier of the account spending the asset units.    |\n| account_tags  | string      | local      | Arbitrary, user-supplied, key-value data about the account spending the asset units. |\n| spent_output_id | string    | global     | The ID of the previous transaction output being spent in the input.                  |\n\n#### Output\n\n| Field           | Type        | Visibility | Description                                                                                                                                  |\n|-----------------|-------------|------------|----------------------------------------------------------------------------------------------------------------------------------------------|\n| id              | string      | global     | The unique ID of the output.                                                                                                                 |\n| type            | string      | global     | Type of output - either `control` or `retirement`.                                                                                            |\n| is_local        | string      | local      | Denotes that the input involves the Core, either by: a) issuing units an asset created in the Core, b) spending from an account in the Core. |\n| purpose         | string      | local      | Purpose of the output - either a) `receive` if used to receive asset units from another account or external party, or b) `change` if used to create change back to the account, when spending only a portion of the amount of an unspent output in a \"spending\" input.|\n| position        | integer     | global     | The sequential number of the output in the transaction.                                                                                      |\n| asset_id        | string      | global     | The cryptographic, globally unique identifier of the asset being controlled or retired.                                                      |\n| asset_alias     | string      | local      | User-supplied, locally unique identifier of the asset being controlled or retired.                                                           |\n| asset_tags      | JSON\u0026nbsp;object | local      | Arbitrary, user-supplied, key-value data about the asset being controlled or retired.                                                        |\n| asset_is_local  | string      | local      | Denotes if the asset being controlled or retired was created in the Core.                                                                    |\n| amount          | integer     | global     | Amount of units of the asset being controlled or retired.                                                                                    |\n| reference_data  | JSON\u0026nbsp;object | global     | Arbitrary, user-supplied, key-value data about the output.                                                                                   |\n| control_program | string      | global     | The program that controls the asset units in the output.                                                                                     |\n\n#### Output (if `type` is `control`)\n\n| Field         | Type   | Visibility | Description                                                                             |\n|---------------|--------|------------|-----------------------------------------------------------------------------------------|\n| account_id    | string | local      | Locally unique identifier of the account controlling the asset units.                   |\n| account_alias | string | local      | User-supplied, locally unique identifier of the account controlling the asset units.    |\n| account_tags  | string | local      | Arbitrary, user-supplied, key-value data about the account controlling the asset units. |\n\n### Example\n\n```\n{\n  \"id\": \"C5D3F8...\",\n  \"timestamp\": \"2015-12-30T00:02:23Z\",\n  \"block_id\": \"3d6732d...\",\n  \"block_height\": 100,\n  \"position\": ..., // position in block\n  \"reference_data\": {\"deal_id\": \"...\"},\n  \"is_local\": \u003c\"yes\"|\"no\"\u003e, // local if any input or output is local\n  \"inputs\": [\n    {\n      \"action\": \"issue\",\n      \"asset_id\": \"125b4e...\",\n      \"asset_alias\": \"...\",\n      \"asset_tags\": {},\n      \"asset_is_local\": \u003c\"yes\"|\"no\"\u003e\n      \"amount\": 5000,\n      \"issuance_program\": ...,\n      \"reference_data\": {\"details\": \"...\"},\n      \"asset_definition\": \"...\",\n      \"is_local\": \u003c\"yes\"|\"no\"\u003e // local if action is issue and asset is local\n    },\n    {\n      \"action\": \"spend\",\n      \"asset_id\": \"125b4e...\",\n      \"asset_alias\": \"...\",\n      \"asset_tags\": {},\n      \"asset_is_local\": \u003c\"yes\"|\"no\"\u003e,\n      \"amount\": 5000,\n      \"spent_output_id\": \"997de5...\",\n      \"account_id\": \"\",\n      \"account_alias\": \"...\",\n      \"account_tags\": {},\n      \"reference_data\": {\"user\": \"alice\"},\n      \"is_local\": \u003c\"yes\"|\"no\"\u003e // local if account id is not null\n    }\n  ],\n  \"outputs\": [\n    {\n      \"action\": \"control\",\n      \"purpose\": \u003c\"change\"|\"receive\"\u003e, // provided if the control program was generated locally\n      \"id\": \"311df2...\",\n      \"position\": \"...\",\n      \"asset_id\": \"125b4e...\",\n      \"asset_alias\": \"...\",\n      \"asset_tags\": {},\n      \"asset_is_local\": \u003c\"yes\"|\"no\"\u003e,\n      \"amount\": 6000,\n      \"account_id\": \"\",\n      \"account_alias\": \"...\",\n      \"account_tags\": {},\n      \"control_program\": \"205CDF...\",\n      \"reference_data\": {\"user\": \"bob\"},\n      \"is_local\": \u003c\"yes\"|\"no\"\u003e // local if action is control and account id is not null\n    },\n    {\n      \"action\": \"retire\",\n      \"id\": \"2eb5cf...\",\n      \"position\": \"...\",\n      \"asset_id\": \"125b4e...\",\n      \"asset_alias\": \"...\",\n      \"asset_tags\": {},\n      \"asset_is_local\": \u003c\"yes\"|\"no\"\u003e,\n      \"amount\": 4000,\n      \"account_id\": \"\",\n      \"account_alias\": \"...\",\n      \"account_tags\": {},\n      \"control_program\": \"6a\",\n      \"reference_data\": {\"user\": \"bob\"},\n      \"is_local\": \u003c\"yes\"|\"no\"\u003e // local if action is control and account id is not null\n    }\n  ]\n}\n```\n\n## Unspent Output\n### Field Descriptions\nThe unspent output object is a subset of the [transaction object](#transaction). It includes all the fields present in the [output](#output) of a transaction, with the addition of the `transaction_id` of the transaction in which it is contained.\n\n### Example\n\n```\n{\n  \"id\": \"2eb5cf...\",\n  \"action\": \"control\",\n  \"purpose\": \u003c\"change\"|\"receive\"\u003e\n  \"transaction_id\": \"...\",\n  \"position\": \"...\",\n  \"asset_id\": \"...\",\n  \"asset_alias\": \"...\",\n  \"asset_definition\": {},\n  \"asset_tags\": {},\n  \"asset_is_local\": \u003c\"yes\"|\"no\"\u003e,\n  \"amount\": 5000,\n  \"account_id\": \"...\",\n  \"account_alias\": \"...\",\n  \"account_tags\": {},\n  \"control_program\": \"...\",\n  \"reference_data\": {}\n}\n```\n"},{"Url":"/docs/1.1/core/reference/changelog.md","Body":"# Changelog\n\nThis changelog covers updates to cored, the Chain Core server binary.\n\nFor updates to subpackages, see below:\n\n- [Mac installer](https://github.com/chain/chain/blob/1.1-stable/installer/mac/CHANGELOG.md)\n- [Windows installer](https://github.com/chain/chain/blob/1.1-stable/installer/windows/CHANGELOG.md)\n- [Java SDK](https://github.com/chain/chain/blob/1.1-stable/sdk/java/CHANGELOG.md)\n- [Node.js SDK](https://github.com/chain/chain/blob/1.1-stable/sdk/node/CHANGELOG.md)\n- [Ruby SDK](https://github.com/chain/chain/blob/1.1-stable/sdk/ruby/CHANGELOG.md)\n\n\u003ca name=\"1.1.4\"\u003e\u003c/a\u003e\n## 1.1.4 (March 27, 2017)\n\n* Resolved issue that could cause some annotated transaction fields to be missing under high load.\n* Expand Dashboard support to Safari 8 on OS X Yosemite systems.\n\n\u003ca name=\"1.1.3\"\u003e\u003c/a\u003e\n## 1.1.3 (March 7, 2017)\n\n* Resolved issue preventing the creation of valid multisig transactions.\n* The network version has been updated to **3**. Chain Core instances on the same network must share the same network version. If you're upgrading to version 1.1.3, make sure to upgrade all Chain Cores in your blockchain network. This version change is due to ([#648](https://github.com/chain/chain/issues/648)), which was resolved in version 1.1.1.\n* Resolved issue where some transaction inputs were not correctly annotated with account information ([#668](https://github.com/chain/chain/issues/668)).\n* Dashboard cosmetic changes.\n\n\u003ca name=\"1.1.2\"\u003e\u003c/a\u003e\n## 1.1.2 (Unreleased)\n\n* Version 1.1.2 was not released.\n\n\u003ca name=\"1.1.1\"\u003e\u003c/a\u003e\n## 1.1.1 (March 3, 2017)\n\n* The list of root CA certificates that Chain Core uses is now configurable via the `ROOT_CA_CERTS` enviornment variable. This list is used when Chain Core acts as an TLS client, i.e. when making RPC calls to signerd or other Chain Core instances.\n* Resolved issue where spent output ID was not being validated correctly ([#648](https://github.com/chain/chain/issues/648)).\n* Resolved connectivity issues when bootstrapping a core from a generator snapshot ([#643](https://github.com/chain/chain/pull/643)).\n* Resolved issue when connecting to other cores via HTTPS ([#674](https://github.com/chain/chain/issues/674)).\n\n\u003ca name=\"1.1.0\"\u003e\u003c/a\u003e\n## 1.1.0 (February 24, 2017)\n\nThis release is a minor version update, and contains new features, deprecations, and protocol breaking changes. cored 1.1.0 is backward-compatible with 1.0.x SDKs, but we strongly recommend upgrading to 1.1.x SDKs as soon as possible. cored 1.1.0 is not backward-compatible with 1.0.X coreds due to fundamental protocol changes.\n\nNotable changes:\n\n* The network version has been updated to **2**. Chain Core instances on the same network must share the same network version. If you're upgrading to version 1.1.0, make sure to upgrade all Chain Cores in your blockchain network.\n* Transaction outputs now have a unique `id` property.\n* Transaction inputs refer to previous outputs using a new `spent_output_id` property. The existing `spent_output` property, which contains a transaction ID and position, is **deprecated**.\n* Accounts now use **receivers**, a cross-core payment primitive that supersedes the Chain 1.0.x pattern of creating and paying to control programs. See the SDK changelogs for usage examples ([Java](https://github.com/chain/chain/blob/1.1-stable/sdk/java/CHANGELOG.md), [Node.js](https://github.com/chain/chain/blob/1.1-stable/sdk/node/CHANGELOG.md), [Ruby](https://github.com/chain/chain/blob/1.1-stable/sdk/ruby/CHANGELOG.md)).\n* The Dashboard has an improved on-boarding experience which guides new users through the basics.\n* Block signing has been improved to better support HSM integration.\n* Disable MockHSM and blockchain reset functions in production mode.\n* Improve version string printing in cored and corectl commands.\n* Bug fixes and performance improvements.\n\n## 1.0.2 (December 2, 2016)\u003ca name=\"1.0.2\"\u003e\u003c/a\u003e\n\n* Resolved issue with some transactions being incorrectly marked as \"not final\"\n  ([#160](https://github.com/chain/chain/issues/160), [#161](https://github.com/chain/chain/pulls/161)).\n* Added Ruby SDK documentation.\n* Updated included Java SDK to [1.0.1](https://github.com/chain/chain/blob/1.0-stable/sdk/java/CHANGELOG.md#1.0.1).\n* MockHSM keys can now be generated automatically when creating accounts or\n    assets from the Dashboard.\n* Bug fixes and performance improvements.\n\n## 1.0.1 (October 25, 2016)\n\n* Updated link to Java SDK JAR file.\n\n## 1.0.0 (October 24, 2016)\n\n* Initial release.\n"},{"Url":"/docs/1.1/core/reference/license.md","Body":"# License\n\n## Chain Core Developer Edition\n\nCopyright (c) 2016 Chain, Inc. \n\nSee [here](https://github.com/chain/chain/blob/main/NOTICE) for license information pertaining to Chain Core Developer Edition.\n\n## Chain Core Developer Edition for Mac\n\nCopyright (c) 2016 Chain, Inc.\n\nChain Core Developer Edition for Mac includes [Chain Core Developer Edition](#chain-core-developer-edition). \n\nSee below for third-party license information pertaining to Chain Core Developer Edition for Mac.\n\n---\n\nChain Core Developer Edition for Mac includes [PostgreSQL](https://www.postgresql.org/), which is distributed under the following license:\n\n```\nPostgreSQL Database Management System\n(formerly known as Postgres, then as Postgres95)\n\nPortions Copyright (c) 1996-2016, PostgreSQL Global Development Group\n\nPortions Copyright (c) 1994, The Regents of the University of California\n\nPermission to use, copy, modify, and distribute this software and its\ndocumentation for any purpose, without fee, and without a written agreement\nis hereby granted, provided that the above copyright notice and this\nparagraph and the following two paragraphs appear in all copies.\n\nIN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR\nDIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING\nLOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS\nDOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n\nTHE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\nON AN \"AS IS\" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO\nPROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n```\n\n---\n\nChain Core Developer Edition for Mac includes code adapted from [Postgres.app](http://postgresapp.com/). Postgres.app is distributed under the following license:\n\n```\nPostgreSQL Database Management System\n(formerly known as Postgres, then as Postgres95)\n\nPortions Copyright (c) 1996-2012, The PostgreSQL Global Development Group\nPortions Copyright (c) 1994, The Regents of the University of California\n\nPermission to use, copy, modify, and distribute this software and its \ndocumentation for any purpose, without fee, and without a written agreement \nis hereby granted, provided that the above copyright notice and this \nparagraph and the following two paragraphs appear in all copies.\n\nIN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR \nDIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING \nLOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS \nDOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE \nPOSSIBILITY OF SUCH DAMAGE.\n\nTHE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES, \nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY \nAND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS \nON AN \"AS IS\" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO \nPROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n```\n\n---\n\nChain Core Developer Edition for Mac includes [JasPer](http://www.ece.uvic.ca/~frodo/jasper/), which is distributed under the following license:\n\n```\nJasPer License Version 2.0\n\nCopyright (c) 2001-2006 Michael David Adams\nCopyright (c) 1999-2000 Image Power, Inc.\nCopyright (c) 1999-2000 The University of British Columbia\n\nAll rights reserved.\n\nPermission is hereby granted, free of charge, to any person (the\n\"User\") obtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without restriction,\nincluding without limitation the rights to use, copy, modify, merge,\npublish, distribute, and/or sell copies of the Software, and to permit\npersons to whom the Software is furnished to do so, subject to the\nfollowing conditions:\n\n1.  The above copyright notices and this permission notice (which\nincludes the disclaimer below) shall be included in all copies or\nsubstantial portions of the Software.\n\n2.  The name of a copyright holder shall not be used to endorse or\npromote products derived from the Software without specific prior\nwritten permission.\n\nTHIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\nLICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\nTHIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n\"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\nBUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\nPARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\nEVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\nINDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\nFROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\nNEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\nWITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\nPROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\nTHE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\nEACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\nBROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\nPROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\nGRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\nANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\nIS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\nSYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\nAIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\nSYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\nTHE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\nPERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\nRISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\nEXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n```\n\n---\n\nChain Core Developer Edition for Mac includes [libxml2](http://www.xmlsoft.org/), which is distributed under the following license:\n\n```\nExcept where otherwise noted in the source code (e.g. the files hash.c,\nlist.c and the trio files, which are covered by a similar licence but\nwith different Copyright notices) all the files are:\n\n Copyright (C) 1998-2012 Daniel Veillard.  All Rights Reserved.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is fur-\nnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FIT-\nNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n```\n\n\n---\n\nChain Core Developer Edition for Mac includes [libedit](http://www.xmlsoft.org/), which is distributed under the following license:\n\n```\nExcept where otherwise noted in the source code (e.g. the files hash.c,\nlist.c and the trio files, which are covered by a similar licence but\nwith different Copyright notices) all the files are:\n\n Copyright (C) 1998-2012 Daniel Veillard.  All Rights Reserved.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is fur-\nnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FIT-\nNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n```\n\n\n---\n\nChain Core Developer Edition for Mac includes [libjpeg](http://www.ijg.org/), which is distributed under the following license:\n\n```\nIn plain English:\n\n1. We don't promise that this software works.  (But if you find any bugs,\n   please let us know!)\n2. You can use this software for whatever you want.  You don't have to pay us.\n3. You may not pretend that you wrote this software.  If you use it in a\n   program, you must acknowledge somewhere in your documentation that\n   you've used the IJG code.\n\nIn legalese:\n\nThe authors make NO WARRANTY or representation, either express or implied,\nwith respect to this software, its quality, accuracy, merchantability, or\nfitness for a particular purpose.  This software is provided \"AS IS\", and you,\nits user, assume the entire risk as to its quality and accuracy.\n\nThis software is copyright (C) 1991-2014, Thomas G. Lane, Guido Vollbeding.\nAll Rights Reserved except as specified below.\n\nPermission is hereby granted to use, copy, modify, and distribute this\nsoftware (or portions thereof) for any purpose, without fee, subject to these\nconditions:\n(1) If any part of the source code for this software is distributed, then this\nREADME file must be included, with this copyright and no-warranty notice\nunaltered; and any additions, deletions, or changes to the original files\nmust be clearly indicated in accompanying documentation.\n(2) If only executable code is distributed, then the accompanying\ndocumentation must state that \"this software is based in part on the work of\nthe Independent JPEG Group\".\n(3) Permission for use of this software is granted only if the user accepts\nfull responsibility for any undesirable consequences; the authors accept\nNO LIABILITY for damages of any kind.\n\nThese conditions apply to any software derived from or based on the IJG code,\nnot just to the unmodified library.  If you use our work, you ought to\nacknowledge us.\n\nPermission is NOT granted for the use of any IJG author's name or company name\nin advertising or publicity relating to this software or products derived from\nit.  This software may be referred to only as \"the Independent JPEG Group's\nsoftware\".\n\nWe specifically permit and encourage the use of this software as the basis of\ncommercial products, provided that all warranty or liability claims are\nassumed by the product vendor.\n```\n\n---\n\nChain Core Developer Edition for Mac includes [OpenSSL](https://www.openssl.org/), which is distributed under the following license:\n\n```\n  LICENSE ISSUES\n  ==============\n\n  The OpenSSL toolkit stays under a dual license, i.e. both the conditions of\n  the OpenSSL License and the original SSLeay license apply to the toolkit.\n  See below for the actual license texts.\n\n  OpenSSL License\n  ---------------\n\n/* ====================================================================\n * Copyright (c) 1998-2016 The OpenSSL Project.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. All advertising materials mentioning features or use of this\n *    software must display the following acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)\"\n *\n * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n *    endorse or promote products derived from this software without\n *    prior written permission. For written permission, please contact\n *    openssl-core@openssl.org.\n *\n * 5. Products derived from this software may not be called \"OpenSSL\"\n *    nor may \"OpenSSL\" appear in their names without prior written\n *    permission of the OpenSSL Project.\n *\n * 6. Redistributions of any form whatsoever must retain the following\n *    acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit (http://www.openssl.org/)\"\n *\n * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n * ====================================================================\n *\n * This product includes cryptographic software written by Eric Young\n * (eay@cryptsoft.com).  This product includes software written by Tim\n * Hudson (tjh@cryptsoft.com).\n *\n */\n\n Original SSLeay License\n -----------------------\n\n/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)\n * All rights reserved.\n *\n * This package is an SSL implementation written\n * by Eric Young (eay@cryptsoft.com).\n * The implementation was written so as to conform with Netscapes SSL.\n * \n * This library is free for commercial and non-commercial use as long as\n * the following conditions are aheared to.  The following conditions\n * apply to all code found in this distribution, be it the RC4, RSA,\n * lhash, DES, etc., code; not just the SSL code.  The SSL documentation\n * included with this distribution is covered by the same copyright terms\n * except that the holder is Tim Hudson (tjh@cryptsoft.com).\n * \n * Copyright remains Eric Young's, and as such any Copyright notices in\n * the code are not to be removed.\n * If this package is used in a product, Eric Young should be given attribution\n * as the author of the parts of the library used.\n * This can be in the form of a textual message at program startup or\n * in documentation (online or textual) provided with the package.\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *    \"This product includes cryptographic software written by\n *     Eric Young (eay@cryptsoft.com)\"\n *    The word 'cryptographic' can be left out if the rouines from the library\n *    being used are not cryptographic related :-).\n * 4. If you include any Windows specific code (or a derivative thereof) from \n *    the apps directory (application code) you must include an acknowledgement:\n *    \"This product includes software written by Tim Hudson (tjh@cryptsoft.com)\"\n * \n * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n * \n * The licence and distribution terms for any publically available version or\n * derivative of this code cannot be changed.  i.e. this code cannot simply be\n * copied and put under another distribution licence\n * [including the GNU Public Licence.]\n */\n```\n\n---\n\nChain Core Developer Edition for Mac includes [json-c](https://github.com/json-c/json-c), which is distributed under the following license:\n\n```\n\nCopyright (c) 2009-2012 Eric Haszlakiewicz\n\nPermission is hereby granted, free of charge, to any person obtaining a\ncopy of this software and associated documentation files (the \"Software\"),\nto deal in the Software without restriction, including without limitation\nthe rights to use, copy, modify, merge, publish, distribute, sublicense,\nand/or sell copies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n----------------------------------------------------------------\n\nCopyright (c) 2004, 2005 Metaparadigm Pte Ltd\n\nPermission is hereby granted, free of charge, to any person obtaining a\ncopy of this software and associated documentation files (the \"Software\"),\nto deal in the Software without restriction, including without limitation\nthe rights to use, copy, modify, merge, publish, distribute, sublicense,\nand/or sell copies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n```\n\nChain Core Developer Edition for Mac includes [libtiff](http://www.libtiff.org/), which is distributed under the following license:\n\n```\nCopyright (c) 1988-1997 Sam Leffler\nCopyright (c) 1991-1997 Silicon Graphics, Inc.\n\nPermission to use, copy, modify, distribute, and sell this software and \nits documentation for any purpose is hereby granted without fee, provided\nthat (i) the above copyright notices and this permission notice appear in\nall copies of the software and related documentation, and (ii) the names of\nSam Leffler and Silicon Graphics may not be used in any advertising or\npublicity relating to the software without the specific, prior written\npermission of Sam Leffler and Silicon Graphics.\n\nTHE SOFTWARE IS PROVIDED \"AS-IS\" AND WITHOUT WARRANTY OF ANY KIND, \nEXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY \nWARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  \n\nIN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR\nANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,\nOR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,\nWHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF \nLIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE \nOF THIS SOFTWARE.\n```\n\n## Chain Core Developer Edition for Windows\n\nCopyright (c) 2016 Chain, Inc.\n\nChain Core Developer Edition for Windows includes [Chain Core Developer Edition](#chain-core-developer-edition). \n\nSee below for third-party license information pertaining to Chain Core Developer Edition for Windows.\n\n---\n\nChain Core Developer Edition for Windows includes [PostgreSQL](https://www.postgresql.org/download/windows/), which is distributed under the following license:\n\n```\nPostgreSQL Database Management System\n(formerly known as Postgres, then as Postgres95)\n\nPortions Copyright (c) 1996-2016, PostgreSQL Global Development Group\n\nPortions Copyright (c) 1994, The Regents of the University of California\n\nPermission to use, copy, modify, and distribute this software and its\ndocumentation for any purpose, without fee, and without a written agreement\nis hereby granted, provided that the above copyright notice and this\nparagraph and the following two paragraphs appear in all copies.\n\nIN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR\nDIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING\nLOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS\nDOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n\nTHE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\nON AN \"AS IS\" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO\nPROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n```\n"},{"Url":"/docs/1.1/core/reference/versioning.md","Body":"# Versioning\n\n## Summary\n\nThere are two distinct Chain versioning schemes:\n\n* **core** versioning\n* **network** versioning\n\nCore versioning applies to the main pieces of software that compose, package, or directly interact with Chain Core. This includes, for example, the Chain Core server, the client SDK libraries, and the platform-specific installers.\n\nNetwork versioning applies to the network API--the interface through which different Chain Cores communicate to exchange transactions and blocks. Any breaking changes to the network API interface or the data structures as defined by the Chain protocol are reflected by a change to the network version.\n\n## Core Versioning\n\nThe various packages of the Chain Core suite each use a three-number versioning scheme: **x.y.z**. The first two numbers indicate compatibility between packages. Server software is compatible with clients that share the same major and minor version, or are one minor version behind. For example, if you are a running a version of the Chain Core server whose first two numbers are **1.1**, you can use a version of an SDK whose first two numbers are **1.0** or **1.1**.\n\nSometimes we make bugfixes and minor feature updates to individual software packages. When this occurs, we update the third number in the version string for that package only. This number doesn't affect compatibility with other packages. For example, you can safely use version **1.1.1** of the Chain Core Mac App with version **1.1.3** of the Java SDK.\n\n### Scope\n\nThe core versioning scheme covers a suite of individual software packages, including servers, clients, and bundled releases.\n\nServer packages include:\n\n- `cored`, the Chain Core server daemon\n- `signerd`, the HSM signing server daemon\n- Thales Codesafe HSM firmware\n\nClient packages include:\n\n- `corectl`, a CLI utility for operating Chain Core\n- Java SDK\n- Node.js SDK\n- Ruby SDK\n\nBundled releases include:\n\n- Chain Core Mac app\n- Chain Core Windows app\n- Chain Core Docker image\n\n### Format\n\nEach release of a core software package is assigned a version string composed of three numbers separated by periods, such as **1.0.1**.\n\nThese numbers represent, in order:\n\n- **Major version**: significant product changes\n- **Minor version**: bugfixes, new features, deprecations, and breaking changes\n- **Build version**: package-specific bugfixes and features\n\n### Semantics\n\nThis scheme has semantics that are unique to Chain Core, despite superficial similarities to other versioning schemes. In particular, Chain Core does **not** use [Semantic Versioning](http://semver.org/).\n\n#### Compatibility between packages\n\nSoftware packages are mutually compatible if they share the same major and minor version. To accommodate a smooth upgrade flow, server packages are backward compatible with client packages that are one minor version behind. For example, if you are running version 1.1.x of the Chain Core server, you can use version 1.0.x or 1.1.x of the Java SDK.\n\n#### Deprecations and breaking changes\n\nDeprecations and breaking changes can occur when the minor version changes. If a feature is deprecated, it will remain functional for at least one minor version before being removed.\n\n## Network versioning\n\nThe network version is a single integer. All instances of Chain Core connecting to a network must have the same network version. The network version is determined by the Chain Core operating as the block generator.\n\nThe network version will be incremented each time there is a breaking change in the network API interface or a breaking change in the version of the Chain protocol being implemented.\n\n### Breaking changes\n\nAn upgrade in network version constitutes a breaking change at the network level. Any upgrade to the network version will be included in a new package version of Chain Core software and documented as a breaking network change in the release notes.\n\n## Notes\n\n### Enterprise vs. developer editions\n\nChain Core Enterprise Edition is a superset of Developer Edition. The two editions share the same version space. For example, if a particular feature exists in version 1.1.x of Developer Edition, then it also exists in version 1.1.x of Enterprise Edition.\n\n### Older software\n\nChain Core is a different product than older software released by Chain, such as the Chain Blockchain Platform and related SDKs, the Chain sandbox and related SDKs, or SDKs for the Chain Bitcoin API. Chain Core does **not** share the same version space as older products.\n"},{"Url":"/docs/1.1/enterprise/docker-external-postgres.md","Body":"# Connect Chain Core to an external PostgreSQL server\nThis guide shows how to run Chain Core on 2 servers:\n\n1. A server running the Chain Core binary\n2. A server running PostgreSQL\n\nFor this example, we will assume that server #1 runs on `10.0.0.1` and server #2 runs on `10.0.0.2`.\n\n### Setting up the PostgreSQL server\nThe PostgreSQL server needs to be running PostgreSQL 9.5 and it must expose port `5432` to the server running the Chain Core binary. Here is Centos/RHEL example:\n\n```\nsudo yum -y install http://yum.postgresql.org/9.5/redhat/rhel-6.8-x86_64/pgdg-redhat95-9.5-2.noarch.rpm\nsudo yum -y install postgresql95-server postgresql95-contrib\n```\nOnce PostgreSQL is installed, we can initialize the PostgreSQL database and allow incoming connection from our Chain Core server.\n```\nsudo service postgresql-9.5 initdb\nsudo su -c 'echo host all all 10.0.0.1/32 trust \u003e /var/lib/pgsql/9.5/data/pg_hba.conf'\nsudo su -c 'echo host all all 127.0.0.1/32 trust \u003e /var/lib/pgsql/9.5/data/pg_hba.conf'\nsudo service postgresql-9.5 on\npsql postgres://postgres:@127.0.0.1 -c 'create database core'\n```\n\n### Setting up the Chain Core server\nNow that we have a server running on `10.0.0.2:5432`, we can instruct the Docker container that is running Chain Core to connect to the PostgreSQL server.\n\n```\n$ docker run \\\n  -it \\\n  -p 1999:1999 \\\n  -e DATABASE_URL=postgres://10.0.0.2:5432/core \\\n  chaincore/developer\n```\n"},{"Url":"/docs/1.1/enterprise/operations.md","Body":"# Operations guide\n\n### Topics\n\n- [Monitoring and health checks](#monitoring-and-health-checks)\n\n## Monitoring and health checks\n\nChain Core exposes two HTTP endpoints for monitoring.\n\n### `/health`\n\nFor uptime monitoring, check `/health` periodically. If your request returns anything but a 200 status code, then the server is unavailable.\n\nThis endpoint is **unauthenticated**.\n\n### `/info`\n\nThe `/info` endpoint reports basic information about the configuration of Chain Core, as well as any errors encountered when updating the local state of the blockchain. These errors include problems with generating new blocks (if the core is a generator), or problems making requests to the generator core.\n\nThis endpoint is **authenticated** via HTTP Basic Auth. Your client API token can be used as a username/password pair, e.g.:\n\n```\nGET https://\u003cclient API token\u003e@chaincore.example.com/info\n```\n\n#### Response\n\nThe response is a JSON object with the following fields:\n\nField | Type | Description\n--- | --- | ---\n`block_height` | integer | Height of the blockchain in the local core\n`blockchain_id` | string | Hash of the initial block\n`build_commit` | string | Git SHA of build source\n`build_date` | string | Unixtime (as string) of binary build\n`configured_at` | string | RFC3339 timestamp reflecting when the core was configured\n`core_id` | string | A random identifier for the core, generated during configuration\n`generator_access_token` | string | The access token used to connect to the generator\n`generator_block_height` | integer | Height of the blockchain in the generator\n`generator_block_height_fetched_at` | string | RFC3339 timestamp reflecting the last time `generator_block_height` was updated\n`generator_url` | string | URL of the generator\n`health` | object | **Blockchain error information (see below)**\n`is_configured` | boolean | Whether the core has been configured\n`is_generator` | boolean | Whether the core is configured as the blockchain generator\n`is_production` | boolean | Whether the core is running in production mode\n`is_signer` | boolean | Whether the core is configured as a block signer\n`network_rpc_version` | 1 | The network version supported by this core\n`version` | `1.0.2` | The release version of the `cored` binary\n\nThe `health` object has the following structure:\n\n```\n{\n  \"errors\": {\n    \"fetch\": \u003cnull or string\u003e,\n    \"generator\": \u003cnull or string\u003e\n  }\n}\n```\n\nThere are two types of errors:\n\n- **fetch** errors occur when the core encounters errors synchronizing blocks from the generator. Among other things, this could mean the generator is not reachable from this core. This field is undefined if the core is a generator.\n- **generator** errors occur when the core is acting as a generator, and encounters errors generating a new block. This field is undefined if the core is not a generator.\n\nThese fields will be `null` if no errors have been encountered.\n\n\n"},{"Url":"/docs/1.1/enterprise/rhel-systemd.md","Body":"# Install Chain Core on RHEL with Systemd\n\nThis guide shows how to install Chain Core and how to configure systemd to manage the starting and stopping of the cored process.\n\n1. Install Postgres 9.6\n2. Download cored \u0026 corectl to `/usr/bin/`\n3. Configure cored using `/etc/cored.env`\n4. Configure systemd using `/etc/systemd/system/cored.service`\n\n## Install Postgres 9.6\n\n```\n# curl -LO https://download.postgresql.org/pub/repos/yum/9.6/redhat/rhel-6-x86_64/pgdg-centos96-9.6-3.noarch.rpm\n# service postgresql-9.6 initdb\n# chkconfig postgresql-9.6 on\n# echo host all all 127.0.0.1/32 trust \u003e /var/lib/pgsql/9.5/data/pg_hba.conf\n# service postgresql-9.6 on\n# psql postgres://postgres:@localhost -c 'create database core'\n```\n\nTaken from the official Postgres instructions:\nhttps://wiki.postgresql.org/wiki/YUM_Installation\n\n\n## Downloading cored\n\n```\n$ curl -LO https://download.chain.com/bin/chain-core-server-1.1.3.tar.gz\n$ tar -xzf chain-core-server-1.1.3.tar.gz\n\n$ cp chain-core-server-1.1.3/cored /usr/bin/cored\n$ chmod +x /usr/bin/cored\n\n$ cp chain-core-server-1.1.3/corectl /usr/bin/corectl\n$ chmod +x /usr/bin/corectl\n```\n\n## Configuring cored\n\nHere is an example `/etc/cored.env` file:\n```\nexport DATABASE_URL=postgres://{USERNAME}:{PASSWORD}@{HOST}:{PORT}/{DATABASE-NAME}?sslmode=disable\n```\nThe minimal cored configuration requires `DATABASE_URL`.\n\nIf you have followed the instructions in the Install Postgres 9.6 section, you can use this line:\n\n```\nexport DATABASE_URL=postgres://postgres:@localhost/core?sslmode=disable\n```\n\n## Configure systemd\n\n```\n[Unit]\nDescription=Chain Core Server\nAfter=network.target\n\n[Service]\nUser=cored\nEnvironmentFile=/etc/cored.env\nExecStart=/usr/bin/cored\nRestart=always\nRestartSec=5\n\n[Install]\nWantedBy=multi-user.target\n```\n\n## Start cored\n\n```\nsystemctl start cored\n```\n\n## View cored logs\n\n```\njournalctl -u cored.service\n```\n"},{"Url":"/docs/1.1/enterprise/thales-install-guide.md","Body":"# Using a Thales HSM with Chain Core\n\nThe security of assets and accounts in Chain Core depends on strong\ncryptographic keys that must be kept secure themselves. Chain\nrecommends the use of dedicated devices known as Hardware Security\nModules (HSMs) for protecting sensitive key material. Chain has\npartnered with the vendor Thales to integrate its industry-leading HSM\nhardware, the **nShield Connect**, with the Chain Core programming\ninterface.\n\nTo begin using the Thales nShield Connect with Chain Core, you must\nhave the following files supplied by Chain:\n\n- `xprvseemodule.sar`, the firmware (or “SEE machine”) to be loaded\n  into the HSM;\n- `userdata.bin`, a file of associated data to be signed and loaded\n  into the HSM;\n- `xprvseetool`, a Linux binary for creating a key in the HSM suitable\n  for use in Chain Core;\n- `signerd`, a Linux binary implementing a server for responding to\n  transaction-signing requests.\n  \nYou must also perform the following steps:\n\n-  Set up the HSM(s) and the client host(s) according to the\n   directions from Thales\n   - Install CodeSafe software on client host(s)\n   - Initialize the Remote File System\n   - Configure host(s) and HSM(s) with each other’s IP addresses\n        - If running multiple hosts, the module numbers will be configured at this time.\n   - Create the “Security World” with the Secure Execution Engine\n     (SEE) enabled, along with SEE debugging\n   - Create an administrator cardset and an operator cardset\n\n- Thales configuration involves many policy choices related to SEE Activation. To check which SEE features have been enabled, on the client host:\n   - `fet` \n   - If `SEE Activation (Restricted)` is configured, Thales may need to assist with additional certifcations or licenses prior to proceeding. Refer to the Thales documentation or contact your Thales representative for details.\n    \n\n   These steps are complex and involve policy decisions and other\n   choices.  Refer to the Thales documentation for details.  Note:\n   Chain has tested this using 64-bit Ubuntu Linux on the client host.\n\n-  On the client host, use the “nfast” utilities from Thales to create\n   a _user-data signing key_ and a signed copy of the userdata file.\n   - `generatekey --batch seeinteg plainname=xprvseemoduledevusk`\n   - `tct2 --sign-and-pack -k xprvseemoduledevusk --machine-key=02cf0cd76a8e726ffba2e4a1d2648b447d505aaa -o userdata.sar -i userdata.bin`\n   \n   The hex value here is the hash of the key that Chain used to sign\n   the SEE machine. **Important**: this hash is of a _development key_ and\n   should not be trusted for production.\n   \n-  On the client host (RFS server), copy the signed firmware and userdata files to the custom-seemachines directory. These commands must be run on each module.\n-  Here, `a` and `b` have been chosen to simplify entering the file names on the HSM front panel. These names can be changed if desired.\n   - `cp xprvseemodule.sar /opt/nfast/custom-seemachines/a`\n   - `cp userdata.sar /opt/nfast/custom-seemachines/b`\n\n-  On the HSM, use the front panel to load the machine image and userdata file. \n   This must be done for each HSM. Note: there is no need to reboot the modules.\n   - Choose `CodeSafe` on the front panel \n   - Enter `a` (or name of choice) for the machine image \n   - Enter `b` (or name of choice) for the userdata file\n   - Choose `SEElib` for the world type\n   - Enter `chainenclave` for the name\n\n-  On the client host, check that the SEE world is running on each module using stattree.\n   - `stattree PerModule 1 ModuleEnvStats`\n   - The `MemAllocUser` value in the output should be nonzero\n\n-  On the client host, use the `xprvseetool` binary from Chain to check that the client can access the SEE world on each module (update the module number in the command for each host).\n   - `xprvseetool -m 1 seeversion`\n\n-  On the client host, use the `xprvseetool` binary from Chain to\n   create an `xprv` (for transactions) and a `prv` (for blocks) in the HSM.\n   - `xprvseetool -i xprv0 genx xprvseemoduledevusk`\n   - `xprvseetool -i prv0 gen xprvseemoduledevusk`\n\n   The output of this tool is the hex-encoded public key corresponding\n   to the new private key. Save it for use in asset issuance programs\n   and/or transaction control programs.\n\n   The development version of Chain’s Thales integration operates on a\n   single public/private keypair. The production version of Chain Core\n   Enterprise Edition will permit the creation, storage, and use of\n   arbitrarily many keys.\n\n-  On the client host, run the `signerd` binary from Chain (update the module number in the command for each host).  \n   - `MODULE=1 KEY_IDENT=prv0 XPRV_KEY_IDENT=xprv0 signerd`\n   \n   This launches an HTTP+JSON server listening for `/sign-transaction`\n   requests on port 8080. The request and response formats for this\n   endpoint are byte-for-byte compatible with the\n   `/mockhsm/sign-transaction` endpoint in Chain Core.\n"},{"Url":"/docs/1.1/protocol/papers/blockchain-extensibility.md","Body":"# Blockchain Extensibility\n\n* [Introduction](#introduction)\n* [Hard forks and soft forks](#hard-forks-and-soft-forks)\n* [Safety considerations](#safety-considerations)\n* [Extensive and restrictive upgrades](#extensive-and-restrictive-upgrades)\n* [Extension points](#extension-points)\n* [Versioning rules](#versioning-rules)\n* [Assets and programs interoperability](#assets-and-programs-interoperability)\n* [Consensus upgrades](#consensus-upgrades)\n* [Deprecation process](#deprecation-process)\n* [Examples](#examples)\n* [Conclusion](#conclusion)\n\n## Introduction\n\nUpgrading blockchain networks poses serious challenges. While traditional communications protocols only require point-to-point compatibility and allow the network as a whole to have varying degrees of interoperability, all nodes on a blockchain network must validate the same blocks. It is therefore impossible for any subset of parties to freely upgrade to an arbitrary new protocol without affecting the rest of the network (or, more likely, permanently detaching from it by “forking the chain”). As a result, for any protocol change to be implemented and deployed, the following issues must be considered:\n\n* **Coordination:** how do all nodes agree on adoption of the new rules?\n* **Transition security:** does transition to the new rules (even when done correctly) opens up security loopholes or breaks some assumptions?\n* **Transition reliability:** is the transition implemented correctly and how likely it to contain bugs and cause the blockchain to fork?\n* **Feature security:** is the upgraded protocol secure as advertised?\n\nThis document covers the extensibility features and versioning semantics of Chain Protocol that facilitate safe evolution of the protocol rules.\n\n## Hard forks and soft forks\n\nThere are two ways to upgrade a blockchain network. These are conventionally known as *hard forks* and *soft forks*. \n\n[sidenote] \n\nSee [BIP 99](https://github.com/bitcoin/bips/blob/master/bip-0099.mediawiki) for some background on the Bitcoin community's approach to hard and soft forks.\n\n[/sidenote]\n\nA **hard fork** is a change that is not compatible with non-upgraded software — it makes messages that were invalid under the old rules become valid under new rules. Changes to the protocol can be implemented in a straightforward manner, but at the cost of upgrading all participating nodes and all software that works directly with blockchain data structures. In a smaller network, a hard fork may be an efficient way to upgrade: one should set a deadline when the new rules will be activated, then update all necessary software before the deadline. Unfortunately, in larger networks hard forks pose a serious risk of breaking software unexpectedly, or would require a prohibitively distant deadline to give time to review and upgrade all software.\n\nA **soft fork** is a compatible change — it rejects some messages that were previously valid. This may be a less elegant way to change the protocol, but it allows upgrading the network piece-by-piece without requiring every node to upgrade. A soft fork must be enforced by the block generation and consensus mechanism. For proof-of-work blockchains, this means the miners; for Chain blockchains, this means the block signers. A soft fork requires only block signers to upgrade first and enforce new rules by rejecting non-conforming transactions. To make sure future versions of the protocol still validate earlier blocks, block signers preemptively refuse to sign blocks containing transactions with undefined version numbers, making it safe to introduce new versions (and their associated new behavior) in the future. Once block signers begin enforcing new rules, other nodes can start creating transactions with a new version. Nodes that did not upgrade still validate these transactions, but implicitly rely on block signers to validate their exact meaning. Such nodes operate with reduced security regarding validation of new transactions. Nodes can upgrade to new capabilities at their own pace without blocking anyone else’s operation.\n\n[sidenote]\n\nContrary to what one might assume, neither hard forks, nor soft forks are intended to _actually fork_ the blockchain. The word “fork” indicates the change of the protocol rules that _potentially_ may lead to an undesirable fork of the blockchain. While hard forks require careful coordination of all users, soft forks require careful coordination of block signers only.\n\n[/sidenote]\n\n\n## Safety considerations\n\n### Safety of hard forks\n\nWhile hard forks break compatibility with all fully validating nodes (running Chain Core or compatible software), some hard forks may be made compatible with a wider collection of software that verifies only a subset of protocol features. For instance, signing software deployed in HSMs, or clients that do not execute transaction programs, but only check transactions’ Merkle paths to a signed block.\n\nA hard fork upgrade may have different compatibility implications, depending on its scope:\n\n1. Changing transaction format: virtually no software remains compatible.\n2. Changing block format: some transaction-signing software stays compatible.\n3. Changing built-in limits: clients that verify compact proofs (transaction contents, Merkle paths to signed blocks) remain compatible.\n4. Changing VM bytecode: some clients may remain compatible depending on character of the change.\n\nIn the best case incompatibility caused by hard forks causes outage for non-upgraded clients. But in general, it opens all clients (whether upgraded and not) to network forks and double-spending attacks that are hard to automatically detect and protect against since both sides of the network would see the alternative chain as completely invalid and consider it a noise. Hard fork upgrades are also harder to monitor: an unexpected incompatibility may remain hidden until it is too late and it causes the actual network fork.\n\nDue to the difficulty of deploying hard forks safely, Chain Protocol provides versioning and upgrade semantics for blockchain data structures in order to enable safe soft fork upgrades.\n\n\n### Safety of soft forks\n\nA soft fork upgrade _adds_ rules and _does not remove_ existing ones. As a result, non-upgraded nodes see the upgraded blockchain as valid and easily detect a fork caused by block signers. Upgraded nodes can also detect a fork caused by block signers and pinpoint it to a violation of a specific rule. Although all soft forks provide basic safety guarantee in respect to forking the ledger, the actual safety depends on the nature and scale of the upgrade.\n\nSoft forks allow implementing a surprisingly large number of changes, from bug fixes and small features in the VM, to introducing a completely new block structure. When the versioning rules are carefully planned in advance, changes to the software can also be implemented cleanly.\n\nSmaller changes are safer to implement as they touch smaller software surface. An example of a relatively safe change is addition of a new instruction to the VM in place of one of the NOP instructions: non-upgraded users cannot use it by mistake and are able to execute the rest of the contract logic using pre-existing rules (so the surface of a possible attack is very narrow). It is much less safe to introduce a new transaction format: non-upgraded nodes will entirely ignore the new transactions, a larger amount of software will have to be upgraded to take advantage of the new format. Then even more complexity will have to be added to make old and new transaction formats interoperable.\n\n\n## Extensive and restrictive upgrades\n\nSoft forks allow two approaches to network upgrades:\n\n1. **Extensive upgrade:** introduction of a new rule (security feature) the co-exists with the existing ones. A pre-existing extension field in the blockchain is extended with additional data having a specific meaning applied.\n2. **Restrictive upgrade:** usage of existing features is restricted or partially limited by censoring transactions. Block signers can restrict some transactions anyway for performance or security reasons, but they can also commit to such behaviour by making it a protocol rule so that other nodes can rely on it.\n\nThe first approach allows introducing new features for security or performance reasons without disrupting the use of the existing features.\n\n[sidenote]\n\nNote that restricting existing feature and adding a new one is not equivalent to redefining the rules that apply to a certain piece of data. The former remains a soft fork, while the former is a hard fork. The non-upgraded nodes ignore the new feature and stop seeing instances of usage of the old feature and therefore stay compatible with the blockchain.\n\n[/sidenote]\n\nThe second approach allows for performance optimization and deprecation of less secure features. If a part of the protocol is proven to be completely insecure, a “fail-stop” soft fork upgrade can immediately prohibit its usage.\n\nTogether, the first and the second approaches allow implementing a tick-tock upgrade schedule: first, rolling out a new security feature, then phasing out support for the deprecated one until all nodes are upgraded and the network can forbid its use as a protocol rule.\n\n\n\n## Extension points\n\nChain Protocol defines four main areas of extensibility: \n\n1. Blocks\n2. Transactions\n3. Assets\n4. Programs\n\nEvery extension area includes several _extension points_ with specified upgrade semantics.\n\n\n### Block extension points\n\nField          | Semantics\n---------------|---------------------------------\nBlock Version  | Monotonically-increased integer. New value indicates to all nodes that a new protocol rule is being activated.\nBlock Commitment | Additional commitments are appended to the string and can be ignored by non-upgraded nodes.\nBlock Witness | Additional proofs are appended to the string and can be safely ignored by non-upgraded nodes.\n\nNote that block version is the only version field that must be incremented monotonically, and it does not require increments by 1. All other version fields may have arbitrary values in no particular order of introduction. At any given time, the version of a data structure either belongs to a set of known versions, or is simply *unknown*.\n\n\n### Transaction extension points\n\nField          | Semantics\n---------------|---------------------------------\nTransaction version | Arbitrary integer allowing nodes to opt-in additional rules applied to transaction data.\nCommon fields  | Additional transaction fields common to all inputs and outputs can be committed to the existing transaction by appending them to this field. Non-upgraded nodes ignore unknown suffixes.\nCommon witness | Additional witness data may be appended to the string to aid in validation of the blockchain. Non-upgraded nodes ignore unknown suffixes.\n\n\n### Asset extension points\n\nField             | Semantics\n------------------|---------------------------------\nAsset Version     | Variable-length integer identifying an asset accounting scheme and capabilities. Inputs and outputs with unknown asset versions are ignored by the nodes.\nOutput Commitment | Additional “deposit” commitments are appended to the string and can be ignored by non-upgraded nodes.\nInput Commitment  | Additional “spending” commitments are appended to the string and can be ignored by non-upgraded nodes.\nInput Witness     | Additional witness data may be appended to the string in one or more asset versions to aid in validation of the blockchain. Non-upgraded nodes ignore unknown suffixes.\n\n\n### Program extension points\n\nTransaction programs have five extension points within the output and issuance programs. \n\nBlock programs are not versioned and can be upgraded only via additional block commitment elements.\n\nField         | Semantics\n--------------|---------------------------------\nVM Version    | Variable-length integer that identifies VM for the issuance and output programs. Nodes first read the version field and if the version is unknown, resolve the program without parsing it as if it was executed successfully. This way, arbitrary VM changes can be made via version updates.\nNOP* instructions  | NOP instructions by default do nothing, but can be redefined to perform additional verification without effect on the stack, but behaving like CHECK*SOMECONDITION*VERIFY, without VM version updates.\n\n**Note:** all unassigned opcodes are defined as NOPs (“no operation”) that enable minor changes to the VM without changing the VM version. So the non-upgraded nodes will be able to validate most of the program without having to ignore it completely as “anyone can spend” as a new VM version would cause them to do. Even when the VM version needs to be increased (e.g. a new instruction need a significantly larger run cost or does non-trivial changes to VM state), keeping existing instructions untouched allows keeping consistency between VM implementations and related tools and avoiding bugs.\n\n\n## Versioning rules\n\nChain Protocol implements a versioning scheme that allows users signalling whether they opt into new version of the protocol and also enable the network to protect the extension points (more on them below) against abuse before they have specific semantics assigned to them.\n\nAll upgrades are sequential. Nodes cannot upgrade to a protocol extension without upgrading to all previous ones. Users that do not validate the blockchain fully may cherry-pick which features to validate themselves or delegate trust to block signers or third-party data providers. However, they still must be aware of all intermediate extensions when deciding to opt out of validating some aspects of the protocol. This is reflected in the requirement that block versions monotonically increase: protocol rules that were added once cannot be rolled back in the future. All other version fields while encoded as variable-length integers are free-form and may be treated as integers, short strings, bit fields or a combination thereof.\n\n**Extensive upgrades** to the protocol are signaled by incrementing the block version and changing the versions of all affected data structures that introduce the additional rules. Use of unassigned fields and instructions is *not allowed* without changing the version of the data structure that is being extended and all data structures up in the hierarchy up to the block version. This allows applications to detect addition of new fields, asset and program versions to the protocol and adjust their security assumptions, notify administrators about an upgrade, or take other action as appropriate. This also provides security for users of compact proofs: they are guaranteed that they will notice a protocol upgrade when the previously unused fields become defined.\n\n**Restrictive upgrades** — that limit use of defined fields and instructions — only need to increment a block version in order to maintain compatibility of the new rules with the historical blocks. For additional compatibility with transacting software the following scheme is recommended:\n\n1. The restrictions apply only to a new transaction version (or versions).\n2. Previous transaction version is either allowed indefinitely (therefore allowing users to opt-in the new rule), or announced as deprecated and can be restricted in the future (phased out) or immediately (fail-stop scenario).\n\n### How it works\n\nLets say, a new VM version is introduced with an additional input commitment field necessary for a new VM feature.\n\n1. Since the new VM version is used, the transaction version must be changed.\n2. Transaction version is changed, therefore block version must be increased.\n3. Block signers make sure only well-defined block versions are used and signed. Before the upgrade, block signers reject transactions that use unassigned extension points and version numbers.\n4. When the block version is increased, the rest of the network receives a clear signal that the protocol rules has changed. Non-upgraded nodes may choose to stop processing payments until they upgrade, or apply additional checks and confirmations out of band.\n\n\n## Assets and programs interoperability\n\nVM versions can be updated independently of asset versions. New VM versions can access all previously defined asset versions but not future ones. Newer asset versions may use previously defined VMs and additional VMs introduced in the future (if explicitly defined for these asset versions).\n\nWhen a new asset version is introduced, existing VMs may be nominally upgraded for all older asset versions so that programs controlling older assets may “see” newer assets which allows building trust-minimized bridges between old and new asset versions.\n\nUsers may keep using existing assets alongside the new ones without updating to a new VM, but simply signing multi-input/multi-output transactions for synchronous trades. They can also use an updated VM version with old assets in order to build contracts that involve both new and old asset version.\n\nIssuers may continue to recognize older assets, offer a trusted exchange of old assets for the new ones or define new asset versions via issuance programs that perform conversion in a trust-minimized manner (e.g. a program may allow issuance of a new asset with the amount corresponding to an amount of the older asset explicitly destroyed in the same transaction).\n\n\n## Consensus upgrades\n\nConsensus protocol is mostly separated from the blockchain validation rules as it allows block signers to agree on a single tip block that they need to sign. Block header has an extensible “block commitment” field that allows addition of new rules supporting changes to the consensus protocol. \n\nExtra care must be taken about upgrading the VM used for consensus programs. While control and issuance programs used in transactions have a VM version associated with them, blocks intentionally designed without explicit versioning. When non-upgraded nodes have to evaluate a program with an unknown VM version, they skip the evaluation and instead defer to block signers to decide if transaction is valid. In case of a block consensus program, there is no “higher authority” to defer to. If the new consensus protocol requires a new feature in the VM, block commitment and block witness fields must be extended with a new consensus program and its arguments to be evaluated *in addition* to the old VM and old consensus program. \n\n[sidenote]\n\nBlock signers should not optimize performance changing old consensus program to `OP_1` (always succeeds) because it will immediately open non-upgraded nodes to a vulnerability: anyone would be able to fork the blockchain for them and make it look perfectly valid. \n\nIn some cases, block signers might want to change the old consensus program to `OP_FAIL` in case the old VM has an unavoidable security problem and it is safer to cause non-upgraded nodes to stop entirely and not accept any new blocks until they upgrade. Such update will become a _safe hard fork_ since the original chain will be prohibited from growing further.\n\n[/sidenote]\n\nWhile it is not easy to add support for new signature algorithms (e.g. changing an elliptic curve), VM 1 is flexible enough to allow implementing Lamport signatures: one-time hash-based signatures using built-in instructions for string manipulation, bitwise operations and hashing.\n\n\n## Deprecation process\n\nBy default, all previously supported features remain supported to keep older software compatible. Sometimes features are discovered to be either insecure or inefficient and should be deprecated. Deprecation can be implemented as the block signers’ policy to refuse to include transactions using such features or restricting some aspects of them (size, frequency, etc). If necessary, deprecation can be implemented via a *restrictive upgrade* to the protocol enforced by the entire network. For instance, if a certain signature scheme is deemed insecure, it can be fully banned after a pre-arranged deadline to prevent inclusion of insecure transactions.\n\n\n## Examples\n\n### 1. Adding a new programming feature\n\nWe can add or modify an instruction, introduce a new signature scheme, or completely redesign the bytecode format by introducing a new VM version:\n\n1. Specify an update to the format or semantics of output programs and corresponding signature programs.\n2. Allocate a new VM version number to identify the new VM.\n3. If necessary, specify additional data in the output commitment or input commitment (or both) for outputs using the new VM version.\n4. If necessary, specify an additional global state commitment in the block commitment field.\n5. Upgrade all block signers with software implementing the new feature.\n6. At a pre-agreed time, increment the block version to signal the protocol update to all nodes.\n7. Remaining nodes may upgrade and begin using the new VM.\n\n### 2. Adding a new accounting scheme\n\nWe can implement a new asset accounting mechanism with new confidentiality or performance features by introducing a new asset version:\n\n1. Specify a new protocol for issuance and transfer of assets, and a corresponding layout for input and output commitments and witness structures.\n2. Allocate a new asset version to identify inputs and outputs using the new assets.\n3. If necessary, specify an additional global state commitment in the block commitment field.\n4. Upgrade all block signers with software implementing the new feature.\n5. At a pre-agreed time, increment the block version to signal the protocol update to all nodes.\n6. Remaining nodes may upgrade and begin using new asset versions.\n7. Old assets can be phased out manually by having the issuer redeem them for new assets, or via a fully automated issuance program that does not require interaction with the issuer.\n\n### 3. Updating core data structures\n\nThe two cases above demonstrated how some specific parts of the transaction structure can be updated. However, blocks are extensible enough to allow an entirely new transaction format introduced via a soft fork. For example, assume that the SHA3 hash function is found to be insecure and the network must migrate to a hypothetical “SHA4” algorithm:\n\n1. The block commitment is extended with a previous block hash 2 field, defined as SHA4 of the previous block, as well as challenge program 2, that implements a new VM using SHA4.\n2. The block witness is extended with signature program 2 that contains proofs matching challenge program 2.\n3. A new asset version is introduced that uses SHA4 in asset IDs, programs, and other asset-specific data structures via input and output commitments.\n4. The block commitment is extended again with additional state and transaction Merkle roots computed with SHA4. Previous commitments using SHA3 remain.\n5. At a certain block height, the block version is incremented to signal the protocol update to all nodes.\n6. Nodes update to support new asset versions and validate the new SHA4-based block commitments.\n\n\n## Conclusion\n\nThe Chain Protocol includes a versioning scheme that facilitates network-wide upgrades. The scheme enables introduction of new features and improvements in a safe and compatible manner, providing meaningful security both for the network nodes and clients that rely on compact proofs instead of full blockchain validation.\n\n\n"},{"Url":"/docs/1.1/protocol/papers/blockchain-programs.md","Body":"# Blockchain Programs\n\n* [Introduction](#introduction)\n* [Chain Virtual Machine](#chain-virtual-machine)\n  * [Stack machine basics](#stack-machine-basics)\n  * [Run limit](#run-limit)\n  * [Instruction set](#instruction-set)\n* [Ivy](#ivy)\n  * [Conditions](#conditions)\n  * [Programs](#programs)\n  * [Composing programs](#composing-programs)\n* [Program functionality](#program-functionality)\n  * [Control programs](#control-programs)\n  * [Issuance programs](#issuance-programs)\n  * [Consensus programs](#consensus-programs)\n  * [Signature programs](#signature-programs)\n* [Examples](#examples)\n  * [Offers](#offers)\n  * [State Machines](#state-machines)\n  * [Singletons](#singletons)\n  * [Private Programs](#private-programs)\n* [Conclusion](#conclusion)\n\n## Introduction\n\nChain Protocol enables flexible control over assets by supporting custom logic at three levels:\n\n* **Issuance programs**, that specify the rules for issuing new units of an asset.\n* **Control programs**, that specify the rules for spending existing units of an asset.\n* **Consensus programs**, that specify the rules for accepting new blocks.\n\nEach program authenticates the data structure in which it is used. Programs run deterministically, use capped memory and time requirements, and can be evaluated in parallel.\n\nPrograms are flexible enough to allow implementing:\n\n* a wide range of financial instruments (such as options, bonds, and swaps),\n* sophisticated security schemes for holding assets,\n* and applications such as offers, order books, and auctions.\n\nThis document discusses design and use cases for custom programs on the blockchain.\n\n## Chain Virtual Machine\n\nA program is written in bytecode — instructions for the Chain Virtual Machine (CVM). The CVM is a stack machine: each instruction performs operations on a *data stack*, usually working on the items on top of the stack. All items on the data stack are strings of bytes, although some instructions convert them to and from numbers or booleans in order to perform operations on them. The CVM also has an *alt stack* to simplify stack manipulation.\n\n[sidenote]\n\nBitcoin, similarly, uses programs as predicates in order to determine whether a given state transition — encoded in a transaction — is authorized. This is different from Ethereum’s approach, in which programs directly compute the resulting state.\n\n[/sidenote]\n\n### Stack machine basics\n\nLet’s take a look at a simple program:\n\n    1 2 ADD 3 EQUAL\n\nThis program encodes the predicate `1 + 2 == 3`.\n\nThe first two instructions are `PUSHDATA` instructions that push their associated values (encoded within the program) on the data stack.\n\nNext, the `ADD` instruction removes the top two values (`1` and `2`), interprets them as integers, adds them together, and pushes the result (`3`) on the stack.\n\nThe next instruction is another `PUSHDATA`. This one pushes the number `3`.\n\nFinally, `EQUAL` removes the top two values (the two copies of the number `3`), compares them byte-by-byte, finds them equal, and so pushes the boolean value `true`.\n\n\n### Run limit\n\nThe CVM’s instruction set is Turing complete. To prevent unbounded use of computational resources, the protocol allows networks to set a *run limit* that a program is not allowed to exceed. Each instruction consumes some of the limit as it runs, according to its *run cost*. Simple instructions have a low cost, while processing-intensive instructions, such as signature checks, are more expensive.\n\n[sidenote]\n\nBoth Bitcoin and Ethereum have restrictions that prevent program execution from using excessive time or memory. Chain’s run limit mechanism is similar to Ethereum’s “gas,” except that there is no on-chain accounting for the execution cost of a transaction.\n\n[/sidenote]\n\nThe run cost also takes memory usage into account. Adding an item to the stack has a cost based on the size of the item; removing an item from the stack refunds that cost.\n\n\n### Instruction set\n\nThe CVM has some overlaps and similarities with Bitcoin Script, but adds instructions to support additional functionality, including loops, state transitions (through transaction introspection), and program evaluation.\n\nWhat follows is a summary of the functionality provided by CVM instructions. For a complete list and more precise definitions, see the [VM specification](../specifications/vm1.md).\n\n#### Stack manipulation\n\nPrograms may encode bytestrings to push on the data stack using a range of `PUSHDATA` instructions. Instructions such as `DROP`, `DUP`, `SWAP`, `PICK`, and others allow moving stack items around. More complex stack manipulations can be assisted by `TOALTSTACK` and `FROMALTSTACK` instructions that move items between the data stack and an alternate stack.\n\n#### String manipulation\n\n`EQUAL` checks for the equality of two strings. `CAT`, `SUBSTR`, `LEFT`, and `RIGHT` perform operations on strings from the top of the stack. `AND`, `OR`, and `XOR` perform bitwise operations.\n\n#### Arithmetic operations\n\nWhile all items on the stack are strings, some instructions interpret items as numbers, using 64-bit two’s complement representation.\n\nThe CVM deterministically checks for overflows: if the result overflows (e.g. too-large numbers are multiplied), execution immediately fails.\n\n#### Boolean operations\n\nItems on the stack can also be interpreted as booleans. Empty strings and strings consisting of only `0x00` bytes are interpreted as `false`, all others are `true`.\n\n#### Cryptographic operations\n\nThe `SHA256` and `SHA3` instructions execute the corresponding hash functions and output 32-byte strings.\n\nThe `CHECKSIG` instruction checks the validity of an Ed25519 signature against a given public key and a message hash.\n\n[sidenote]\n\nWhile similar to Bitcoin instructions, `CHECKSIG` and `CHECKMULTISIG` are generalized to accept an arbitrary message hash. This enables integration with external authoritative data sources and, more importantly, [signature programs](#signature-programs) discussed below.\n\n[/sidenote]\n\n`CHECKMULTISIG` checks an “M-of-N” signing condition using `M` signatures and `N` public keys.\n\n#### Control flow instructions\n\n`VERIFY` pops the top value from the data stack and checks if it is `true`. If it is not, or if there is no top value, the entire program fails.\n\n`JUMPIF` conditionally jumps to another part of the code, based on the current value on top of the stack. This can be used to implement conditionals and loops.\n\n`CHECKPREDICATE` executes a program (written in CVM bytecode) in a separate VM instance. Nested executions are allowed, but the depth is capped by memory cost that is subtracted from the available run limit and refunded when the nested VM instance completes execution.\n\n#### Introspection instructions\n\nThe CVM provides operations that, when used in a control or issuance program, introspect parts of a transaction attempting to spend that output.\n\n[sidenote]\n\nThe Ethereum VM includes many instructions that provide introspection into the execution environment, including the global mutable state.\n\nIn contrast, CVM allows introspection only of the immutable data declared in the transaction, similar to Bitcoin’s `CHECKLOCKTIMEVERIFY` and `CHECKSEQUENCEVERIFY` instructions that check absolute and relative transaction lock times, respectively.\n\n[/sidenote]\n\n`CHECKOUTPUT` allows an input to introspect the outputs of the transaction. This allows it to place restrictions on how the input values are subsequently used. This instruction provides functionality similar to the `CHECKOUTPUTVERIFY` instruction proposed by Malte Möser, Ittay Eyal, and Emin Gün Sirer in their [Bitcoin Covenants](http://fc16.ifca.ai/bitcoin/papers/MES16.pdf) paper. `CHECKOUTPUT` also allows implementing arbitrary state-machines within a UTXO model as was proposed by Oleg Andreev in [Pay-to-Contract](https://github.com/oleganza/bitcoin-papers/blob/master/SmartContractsSoftFork.md) paper.\n\n`MINTIME` and `MAXTIME` allow placing limitations on when an output can be spent. `AMOUNT`, `ASSET`, `PROGRAM`, `REFDATAHASH`, and `INDEX` allow a control program to introspect the input itself.\n\n\n## Ivy\n\nIt is easy to write simple programs directly in bytecode thanks to specialized instructions and the simple execution model. However, to design more complex programs that perform transaction introspection and manipulate more data than a few signatures, a higher-level language is needed.\n\nChain is developing a high-level programming language, *Ivy*, that compiles to CVM bytecode, to make it easier to write and reason about blockchain programs. Ivy is still evolving, and this explanation and tutorial is provided only to help ground the examples used below. Some of the compiled bytecode programs are tweaked for clarity or simplicity.\n\n[sidenote]\n\nMost development for the Ethereum VM is done using [Solidity](https://solidity.readthedocs.io/en/develop/), a high-level language that has been compared to JavaScript. While Ivy and Solidity have some similarities in syntax, they have very different semantics. Solidity can be classified roughly as an object-oriented imperative language, while Ivy fits better into the paradigm of a *declarative language*. This reflects the design differences between Ethereum’s and Chain’s transaction models.\n\n[/sidenote]\n\n\n### Conditions\n\nA *condition* in Ivy is a statement that either *fails* or *succeeds*. Each condition begins with `verify` followed by an expression.\n\n    verify 1 + 1 == 2\n\nThis condition would compile to the CVM bytecode:\n\n    1 1 + 2 EQUAL VERIFY\n\nA condition fails if the given expression evaluates to `false`.\n\nIvy supports the same arithmetic, logical, cryptographic, and string operations as the CVM, but uses more familiar infix and function-call syntax.\n\nFor example, the following condition:\n\n    verify checksig(publicKey, hash, signature)\n\nis compiled to:\n\n    signature hash publicKey CHECKSIG VERIFY\n\n\n\n### Programs\n\nIvy syntax brings additional structure to programs, making it easy to construct and combine sequences of conditions. Like individual conditions, programs do not change state or return values; they simply succeed or fail.\n\nHere is an example of a control program written in Ivy:\n\n\tprogram SingleKeyProgram(publicKey: PublicKey) {\n\t\tpath spend(signature: Signature) {\n\t\t\tverify checksig(publicKey, tx.hash, signature)\n\t\t}\n\t}\n\nLet’s break this program down piece by piece.\n\n* Programs can have **parameters**. This program has one parameter, `publicKey`. Values for a program’s parameters, called **arguments**, are specified at the time the program is *instantiated*, or created. In the case of a control program like this, that is the time that an unspent output is added to the blockchain state by a transaction.\n* Parameters have **types**—such as PublicKey and Signature. These types help the compiler catch bugs in your programs, and make the code more readable.\n* Programs define one or more **paths**. This program has only one path: `spend`. If this control program could be satisfied in different ways, it would have more than one path.\n* Each path can define its own parameters. Arguments for path parameters are provided in the input witness. These arguments are passed — and the path is chosen — at the time the program is executed. In the case of a control program like this, that is the time the unspent output is used as an input in a new transaction. This program takes one argument: a `signature`.\n* Paths contain one or more **conditions**. This path only uses a single condition, which uses the `CHECKSIG` instruction to check that the provided signature on the hash of the new transaction corresponds to the previously specified public key.\n\nControl and issuance programs have access to a global `tx` variable, which allows them to use the transaction introspection instructions. In this case, `tx.hash` uses the `TXSIGHASH` instruction to get the hash of the new transaction.\n\n    TXSIGHASH SWAP CHECKSIG VERIFY\n\nWhen the program is instantiated with a `publicKey` value — to be used in an output — the compiler prepends an instruction pushing that value. For example, if the public key used to initialize it is `0xd75a98...`, the script becomes:\n\n\tPUSHDATA(0xd75a98...) TXSIGHASH SWAP CHECKSIG VERIFY\n\nWhen the output is spent and the control program is run:\n\n1. The virtual machine first takes arguments specified in the input witness and pushes them to the stack. In this case, that argument is a signature.\n2. The program then executes, first pushing the public key and then the transaction hash to the stack.\n3. The public key and transaction hash are then swapped to put them in the correct order for the following `CHECKSIG` instruction.\n4. `CHECKSIG` pops all three items off the stack to check the signature, pushing `true` or `false` to the stack.\n5. `VERIFY` then pops the top value from the stack and causes the program to fail if the value is `false`. (In an actual control program, the `VERIFY` instruction of the last condition in a path is omitted, since it is performed by the VM itself.)\n\nMany control, issuance, and consensus programs use a multisignature check.\n\n\tprogram MultiKeyProgram(n: Number, m: Number, publicKeys: PublicKey[n]) {\n\t\tpath spend(signatures: Signature[m]) {\n\t\t\tverify checkmultisig(n, m, publicKeys, tx.hash, signatures)\n\t\t}\n\t}\n\nThe `PublicKey[n]` syntax allows an argument to be a list of another type of argument, with a given length.\n\n\n### Composing programs\n\nNormally, when a control program is added to the blockchain, its logic and any public keys it contains are available immediately to all observers. What if we don't want to reveal our public keys or logic when the control program is first put on the blockchain, but only when and if it is spent? The control program could commit to a *hash* of the actual program, with the actual program passed as an argument later and then evaluated.\n\n[sidenote]\n\nBitcoin supports a similar pattern, known as “[Pay to Script Hash](https://github.com/bitcoin/bips/blob/master/bip-0013.mediawiki)”\n\n[/sidenote]\n\n\tprogram HashedProgram(programHash: Hash) {\n\t\tpath spend(program: Program, arguments: Arguments) {\n\t\t\tverify sha3(string(program)) == programHash\n\t\t\tverify program(arguments)\n\t\t}\n\t}\n\nThis technique is useful for describing and developing generic patterns for control programs and as a result is used throughout the rest of this guide.\n\nPrograms *themselves* can instantiate programs with arguments to create new programs. In combination with output introspection, this allows construction of complex state machines.\n\nThis is examined in more detail in the [examples](#examples) below.\n\n\n\n## Program functionality\n\nChain Protocol uses programs in three contexts:\n\n* **Transferring assets** using control programs.\n* **Issuing assets** using issuance programs.\n* **Signing blocks** using consensus programs.\n\n### Control programs\n\nControl programs define the conditions for spending assets on a blockchain.\n\nControl programs are sometimes called **addresses**.\n\nControl programs are specified in a transaction output, which also specifies an asset ID and amount. That value is stored on the blockchain in an unspent transaction output (UTXO). To spend that value, someone can create a transaction that uses that unspent output as the source of one of its inputs, as long as they can provide arguments that cause the control program to succeed.\n\nExamples of control programs are described above.\n\n\n### Issuance programs\n\nIssuance programs define the rules for issuing new units of an asset onto the blockchain.\n\nThe issuance program for a given type of asset is fixed when the asset ID is first defined. The issuance program is part of the data structure hashed to create the asset ID, and therefore cannot be changed.\n\nTo issue units of an asset, an issuer creates a transaction with one or more issuance inputs specifying some amount of that asset to be issued. Arguments can be passed in the input witness.\n\nA simple issuance program might just check one or more signatures on the transaction doing the issuance. It would therefore look a lot like the control program described above, with only program and path names changed to match the issuance context:\n\n    program MultisigIssuanceProgram(n: Number, m: Number, publickeys: PublicKey[n]) {\n    \tpath issue(signatures: Signature[m]) {\n    \t\tverify checkmultisig(n, m, publicKeys, tx.hash, signatures)\n    \t}\n    }\n\n### Consensus programs\n\nConsensus programs define the rules for accepting a new block.\n\nEach block includes the consensus program that must be satisfied by the *next* block.\n\nChain’s [federated consensus protocol](federated-consensus.md) relies on a quorum of block signers signing the hash of the block. The consensus program can therefore look a lot like the multisignature issuance and control programs described above:\n\n    program ConsensusProgram(n: Number, m: Number, publickeys: PublicKey[n]) {\n    \tpath checkBlock(signatures: Signature[m]) {\n    \t\tverify checkmultisig(n, m, publicKeys, block.hash, signatures)\n    \t}\n    }\n\n### Signature programs\n\nCVM and Ivy also enable a powerful new way to authorize transactions.\n\nIn the above examples of control programs and issuance programs, asset holders and issuers authorize transactions by signing a hash that commits to the entire transaction. This is the typical way that authorization works in UTXO-based cryptocurrencies such as Bitcoin.\n\n[sidenote]\n\nBitcoin provides “signature hash types” that offer some of the functionality described below. Unfortunately, signature types are relatively inflexible and complex, and are rarely used in practice.\n\n[/sidenote]\n\nSigning the entire transaction hash is fine if you only want to authorize an input to be spent in a particular transaction. However, what if you only know or care about a particular part of a transaction at the time you sign it?\n\nFor example, suppose Alice wants to sell **5 Acme shares** to Bob, in exchange for **10 USD**. Alice wants to authorize the transfer of her Acme shares if and only if she receive payment of 10 USD to her own address. However, Alice does not care what the other input in the transaction will be — i.e., where the other payment will come from. If Alice sends the partially filled transaction to Bob to allow him to fill out the rest, he will have to return it to her to examine (verifying that it pays her the 10 USD she expects) and then sign.\n\nInstead of authorizing a specific transaction, it would be useful if a spender or issuer could preauthorize *any* transaction as long as it meets certain criteria.\n\nTo enable this, the control program for Alice’s Acme shares cannot have the simple form described above, which checks a signature against the transaction hash, since at the time Alice signs it, the transaction is still incomplete and its hash is therefore not yet known. Instead, the control program should look like this:\n\n    program AliceAccount(publicKey: PublicKey) {\n    \tpath spend(signature: Signature, prog: Program, arguments: Arguments) {\n    \t\tverify checksig(publicKey, prog, signature)\n    \t\tverify prog(arguments)\n    \t}\n    }\n\nIn this program, the spender provides a signature of an entirely new *program*, which is then evaluated (with any given arguments). The combined signature and program are referred to as a *signature program*.\n\nThe signature program can use transaction introspection to set conditions on particular parts of the transaction.\n\nFor example:\n\n    program TransactionHashCheck(targetHash: Hash) {\n    \tpath check() {\n    \t\tverify tx.hash == targetHash\n    \t}\n    }\n\nThis program turns a signature program into a traditional signature by committing to a specific transaction hash. This is useful if Alice wants to move funds between accounts or make a simple payment. To do that, she would:\n\n1. compose the target transaction,\n2. compute its hash,\n3. instantiate a `TransactionHashCheck` program with that hash,\n4. sign the program,\n5. place the program and the signature in the input witness to authorize the target transaction.\n\nBut a signature program can do much more than that. For example, this program solves the “exchange” problem described above:\n\n    program ExchangeProgram(targetOutputIndex: Number, targetAmount: Number, targetAssetID: AssetID, targetControlProgram: Program) {\n    \tpath exchange() {\n    \t\tverify tx.outputs[targetOutputIndex] == (targetAmount, targetAssetID, targetControlProgram)\n    \t}\n    }\n\nIf this program is initialized with the details of the desired output — say, **10 USD** sent to Alice’s new address — and signed with Alice’s private key, the combined signature program will authorize Alice’s input to be spent only in a transaction that includes the desired output.\n\n[sidenote]\n\nChristopher Allen and Shannon Appelcline explore ideas similar to signature programs in their working paper on “[Smart Signatures](https://github.com/WebOfTrustInfo/ID2020DesignWorkshop/blob/master/draft-documents/smarter-signatures.md).”\n\n[/sidenote]\n\n\n## Examples\n\nUsing the building blocks described above, it is possible to implement financial applications that are enforced by the network (so-called \"smart contracts\").\n\nThe examples that follow are provided as illustrations only. They gloss over some subtleties and should not be considered final or secure.\n\n### Offers\n\nThe following control program implements an open offer to sell the controlled assets to anyone who pays the specified price to the seller's address:\n\n    program Offer(askingPrice: Number, currency: AssetID, sellerProgram: Program) {\n    \tpath lift(paymentIndex: Number) {\n    \t\tverify tx.outputs[paymentIndex] == (askingPrice, currency, sellerProgram)\n    \t}\n    }\n\nThat program will be on the blockchain until someone satisfies it with a corresponding payment. What if we want to make it revocable by the seller?\n\n    program RevocableOffer(askingPrice: Number, currency: AssetID, sellerProgram: Program) {\n    \tpath lift(paymentIndex: Number) {\n    \t\tverify tx.outputs[paymentIndex] == (askingPrice, currency, sellerProgram)\n    \t}\n    \tpath cancel(arguments: Arguments) {\n    \t\tverify sellerProgram(arguments)\n    \t}\n    }\n\nThe offer can be made irrevocable for a certain period of time, and then automatically expire after some later point.\n\n    program TimeLimitedOffer(askingPrice: Number, currency: AssetID, sellerProgram: Program, revocabilityTime: Time, expirationTime: Time) {\n    \tpath lift(paymentIndex: Number) {\n    \t\tverify tx.maxtime \u003c expirationTime\n    \t\tverify tx.outputs[paymentIndex] == (askingPrice, currency, sellerProgram)\n    \t}\n    \tpath cancel(arguments: Arguments) {\n    \t\tverify tx.mintime \u003e revocabilityTime\n    \t\tverify sellerProgram(arguments)\n    \t}\n    }\n\nWhat if we want to be able to fill a *partial* order, allowing someone to pay for part of the program and leaving the rest available for someone else to purchase?\n\n    program PartiallyFillableOffer(pricePerUnit: number, currency: AssetID, sellerProgram: Program) {\n    \tpath lift(purchasedAmount: Number, paymentIndex: Number, remainderIndex: Number) {\n    \t\tverify purchasedAmount \u003e 0\n    \t\tverify tx.outputs[paymentIndex] == (purchasedAmount * pricePerUnit, currency, sellerProgram)\n    \t\tverify tx.outputs[remainderIndex] == (tx.currentInput.amount - purchasedAmount,\n    \t\t\t\t\t\t\t\t\t\t\t  tx.currentInput.asset,\n    \t\t\t\t\t\t\t\t\t\t\t  tx.currentInput.program)\n    \t}\n    \tpath cancel(arguments: Arguments) {\n    \t\tverify sellerProgram(arguments)\n    \t}\n    }\n\nNotice that the remainder must be sent to a new program that is a duplicate of the current one, just controlling fewer assets.\n\n\n### State Machines\n\nWhat if you want to get more complex than just replicating the same program, but want to change its state when you do? This is where the program model really shines. Programs can instantiate programs with new arguments on the fly.\n\nThis program will prevent its assets from being transferred more than once within a certain time period:\n\n    program OncePerPeriod(authorizationPredicate: Program, lastSpend: Time, period: Duration) {\n    \tpath spend(index: Number, arguments: Arguments) {\n    \t\t// check that the spending is otherwise authorized\n    \t\t// this could be a signature check\n    \t\tverify authorizationPredicate(arguments)\n\n    \t\t// check that at least one day has passed\n    \t\tverify tx.mintime \u003e lastSpend\n\n    \t\tnextControlProgram = OncePerPeriod(authorizationPredicate,\n    \t\t\t\t\t\t\t\t\t\t   tx.maxtime,\n    \t\t\t\t\t\t\t\t\t\t   period)\n\n    \t\tverify tx.outputs[index] == (tx.currentInput.amount,\n    \t\t\t\t\t\t\t\t tx.currentInput.asset,\n    \t\t\t\t\t\t\t\t nextControlProgram)\n    \t}\n    }\n\n\n### Singletons\n\nWhile most state should be tracked locally in the program-level arguments for a specific unspent output, some on-chain use cases may require keeping track of “global” state. For example, one may want to limit issuance of an asset, so only 100 units can be issued per day. This can be done using the *singleton* design pattern.\n\nFirst, one needs to create an asset for which only one unit can ever be issued. This requires some understanding of how the Chain Protocol handles issuances. Unique issuance — ensuring that issuances cannot be replayed — is a challenging problem that is outside the scope of this paper. The Chain Protocol’s solution is that each issuance input has a nonce that, when combined with the transaction’s `mintime`, `maxtime`, and asset ID, must be unique throughout the blockchain’s history. As a result, an issuance *program* can ensure that it is only used once by committing to a specific nonce, transaction mintime, and transaction maxtime:\n\n    program SinglyIssuableAssetSingletonToken(nonce: String, mintime: Time, maxtime: Time, amount: Number, lockProgram: Program) {\n    \tpath issue(outputIndex: Number) {\n    \t\t// ensure that asset can only be issued once\n    \t\tverify nonce == tx.currentInput.nonce\n    \t\tverify mintime == tx.mintime\n    \t\tverify maxtime == tx.maxtime\n\n    \t\t// ensure that only one unit is issued\n    \t\tverify tx.currentInput.amount == 1\n\n    \t\t// ensure that the issued unit is locked with the target lockProgram\n    \t\tverify tx.outputs[outputIndex] == (tx.currentInput.amount,\n    \t\t\t\t\t\t\t\t\t\t   tx.currentInput.asset,\n    \t\t\t\t\t\t\t\t\t\t   lockProgram)\n    \t}\n    }\n\nThis means there will only be one unspent output on the blockchain with this asset ID at a given time. As a result, it can be used as a *singleton* — a token to keep track of some piece of global state for other asset IDs.\n\nThe `lockProgram` parameter of this program determines the rules that will govern the token.\n\nFor example, we've already seen the `OncePerPeriod` program. If that program is used as the “lock program”, the singleton token can be prevented from being spent more than once in a particular amount of time.\n\nHow does that help us with metered issuance? We can create a separate asset with an issuance program that checks that the singleton is also spent in the same transaction, and that no more than a given amount is issued.\n\n    program MeteredAssetIssuanceProgram(authorizationPredicate: Program, singletonAssetID: AssetID, maxAmount: Number) {\n    \tpath issue(singletonControlProgram: Program, singletonIndex: Number, arguments: Arguments) {\n    \t\t// check that the issuance is otherwise authorized\n    \t\tverify authorizationPredicate(arguments)\n\n    \t\t// check that no more than the max amount is being issued\n    \t\tverify tx.currentInput.amount \u003c maxAmount\n\n    \t\t// check that the singleton token is being spent\n    \t\t// its index and control program don't need to be checked\n    \t\t// which is why they are passed as arguments\n    \t\tverify tx.outputs[singletonIndex] == (1,\n    \t\t\t\t\t\t\t\t\t\t   singletonAssetID,\n    \t\t\t\t\t\t\t\t\t\t   singletonControlProgram)\n    \t}\n    }\n\n\n### Private Programs\n\nPrograms on the blockchain are made secure because the entire network may verify correctness of their execution. This necessarily means that all data necessary for execution is made public. But what if parties to a contract wish to avoid revealing sensitive parameters (such as prices, interest rates, deadlines etc)? They can achieve a level of privacy by adding an additional path that lets all interested parties spend the output without revealing the path that actually enforces the contract:\n\n    program PrivateControlProgram(programHash: Hash, n: Number, publicKeys: PublicKeys[n]) {\n    \tpath settle(signatures: Signature[n]) {\n    \t\t// all interested parties can agree to the final result of the program\n    \t\tverify checkmultisig(n, n, publicKeys, tx.hash, signatures)\n    \t}\n    \tpath enforce(prog: Program, arguments: Arguments) {\n    \t\t// any party can reveal the program and enforce it\n    \t\tverify sha3(prog) == programHash\n    \t\tverify prog(arguments)\n    \t}\n    }\n\nParties can evaluate the program privately, determine the result, mutually agree to how it should resolve, and provide their signatures on the resulting transaction. If any party refuses to agree to the result, another party can enforce the program by making its code public. This is similar to how contract enforcement works in the real world: details can remain private unless and until disputes have to be settled in court.\n\n[sidenote]\n\nThis idea can be extended to implement full [Merklized Abstract Syntax Trees](http://www.mit.edu/~jlrubin/public/pdfs/858report.pdf) — programs for which unexecuted branches do not need to be revealed. Similar ideas have also been explored by so-called “payment channels” in Bitcoin, most famously in the [Lightning Network](https://lightning.network/) project, as well as “[state channels](http://www.jeffcoleman.ca/state-channels/)” in Ethereum.\n\n[/sidenote]\n\n\n## Conclusion\n\nThe Chain Protocol enables flexible control over assets through programmatic conditions that govern both issuance and transfer, as well as integrity of the ledger. Programs are executed by a Chain Virtual Machine with a Turing-complete instruction set. Programs are evaluated as predicates in a restricted, stateless environment that ensures safety and scalability. Programs can use powerful transaction introspection instructions that allow building sophisticated smart contracts and state machines. To make it more efficient to design programs, Chain is developing Ivy, a high-level programming language that compiles to CVM bytecode.\n"},{"Url":"/docs/1.1/protocol/papers/federated-consensus.md","Body":"# Federated Consensus\n\n* [Introduction](#introduction)\n* [Consensus programs](#consensus-programs)\n* [Federated consensus program](#federated-consensus-program)\n* [Consensus algorithm](#consensus-algorithm)\n* [Safety guarantees](#safety-guarantees)\n* [Liveness guarantees](#liveness-guarantees)\n* [Consensus program changes](#consensus-program-changes)\n* [Policy enforcement](#policy-enforcement)\n* [Future improvements](#future-improvements)\n\n## Introduction\n\nIn this guide we discuss the design of the federated consensus protocol used by the Chain Protocol: its goals, use cases, threat models, and areas for future improvement.\n\nFederated consensus is a mechanism ensuring that all participants in a network agree on a single transaction log. This prevents different versions of the ledger being shown to different participants — thus preventing “double-spending” of assets — as well preventing history from being edited. While the blockchain validation rules specify _whether_ a given blockchain is valid, the consensus protocol makes sure there is _only one_ valid blockchain on a given network. \n\nThis consensus protocol is designed to be practically useful under a certain set of requirements and assumptions commonly encountered in permissioned blockchain networks. The Chain Protocol is capable of supporting alternative consensus protocols.\n\nFor a detailed description of the federated consensus protocol, see the [formal specification](../specifications/consensus.md).\n\n## Consensus programs\n\nThe Chain Protocol blockchain validation rules are intentionally agnostic as to what kind of consensus protocol is enforced. Additionally, they do not play a role in the process by which consensus is reached. Instead, blockchains provide a way for network participants to evaluate whether consensus has been reached: namely, _consensus programs_. The consensus program specifies a set of conditions that must be satisfied for a block to be accepted. The separation of consensus logic from blockchain validation rules, together with flexibility of consensus programs, allows networks to adopt of arbitrary consensus protocols, even including ones based on proof-of-work and proof-of-stake.\n\nThe consensus program for each block is specified in the header of the previous block. When the block is validated by a network participant, the consensus program is executed with the *arguments* that are specified in the block header. If the consensus program fails, the block is considered invalid.\n\nConsensus programs are written for and executed by the Chain Virtual Machine. See [Blockchain Programs](./blockchain-programs.md#consensus-programs) and [Chain VM Specification](../specifications/vm1.md) for details.\n\nThe consensus protocol presented here uses relatively simple consensus programs, but the Chain Protocol supports more complex programs that could allocate signing authority in more complex ways.\n\n\n## Federated consensus program\n\nUnder the federated consensus protocol, blocks are considered accepted once they have been signed by a specified quorum of *block signers*. This is implemented using a consensus program that checks an “M-of-N multisignature” rule, where N is the number of block signers, and M is the number of signatures required for a block to be accepted. \n\nThe program specifies the public keys of each of the N block signers. The signatures are passed in the arguments. The program checks the signatures against the prespecified public keys to confirm that they are valid signatures of the hash of the new block. New blocks may reuse the same consensus program or change it to a new one (as when members join and leave the federation) as long as a quorum of block signers approves the change.\n\nThe values of these parameters, M and N, can be tweaked according to business requirements or the security parameters of the network. The safety and liveness implications of these choices are described below.\n\n## Consensus algorithm\n\nAssuming that every participant in the network trusts a sufficient subset of the block signers, the consensus program described above reduces the problem of reaching network-wide consensus to the simpler problem of reaching a consensus of at least M out of N block signers.\n\nTo efficiently do so, block signers agree on a single *block generator*. The generator's signature is only used to coordinate the block signers; it is not seen or validated by the network. This allows block signers to evolve the consensus mechanism without any additional support from the rest of the network.\n\nThe block generator:\n\n* receives transactions from the network,\n* filters out transactions that are invalid,\n* filters out transactions that do not pass local policy checks,\n* periodically aggregates transactions into blocks,\n* sends each proposed block to the block signers for approval.\n\nEach block signer:\n\n* verifies that the proposed block is signed by the generator,\n* verifies that the block is valid under its (the signer’s) current state without checking that the previous _consensus program_ is satisfied (which requires the block signers’ signatures),\n* verifies that it has not signed a different block at the same or greater height,\n* verifies that the block timestamp is no more than 2 minutes ahead of the current system time,\n* verifies that the block contains an acceptable consensus program (for authenticating the next block),\n* if all checks passed, signs the block.\n\nOnce the block generator receives signatures from enough block signers (as defined by the previous block's consensus program), it publishes the block to the network. All network participants, including the block signers, validate that block (including checking the previous consensus program is satisfied) and update their state.\n\n\n## Safety guarantees\n\nSafety — specifically, the assurance that a valid block is the only valid block at that height — is guaranteed as long as no more than `2M - N - 1` block signers violate the protocol. For example, if the consensus program requires signatures by 3 of 4 block signers, the blockchain could only be forked if 2 block signers misbehave by signing two blocks at the same height.\n\nAn attempt to fork the blockchain by signing multiple blocks can be detected and proven by anyone with access to both block headers. Network participants could implement a gossip protocol to share block headers and detect an attempted fork immediately, as long as the network is not partitioned. Double-signing can be proven after the fact, and dealt with out-of-band.\n\nAnother potentially desirable safety guarantee is the assurance that, if a block header's consensus program is satisfied, there is a corresponding valid blockchain history — i.e., no transaction is unbalanced and all programmed conditions are satisfied. This guarantee is assured as long as no more than `N - M` block signers are faulty.\n\nThis latter guarantee is useful for clients that do not have full visibility into the blockchain, instead using _compact proofs_ to check some transaction or piece of state against the block headers. Network participants that have visibility into entire blocks and has seen the entire history of the blockchain — or which trust some other party which does have such visibility — have no need to trust block signers for this particular guarantee. \n\n## Liveness guarantees\n\nLiveness is guaranteed as long as: \n\n* The generator is not faulty, and\n* No more than `N - M` block signers are faulty\n\nIf the block generator crashes or becomes unavailable, the network cannot generate new blocks. If the block generator disobeys the protocol by sending different blocks to different signers, it can even *deadlock* the protocol.\n\nThis reliance on a single specific participant is relatively unusual for modern consensus protocols. However, it provides many efficiency and simplicity benefits, and has only limited downside in many target use cases.\n\nGuaranteeing the liveness of the generator is an easier technical problem than a more complicated consensus protocol that allows any block signer to propose a block. The block generator can be operated as a distributed system within a single organization's trust boundary. It can therefore be made highly available using traditional replication methods, including non-Byzantine-fault-tolerant consensus protocols.\n\nIf the generator is intentionally shut down by the network operator, or if it ceases to correctly follow the protocol (whether due to a hack, a bug, or malicious intent by its operator), the network can safely halt until manual intervention.\n\n## Consensus program changes\n\nIf members need to be added or removed from the federation, or if keys need to be rotated, the federation may agree out of band on a new consensus program to be used in new blocks beginning at a certain timestamp.\n\n## Policy enforcement\n\nThe block generator may enforce local “policies” to filter out non-compliant transactions. For example, a block generator could require that transactions include AML/KYC information in its reference data. Since policy enforcement is not a part of the protocol rules, it is flexible, can be changed at will, and may use confidential information that should not be shared with the whole network.\n\n## Future improvements\n\nFuture versions of the Chain Protocol may move further in the direction of full Byzantine-fault-tolerance, such as by supporting leader rotation or multi-phase commitment. Protocols such as [PBFT](http://pmg.csail.mit.edu/papers/osdi99.pdf) and [Tendermint](https://atrium.lib.uoguelph.ca/xmlui/bitstream/handle/10214/9769/Buchman_Ethan_201606_MAsc.pdf?sequence=7) show promise in this area. \n\nFuture protocols may also include specifications of fraud proofs and gossip protocols to allow network participants to more easily detect and report problems in the network, such as forks or signatures on invalid blocks. \n\n\n\n"},{"Url":"/docs/1.1/protocol/papers/whitepaper.md","Body":"# Chain Protocol Whitepaper\n\n1. [Introduction](#1-introduction)\n2. [Motivation](#2-motivation)\n3. [Data model](#3-data-model)\n4. [Programs](#4-programs)\n5. [Consensus](#5-consensus)\n6. [Security](#6-security)\n7. [Scalability](#7-scalability)\n8. [Extensibility](#8-extensibility)\n9. [Interoperability](#9-interoperability)\n10. [Conclusion](#10-conclusion)\n\n## 1. Introduction\n\nIn this paper, we present the Chain Protocol: a design for a shared, multi-asset, cryptographic ledger. It supports the coexistence and interoperability of multiple independent networks, with different operators, sharing a common format and capabilities. Using the principle of least authority, control over assets is separated from control over ledger synchronization.\n\nThe Chain Protocol allows any network participant to define and issue assets by writing custom “issuance programs.” Once issued, units of an asset are controlled by “control programs.” These programs are expressed in a flexible and Turing-complete programming language that can be used to build sophisticated smart contracts.\n\nEach network is secured by a federation of “block signers.” The system is secure against forks as long as a quorum of block signers follows the protocol. For efficiency, block creation is delegated to a single “block generator.” Any node on the network can validate blocks and submit transactions to the network.\n\nChain Core is an enterprise software product that implements the Chain Protocol. An open-source [developer edition](https://github.com/chain/chain) is freely available, and Chain operates a Chain blockchain network as a freely accessible testnet. \n\nIn the [second section](#2-motivation), we explain the background and motivation for the design of the protocol.\n\nNext, we describe key concepts — [assets, transactions, blocks](#3-data-model), [programs](#4-programs) and [consensus protocol](#5-consensus) — and discuss how programmed rules are enforced and double-spending is prevented.\n\nFinally, we discuss various aspects of the blockchain network: [security](#6-security), [scalability](#7-scalability), [extensibility](#8-extensibility) and [interoperability with other networks](#9-interoperability).\n\n\n## 2. Motivation\n\nIn the modern financial system, assets such as currencies, securities, and derivatives are typically held and traded electronically. This miraculous abstraction hides the true complexity of the system: a messy decentralized web of mutual obligations, indirect ownership, and periodic settlement. Transferring assets often requires point-to-point interaction between multiple intermediaries, and reconciliation of duplicated ledgers.\n\nThis system has many downsides:\n\n* **Time:** settlement of asset transfers or payments often takes days.\n* **Cost:** transfers involve fee payments to multiple intermediaries, and reconciliation has expensive overhead.\n* **Transparency:** it may be difficult to find out the status of a pending transfer or the current owner of an asset.\n* **Atomicity:** transfers may not complete, and it is difficult to make one transfer conditional on another.\n* **Security:** the complexity of the existing system makes it difficult to prevent fraud or theft.\n* **Finality:** whether transactions are reversible depends on the transfer mechanism, rather than the business requirements of the transacting party.\n\nMany of these problems could be addressed if asset ownership were recorded on a *single shared ledger*. But a combination of practical and technological constraints have made such ledgers difficult to adopt. Such a shared ledger would tend to require trust in a single party. That party would need to have the technical capacity to process every transaction in real time. Additionally, to support reversible, atomic, or complex transactions, the ledger would need to support more sophisticated logic than simple ownership changes.\n\nIn 2009, Satoshi Nakamoto introduced [Bitcoin](https://bitcoin.org/bitcoin.pdf), the first implementation of a protocol that enables issuance of a digital bearer instrument without a trusted third party, using a ledger replication system that has come to be known as a “blockchain.” Bitcoin solves the difficult problem of implementing decentralized digital cash, but its security model limits its efficiency and throughput, its design only supports a single native asset, and its virtual machine has only limited support for custom programs that determine asset movement, sometimes called “smart contracts.”\n\nEthereum, which launched in 2015, generalizes the concept of a blockchain to a fully programmable state replication mechanism. While it includes a much more powerful programming language, it presents additional challenges for scalability and efficiency. Its general-purpose computation model makes it difficult for engineers to reason about security of their applications.\n\nIn contrast to Bitcoin and Ethereum, which are designed to operate on the public Internet (a highly hostile environment), most financial activity already occurs within restricted networks of financial institutions. A shared ledger operated within this network can exhibit the advantages of blockchain technology without sacrificing the efficiency, security, privacy, and flexibility needed by financial institutions.\n\n\n## 3. Data model\n\nThe purpose of a Chain blockchain network is to manage issuance, ownership, and control of digital *assets*. Assets are issued, transferred, and exchanged by posting *transactions* to the network. These transactions are ordered and batched into *blocks*, which together form an immutable *blockchain*.\n\n#### Assets\n\nA single Chain blockchain can support multiple types of assets.\n\nEach type of asset has an asset identifier, or *asset ID*. An asset ID is a 256-bit string designed to be globally unique not only within one blockchain, but across all blockchains.\n\nEach Asset ID corresponds to an *issuance program*, which defines the rules for issuing units of that asset. Once units have been issued, the rules for spending them are determined by *control programs*.\n\n#### Transactions\n\nTransactions move value from *inputs* to *outputs*. Each input specifies a source of value — either an issuance of new units, or an output from a previous transaction. Each output specifies a destination — namely, a control program defining the rules for spending that output in the future.\n\nEach input and output specifies a quantity of a single asset ID. A transaction can mix inputs and outputs of different asset IDs, or merge or split inputs into outputs with different amounts, as long as the total values of the inputs and the total values of the outputs balance.\n\n![Transaction](whitepaper-tx.png)\n\nEach input must satisfy an *issuance program* (if the source of value is a new issuance of units) or a *control program* (if the source of value is a previous unspent transaction output). The issuer or spender may pass *arguments* to the program via the *witness* field. For example, an issuance or control program can implement an authorization check by defining a public key and requiring a cryptographic signature over the transaction by the corresponding private key.\n\n[sidenote]\n\nThis “witness” field is not included in the transaction ID, and is therefore not covered by signatures of the transaction, which is why such signatures can themselves be included in the witness. This design is partially inspired by the “segregated witness” proposal, described in [BIP 141](https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki) by Pieter Wuille et al., which is expected to be adopted by the Bitcoin network by the end of 2016. \n\n[/sidenote]\n\nEach transaction, and each individual input and output, includes a *reference data* field for arbitrary application-level uses. The Chain Protocol specifies how reference data is committed to the blockchain, but does not mandate any structure or semantics for its contents.\n\n![Spending Transaction Output](whitepaper-spend.png)\n\n#### Blocks\n\nOnce a transaction has spent a particular output, no other transaction is allowed to spend that same output. To prevent such “double-spending”, the network maintains a unique and immutable ordering of all transactions together with a *blockchain state* consisting of *unspent transaction outputs* (UTXOs). Transaction inputs are allowed to reference only unspent outputs from the UTXO set. Once a transaction is applied, the spent outputs are removed from the set and the new outputs are added to it.\n\n![Blockchain](whitepaper-blocks.png)\n\nA *block* is a data structure that batches multiple transactions to be executed. Each *block header* contains the hash of the previous block, turning the series of blocks into an immutable *blockchain*. \n\n[sidenote]\n\nA *hash* is the result of running a deterministic one-way hash function on a given input data. A good hash function is collision-resistant: it is infeasible to find two inputs that hash to the same output. This property makes a blockchain immutable, since it is impossible to change a block without changing its hash, and thus changing the hashes in the headers of all subsequent blocks.\n\n[/sidenote]\n\nA block contains the hash of all its transactions and the hash of the current state — i.e., the set of current unspent outputs. This “snapshot” of the blockchain state makes it easy for a network participant to join an ongoing network without having to “replay” the blockchain’s entire history. The hashes are the roots of two *Merkle trees* that enable compact proofs of existence of any given transaction or unspent output, and allow concurrent download and verification of their elements.\n\nTo prevent unauthorized participants from creating new blocks, each new block must satisfy a *consensus program*, which is specified in the header of the previous block. The consensus program — much like an issuance or control program — receives  arguments from the new block’s *witness* field.\n\nFor example, a consensus program could specify a public key, and require that the next block’s witness contain a signature by the corresponding private key, using the block hash as a message. This is the basis of the consensus programs used in Chain’s [federated consensus protocol](#5-consensus). The flexibility and power of the [programming language](#4-programs), however, means that the protocol could theoretically support arbitrary consensus algorithms — even complex ones based on “proof-of-work” or “proof-of-stake”.\n\n## 4. Programs\n\nChain Protocol blockchains are designed to be flexible and programmable, supporting custom logic at every level.\n\n* *Issuance programs* specify the rules for issuing new units of an asset.\n* *Control programs* specify the rules for spending existing units of an asset.\n* *Consensus programs* specify the rules for accepting new blocks.\n\nPrograms authenticate the data structure in which they are used. They run deterministically, use capped memory and time requirements, and can be evaluated in parallel.\n\nPrograms are flexible enough to allow implementing a wide range of financial instruments (such as options, bonds, and swaps), security schemes (for storing assets), and applications such as offers, escrows, and auctions.\n\n#### Virtual machine\n\nA *program* is written in *bytecode* — instructions for the Chain Virtual Machine (CVM). The CVM is a stack machine: each instruction performs operations on a data stack. \n\nWhen validating a program, the CVM initializes the data stack with *program arguments* passed from the witness. The program is then executed, and either succeeds or fails.\n\nThe CVM’s instruction set is Turing complete. To prevent unbounded use of computational resources, the protocol allows networks to set a *run limit* that a program is not allowed to exceed. Each instruction consumes some of the limit as it runs, according to its *run cost*.\n\n[sidenote]\n\nBitcoin, similarly, uses scripts as predicates in order to determine whether a given state transition — encoded in a transaction — is authorized. This is different from Ethereum’s approach, in which programs directly compute the resulting state.\n\nBoth Bitcoin and Ethereum have restrictions that prevent script execution from using excessive amounts of time or memory. Chain’s run limit mechanism is similar to Ethereum’s “gas,” except that there is no on-chain accounting for the execution cost of a transaction.\n\n[/sidenote]\n\nThe CVM provides a range of data processing instructions, from arithmetic operations to higher-level cryptographic functions such as `SHA3`, `CHECKSIG`, and `CHECKMULTISIG`. It also supports transaction introspection instructions and flexible control-flow operations.\n\n#### Introspection\n\n*Transaction introspection* instructions allow an issuance program or control program to define not only *who* can spend it, but *when* and *how* it can be spent. They do this by allowing the program to access and evaluate fields of the transaction.\n\nThe `TXSIGHASH` instruction gets the hash of the current transaction, allowing the program to check that a spender has provided a valid signature.\n\nThe `MINTIME` and `MAXTIME` instructions get the respective “mintime” and “maxtime” fields of the transaction, allowing the program to prevent spending or issuance after a given deadline, or before a given release time.\n\nThe `CHECKOUTPUT` instruction allows a program to verify that specific amounts of assets are sent to outputs with specific control programs. This, along with introspection instructions that allow access to information about the input being spent (`AMOUNT`, `ASSET`, `PROGRAM`, and `INDEX`), allows developers to implement arbitrary state machines to govern assets.\n\n[sidenote]\n\nThe `MINTIME` and `MAXTIME` instructions (and their associated transaction fields) provide functionality similar to Bitcoin’s `CHECKLOCKTIMEVERIFY`.\n\nThe `CHECKOUTPUT` instruction provides functionality similar to the `CHECKOUTPUTVERIFY` instruction proposed by Malte Möser, Ittay Eyal, and Emin Gün Sirer in their [Bitcoin Covenants](http://fc16.ifca.ai/bitcoin/papers/MES16.pdf) paper.\n\n[/sidenote]\n\nThe protocol also specifies several *block introspection* instructions (`BLOCKHASH`, `NEXTPROGRAM`). These instructions can only be used in consensus programs (since transactions must be capable of being validated independently of the block header).\n\n#### Control flow\n\nPrograms can implement conditional branches and loops using the `JUMP` and `JUMPIF` instructions, which allow branching to a statically defined address in the program. The run limit ensures that infinite loops are not possible.\n\nPrograms can verify other programs using the `CHECKPREDICATE` instruction, which evaluates an arbitrary byte string as a program with given arguments. \n\nThis instruction permits a generalization of signatures where, instead of signing a specific message (such as a transaction hash), the signer signs a predicate in its byte-string form. The combined signature and predicate is a “signature program” that is considered a valid signature on any message for which the predicate evaluates to true. When combined with the introspection instructions, signature programs allow much greater flexibility in spending a transaction: instead of authorizing a specific transaction by signing its hash, a spender can sign a set of conditions that the transaction must fulfill (which may include having a specific hash). This enables partially signing a transaction before it is completed or balanced.\n\n`CHECKPREDICATE` enables many other powerful features, including “Merkleized programs” (see [MAST by Jeremy Rubin et al](http://www.mit.edu/~jlrubin/public/pdfs/858report.pdf)) that commit to hashes of each branch, but do not require revealing the contents of a branch unless it needs to be executed.\n\n## 5. Consensus\n\nAs described above, a consensus program allows the blockchain to implement arbitrary consensus protocols. The first version of the Chain Protocol specifies a default consensus protocol based on approval from a federation of block signers.\n\n[sidenote]\n\nThe Chain Protocol’s approach to federated consensus is similar to one described by Nick Szabo in [Secure Property Titles with Owner Authority](http://nakamotoinstitute.org/secure-property-titles/), published in 1998.\n\n[/sidenote]\n\nA consensus program specifies a set of N public keys and uses the `CHECKMULTISIG` and `BLOCKHASH` instructions to confirm that the block witness includes M valid signatures on the block hash (where M and N are parameters of the algorithm).\n\nEach public key corresponds to a block signer. Block signers should never sign two different blocks with the same height. As long as no more than 2M - N - 1 block signers violate this rule, the blockchain cannot be forked.\n\nBecause of this rule, block signers must coordinate to make sure they sign the same block. To ensure this, they rely on a single *block generator*. The block generator collects transactions, periodically batching valid ones together into blocks.\n\nThe generator sends each proposed new block to the block signers. Block signers only sign blocks that have already been signed by the generator.\n\nWhile the block generator is not capable of forking the blockchain, it does have a privileged role. The block generator has control over network liveness: if the block generator crashes or otherwise stops producing new blocks, the blockchain halts. The block generator can also deadlock the network by sending inconsistent blocks to different block signers. Additionally, the block generator has control over the block timestamp, and can produce blocks with artificially “slow” timestamps. \n\nThese tradeoffs are considered acceptable based on the current business use cases for the protocol. For most permissioned networks, it makes sense to have a single company or market utility responsible for continued operation of the network. High-availability of the block generator is an engineering problem that can be solved through replication, without the need for Byzantine-fault-tolerant distribution. If the block generator behaves maliciously, or is intentionally shut down, it is probably better (in these use cases) for the network to stop. Such misbehavior can be detected and dealt with out-of-band.\n\n![Federated Consensus](whitepaper-consensus.png)\n\nThis consensus protocol, therefore, does not attempt to solve the general problem of Byzantine agreement. It requires trust assumptions that are unusually strong relative to Byzantine-fault-tolerant algorithms, but usefully weak relative to centralized databases. In practice, they are reasonable for many real-world deployments. Future versions of the Chain Protocol may specify consensus protocols with weaker assumptions for a broader range of applicability.\n\n## 6. Security\n\nThe Chain Protocol is intended to be secure under realistic threat models for specific use cases.\n\n#### Direct asset ownership\n\nAssets are typically controlled by one or more cryptographic keys. The Chain Protocol supports M-of-N *multisignature* control programs and issuance programs that help reducing the risk of theft by tolerating compromise of up to M–1 cryptographic keys. The protocol uses highly secure Ed25519 keys, which are increasingly being adopted as an industry standard. Private keys can be generated and stored in hardware security modules (HSMs), making key compromise much more difficult. HSM integration is included as a feature in [Chain Core Enterprise Edition](https://chain.com/enterprise).\n\n#### Privacy\n\nTraditional ledgers achieve a level of privacy by limiting information access to the parties involved and a trusted third party. By contrast, the requirement of a blockchain system to announce all transactions to all network participants precludes this method. Privacy can still be maintained, however, by breaking the flow of information in another place: keeping public keys pseudonymous. The network can see that a transaction occurred, but uninvolved parties lack the information to link the transaction with specific identities.\n\nChain’s implementation of the Chain Protocol, Chain Core, uses unique public keys for each control program to prevent observers from linking multiple outputs to one account. Individual keys are derived from a single master key to make key management safer. Chain Core implements a [key derivation scheme](../specifications/chainkd.md) that allows public and private keys to be derived from the common master key pair independently, therefore permitting creation of unique public keys without access to the master private key.\n\nPrograms that facilitate multi-party contracts may depend on sensitive data such as deadlines, prices, and interest rates. These can be hidden via Merkleized programs (see [MAST](http://www.mit.edu/~jlrubin/public/pdfs/858report.pdf)) that contain only hashes of each branch, for which only the executed branches need to be revealed during execution. Such a smart contract could allow spending in one of two ways: by providing signatures from all parties on the new transaction (allowing parties to agree to how a contract should be resolved, while preserving privacy), or by revealing and executing the private smart contract code. This is similar to how contracts work in the real world — while enforcement in court typically requires the terms of the contract to be made public, most contracts are settled in private, with the public system only necessary as an implicit backstop.\n\nThe Chain Protocol can also be extended with additional confidentiality features, as covered in [Blockchain Extensibility](blockchain-extensibility.md).\n\n#### Consensus security\n\nSecurity against forks — i.e., security against history-editing or double-spending — is enforced by the consensus protocol.\n\nThe consensus protocol guarantees safety — i.e, the blockchain cannot be “forked” to show two different versions of history — as long as at least 2M – N – 1 block signers obey the protocol. The protocol guarantees liveness as long as the block generator and at least M block signers follow the protocol.\n\nIf signers attempt to fork the blockchain, this behavior can be detected and proven to an observer. Finally, any party that monitors the block headers can detect history-editing when it occurs.\n\nThe set of participants and the number of required block signatures can be configured differently for each blockchain network to provide different tradeoffs between liveness, efficiency, and safety. Within a network, those parameters can change over time (with the approval of a quorum of block signers ) as the needs of the network evolve.\n\n#### Local policy\n\nBlock generators can implement local policies that filter out non-compliant transactions. This allows implementation of business or regulatory requirements (such as KYC/AML rules) that are outside the scope of the protocol. Local policies can be changed freely over time, as they are not enforced and verified by the rest of the network nodes.\n\n#### Compact proofs\n\nThe block header includes the Merkle root of the transactions in the block as well as the current UTXO state, which allows compact *Merkle proofs* about a given part of the blockchain, such as whether a transaction has been accepted, or whether a particular UTXO remains unspent. Merkle proofs link a piece of data to a block header, from which a participant can check the timestamp and the block signers’ signatures. \n\nAs a result, entities can participate in the network without seeing any transactions other than the ones in which they are involved. They only need to validate block headers, along with compact proofs of the relevant transactions and/or UTXOs.\n\nCompact proofs can also protect network participants against misbehaving block signers. If a block signer signs multiple blocks at the same height, participants can use the inconsistent signatures to construct *fraud proofs* to warn other nodes or provide evidence for enforcement out-of-band.\n\n## 7. Scalability\n\nThe Chain Protocol makes several design decisions to support scalable transaction processing.\n\nFirst, the UTXO model makes it possible to verify transactions in parallel — potentially on separate servers. This makes scaling easier, compared to a “programmable state-machine” model, such as Ethereum’s, which requires each transaction to be executed in sequence. Programs do not calculate or alter state — rather, each transaction fully specifies a state transition, and each program checks whether the specified state transition is valid. As a result, the program for each input can be validated independently. Similarly, each transaction in a block can be validated in parallel (except that UTXOs must be created before they are spent, and each UTXO can be spent only once).\n\nSecond, the protocol does not require that participants keep track of the entire blockchain state. Participants only need to remember the hashes of unspent outputs, since transactions include the details (such as asset ID, amount, and control program), which can be verified against the hash. This trades bandwidth for memory, making it easier for participants to avoid costly disk accesses.\n\nFinally, compact proofs allow users to validate only the parts of the blockchain with which they are concerned without processing and validating all transactions, as long as they trust a quorum of block signers. An example of such proof is a Merkle path that proves that a given transaction or unspent output is included in a particular block. For additional security, clients could delegate the task of monitoring the entire blockchain to a server they trust.\n\n## 8. Extensibility\n\nThe Chain Protocol is extensible to allow fixing bugs and adding new security features while keeping all network nodes compatible with the blockchain. Changes can be applied using a “soft fork” method that preserves both backward and forward compatibility, allowing outdated clients to continue validating the blockchain. \n\nBlocks, assets, transactions, and programs each have version numbers and extensible fields. New versions can fix security flaws or add features — such as adding an instruction to the VM, changing the VM completely, or introducing an entirely new accounting system and a new category of assets.\n\nIf a client does not recognize a version number for a field in a block or transaction, it treats it as “unknown” and assumes that it is valid. This allows outdated clients to continue validating the parts of the blockchain that use old rules while ignoring the parts using new rules, deferring to block signers for their validation. Some participants may choose to stop performing sensitive operations — such as signing transactions or accepting payments — if they detect an unknown version number and wish to upgrade the software before continuing operation.\n\n## 9. Interoperability\n\nThe Chain Protocol can power multiple blockchain networks simultaneously. While these networks use the same protocol, their asset IDs are anchored to the initial blocks of these networks, making them globally unique.\n\nCross-ledger interaction is possible using cross-chain swap protocols, such as [Interledger](https://interledger.org/interledger.pdf). For example, the CVM is capable of supporting the SHA-256, PREIMAGE, PREFIX, THRESHOLD, and ED25519 feature suites of [Crypto-Conditions](https://github.com/interledger/rfcs/blob/master/0002-crypto-conditions/0002-crypto-conditions.md). These protocols allow participants on different Chain blockchains to interact with each other, as well as with participants on different types of blockchains and ledgers.\n\nThe Chain Protocol uses standard cryptographic tools such as SHA-2 and SHA-3 hash functions and the secure signature algorithm Ed25519.\n\n## 10. Conclusion\n\nThis paper has presented the Chain Protocol: a design for a shared, multi-asset, cryptographic ledger that can underpin modern financial networks. The protocol is designed for large scale applications, offering a scalable and extensible data model with a flexible yet robust programming environment.\n\nThe Chain Protocol allows participants to issue and control assets programmatically using digital signatures and custom rules. Transactions issuing and controlling assets are collected into a cryptographic chain of blocks forming a shared ledger. Block signers follow a [federated consensus protocol](#5-consensus) to replicate a single copy of the ledger across all nodes to prevent reversal of transactions and double-spending. \n\nChain Core is software that implements the Chain Protocol. Using Chain Core, organizations can launch a blockchain network in their market or connect to a growing list of networks that are enabling this new medium for assets – one that reduces the time, cost, and complexity of asset transfer and custody in the financial system and can give rise to new products and services that are difficult or impossible to realize on traditional infrastructure.\n\n## Further reading\n\n* [Federated Consensus](federated-consensus.md)\n* [Blockchain Programs](blockchain-programs.md)\n* [Blockchain Extensibility](blockchain-extensibility.md)\n* [Data Model Specification](../specifications/data.md)\n* [Virtual Machine Specification](../specifications/vm1.md)\n* [Key Derivation Specification](../specifications/chainkd.md)\n* [Chain Core Documentation](../../)\n\n"},{"Url":"/docs/1.1/protocol/specifications/chainkd.md","Body":"# Chain Key Derivation\n\n* [Introduction](#introduction)\n* [Definitions](#definitions)\n* [Security](#security)\n* [Algorithms](#algorithms)\n  * [Generate root key](#generate-root-key)\n  * [Generate extended public key](#generate-extended-public-key)\n  * [Derive hardened extended private key](#derive-hardened-extended-private-key)\n  * [Derive non-hardened extended private key](#derive-non-hardened-extended-private-key)\n  * [Derive non-hardened extended public key](#derive-non-hardened-extended-public-key)\n  * [Sign](#sign)\n  * [Verify signature](#verify-signature)\n  * [Generate secret scalar](#generate-secret-scalar)\n  * [Encode public key](#encode-public-key)\n* [FAQ](#faq)\n* [Test vectors](#test-vectors)\n* [References](#references)\n\n## Introduction\n\nThis is a simple deterministic key derivation scheme consisting of two instances using different hash functions:\n\n**ChainKD2:** the hash function is SHA2-512 (as in EdDSA specification).\n\n**ChainKD3:** the hash function is SHA3-512.\n\nFeatures:\n\n1. Scheme is fully deterministic and allows producing complex hierarchies of keys from a single high-entropy seed.\n2. Derive private keys from extended private keys using “hardened derivation”.\n3. Derive public keys independently from private keys using “non-hardened derivation”.\n4. Hardened and non-hardened public keys and signatures are compatible with [EdDSA](https://tools.ietf.org/html/draft-irtf-cfrg-eddsa-08) specification.\n5. Variable-length string selectors instead of fixed-length integer indexes.\n6. Short 64-byte extended public and private keys without special encoding.\n7. No metadata: an extended key carries only an additional 32-byte salt to avoid having the derivation function depend only on the key itself.\n8. Privacy: extended key does not reveal neither its place in the hierarchy, nor the manner of derivation (hardened or non-hardened).\n\n\n## Definitions\n\n**Hash512** is a cryptographic hash function with 512-bit output (either SHA2-512 or SHA3-512).\n\n**Selector** is a variable-length byte string that can be used as a derivation index.\n\n**Secret scalar** is 32-byte string representing a 256-bit integer using little-endian convention.\n\n**Public key** is a 32-byte string representing a point on elliptic curve Ed25519 [CFRG].\n\n**Extended private key** (aka “xprv”) is a 64-byte string representing a key that can be used for deriving *child extended private and public keys*.\n\n**Extended public key** (aka “xpub”) is a 64-byte string representing a key that can be used for deriving *child extended public keys*.\n\n**LEB128** is a [Little Endian Base-128](https://developers.google.com/protocol-buffers/docs/encoding#varints) encoding for unsigned integers used for length-prefixing of a variable-length *selector* string.\n\n\n## Security\n\nKnowledge of the seed or the root extended private key:\n\n1. Allows deriving hardened extended private key.\n2. Allows deriving non-hardened extended private key.\n3. Allows signing messages with the root key.\n\nKnowledge of an extended private key:\n\n1. Allows deriving hardened extended private key.\n2. Allows deriving non-hardened extended private key.\n3. Allows signing messages with that key.\n\nKnowledge of an extended public key:\n\n1. Allows deriving non-hardened public keys.\n2. Does not allow determining if it is derived in a hardened or non-hardened way.\n3. Does not allow determining if another extended public key is a sibling of the key.\n4. Does not allow signing\n5. Does not allow deriving private keys.\n6. Does not allow deriving hardened public keys.\n\nKnowledge of a parent extended public key and one of non-hardened derived extended private keys:\n\n1. Allows extracting parent private key: `s = (s’ - f) mod L` where `f` is derived from the parent `xpub` and `s’` is extracted from the child `xprv’`.\n\n\n\n## Algorithms\n\n### Generate root key\n\n**Input:** `seed`, a seed byte sequence (variable-length, should contain at least 256 bits of entropy).\n\n**Output:** `xprv`, a root extended private key.\n\n1. Calculate `I = Hash512(\"Chain seed\" || seed)`.\n2. Split `I` in two parts: 32-byte `buf` and 32-byte `salt`.\n3. [Generate secret scalar](#generate-secret-scalar) `s` from buffer `buf`.\n4. Let `privkey` be a 32-byte string encoding scalar `s` using little-endian convention.\n5. Return `xprv = privkey || salt` (64 bytes).\n\n\n\n### Generate extended public key\n\n**Input:** `xprv`, an extended private key.\n\n**Output:** `xpub`, an extended public key.\n\n1. Split `xprv` in two parts: 32-byte `privkey` and 32-byte `salt`.\n2. Interpret `privkey` as a little-endian 256-bit integer `s`.\n3. Perform a fixed-base scalar multiplication `P = s*B` where `B` is a base point of Ed25519.\n4. [Encode](#encode-public-key) point `P` as `pubkey`.\n5. Return extended public key `xpub = pubkey || salt` (64 bytes).\n\n\n### Derive hardened extended private key\n\n**Inputs:**\n\n1. `xprv`, an extended private key.\n2. `selector`, a variable-length byte sequence used as a derivation key.\n\n**Output:** `xprv’`, the derived extended public key.\n\n1. Split `xprv` in two parts: 32-byte `privkey` and 32-byte `salt`.\n2. Let `len` be the length of `selector` in bytes.\n3. Let `I = Hash512(0x00 || privkey || salt || LEB128(len) || selector)`.\n4. Split `I` in two parts: 32-byte `buf` and 32-byte `salt’`.\n5. [Generate secret scalar](#generate-secret-scalar) `s’` from buffer `buf`.\n6. Let `privkey’` be a 32-byte string encoding scalar `s’` using little-endian convention.\n7. Return `xprv’ = privkey’ || salt’`.\n\n\n### Derive non-hardened extended private key\n\n**Inputs:**\n\n1. `xprv`, an extended private key.\n2. `selector`, a variable-length byte sequence used as a derivation key.\n\n**Output:** `xprv’`, the derived extended public key.\n\n1. Split `xprv` in two parts: 32-byte `privkey` and 32-byte `salt`.\n2. Let `s` be the scalar decoded from `privkey` using little-endian notation.\n3. Perform a fixed-base scalar multiplication `P = s*B` where `B` is a base point of Ed25519.\n4. [Encode](#encode-public-key) point `P` as `pubkey`.\n5. Let `len` be the length of `selector` in bytes.\n6. Let `I = Hash512(0x01 || pubkey || salt || LEB128(len) || selector)`.\n7. Split `I` in two parts: 32-byte `fbuffer` and 32-byte `salt’`.\n8. [Generate secret scalar](#generate-secret-scalar) `f` from buffer `fbuffer`.\n9. Compute derived secret scalar `s’ = (f + s) mod L` (where `L` is the group order of `B`).\n10. Let `privkey’` be a 32-byte string encoding scalar `s’` using little-endian convention.\n11. Return `xprv’ = privkey’ || salt’`.\n\n\n### Derive non-hardened extended public key\n\n**Inputs:**\n\n1. `xpub`, an extended public key.\n2. `selector`, a variable-length byte sequence used as a derivation key.\n\n**Output:** `xpub’`, the derived extended public key.\n\n1. Split `xpub` in two parts: 32-byte `pubkey` and 32-byte `salt`.\n2. Let `len` be the length of `selector` in bytes.\n3. Let `I = Hash512(0x01 || pubkey || salt || LEB128(len) || selector)`.\n4. Split `I` in two parts: 32-byte `fbuffer` and 32-byte `salt’`.\n5. [Generate secret scalar](#generate-secret-scalar) `f` from buffer `fbuffer`.\n6. Perform a fixed-base scalar multiplication `F = f*B` where `B` is a base point of Ed25519.\n7. Decode point `P` from `pubkey` according to EdDSA.\n8. Perform point addition `P’ = P + F`.\n9. [Encode](#encode-public-key) point `P’` as `pubkey’`.\n10. Return `xpub’ = pubkey’ || salt’`.\n\n\n### Sign\n\n**Inputs:**\n\n1. `xprv`, an extended private key.\n2. `message`, a variable-length byte sequence representing a message to be signed.\n\n**Output:** `(R,S)`, 64-byte string representing an EdDSA signature.\n\n1. Split `xprv` in two parts: 32-byte `privkey` and 32-byte `salt`.\n2. Let `s` be the scalar decoded from `privkey` using little-endian notation.\n3. Let `h = Hash512(0x02 || privkey || salt)`.\n4. Let `prefix` be the first half of `h`: `prefix = h[0:32]`.\n5. Perform a fixed-base scalar multiplication `P = s*B` where `B` is a base point of Ed25519.\n6. [Encode](#encode-public-key) point `P` as `pubkey`.\n7. Compute `Hash512(prefix || message)`. Interpret the 64-byte digest as a little-endian integer `r`.\n8. Compute the point `r*B`.  For efficiency, do this by first reducing `r` modulo `L`, the group order of `B`. \n9. Let the string `R` be the encoding of the point `r*B`.\n10. Compute `Hash512(R || pubkey || message)`, and interpret the 64-byte digest as a little-endian integer `k`.\n11. Compute `S = (r + k * s) mod L`. For efficiency, again reduce `k` modulo `L` first.\n12. Concatenate `R` (32 bytes) and the little-endian encoding of `S` (32 bytes, three most significant bits of the final byte are always zero).\n13. Return `(R,S)` (64 bytes).\n\n\n### Verify signature\n\n**Inputs:**\n\n1. `xpub`, an extended public key.\n2. `message`, a variable-length byte sequence representing a signed message.\n3. `(R,S)`, a 64-byte signature.\n\n**Output:** boolean value indicating if the signature is valid or not.\n\n1. Extract public key `pubkey` as first 32 bytes of `xpub`.\n2. Verify the EdDSA signature `(R,S)` over `message` using `pubkey` per [CFRG](https://tools.ietf.org/html/draft-irtf-cfrg-eddsa-08) substituting SHA512 hash function with Hash512 (which equals SHA512 in ChainKD-SHA2 instance thus retaining full compatibility with EdDSA verification procedure).\n\n\n### Generate secret scalar\n\n**Input:** `buffer`, a 32-byte string.\n\n**Output:** `s`, a 256-bit integer.\n\n1. Prune the buffer `buffer`: the lowest 3 bits of the first byte are cleared, the highest bit of the last byte is cleared, and the second highest bit of the last byte is set.\n2. Interpret the buffer as the little-endian integer, forming a secret scalar `s`.\n3. Return `s`.\n\n\n### Encode public key\n\n**Input:** `P`, a Ed25519 curve point.\n\n**Output:** `pubkey`, a 32-byte string representing a point on Ed25519 curve.\n\n1. First encode the y coordinate (in the range 0 \u003c= y \u003c p) as a little-endian string of 32 bytes. The most significant bit of the final byte is always zero.\n2. To form the encoding of the point `P`, copy the least significant bit of the x coordinate to the most significant bit of the final byte. \n3. Return the resulting 32-byte string as `pubkey`.\n\n\n## FAQ\n\n**Can I derive hardened keys from non-hardened ones?**\n\nYes. The derivation method only affects relationship between the key and its parent, but does not affect how other keys are derived from that key.\nNote that secrecy of all derived private keys (both hardened and non-hardened, at all levels) from a non-hardened key depends on keeping either the parent extended public key secret, or all non-hardened sibling keys secret.\n\n**BIP32 is fully compatible with ECDSA. Why this scheme does not follow standard EdDSA?**\n\nEdDSA treats private key not as a raw scalar (which is what ECDSA does), but as a buffer being hashed and then split into a scalar and a `prefix` material for the nonce. This hashing creates a non-linear relationship that is impossible to map to curve points that only support linear operations for non-hardened derivation. This scheme therefore deviates from EdDSA and encodes a non-hardened private key as a scalar directly, without its hash preimage. For consistency, the hardened key also stores only the scalar, not its preimage. At the same time, signature verification is fully compatible with EdDSA for both hardened and non-hardened public keys.\n\n**Is it safe to derive signature nonce directly from the secret scalar?**\n\nWe believe the scheme is equivalent to RFC6979 that derives the nonce by hashing the secret scalar. As an extra safety measure, the secret scalar is concatenated with the `salt` (which is not considered secret in this scheme) in order to make derivation function not dependent solely on the key.\n\n\n\n## Test vectors\n\nAll values use hexadecimal encoding.\n\n### ChainKD2 test vector 1\n\n    Master:\n        seed:     010203\n        xprv:     e892d064d9658a3405e97f5dfaefab9b3a08a2341cdeb427ae7d6f2eb96b3952967a0ec62a845bccb318935c012f6900b330d2831f6407eb0dd7df1082c2e22b\n        xpub:     254a6f2c96f84aabaef5f2922026360c03d29ce3eb3de739c8c243053e1a3cbe967a0ec62a845bccb318935c012f6900b330d2831f6407eb0dd7df1082c2e22b\n            \n    Master/010203(H):\n        selector: 010203\n        xprv:     209f3ae66a0ef7bef75497fd214b821133d44ff2f8eb80b50b738b3e9ec67f5f2b037c3ec24d503128664eb2e773c0c96b6e102faf898568177491188180bd4f\n        xpub:     e844c655dfced878e489d42c3ea26b9877e1c7f8c2dbad679525f8056fa5cfba2b037c3ec24d503128664eb2e773c0c96b6e102faf898568177491188180bd4f\n        \n    Master/010203(N):\n        selector: 010203\n        xprv:     3e42fb09bd0b6360e51c9b7ab70d1010e53eca59be378764535b0143b3a0ca0e4ee9f0b88260285f0b93b6b115e8e978351e4f1491d622821d78cde389c44e28\n        xpub:     061155751a79a3d7dda52a7ea9980bdb1d06bf793be6b78cc8f5724541d5b1c64ee9f0b88260285f0b93b6b115e8e978351e4f1491d622821d78cde389c44e28\n    \n    Master/010203(H)/\"\"(N):\n        selector: (empty string)\n        xprv:     97ae121e2d8b7ca893406edd6d170f260c1d8282eceee975eeb506af2dfbc808dd979ffd561bd9e60cced900e878de425868e0c70b944f7421816fafb6e3b224\n        xpub:     3eca1608be5fa17867bddccd2b99eef344097c6ba17f19b9f54604c77f196813dd979ffd561bd9e60cced900e878de425868e0c70b944f7421816fafb6e3b224\n        \n    Master/010203(N)/\"\"(H):\n        selector: (empty string)\n        xprv:     981da97280c994c3c0f5fe1990a263bbaf5493576c98102e9a1dd635e728c65eff84c4ba93c29e42cc6f89981b6bd903c3b78f03fa6e9d694a123abcfe024357\n        xpub:     bc6a0009d5249872e94e1058a95f226560ab9c218665e18f34b168dd45b70b41ff84c4ba93c29e42cc6f89981b6bd903c3b78f03fa6e9d694a123abcfe024357\n    \n    Master/010203(N)/\"\"(N):\n        selector: (empty string)\n        xprv:     604e33854c66f785e05d36d774b0b3dbe1286526ab8ded41f0cbfe5dfbf68a0a6bd8b033689d38055b58baff8eccceb623871e9c23be82606e903f2d71304208\n        xpub:     3f61a6f6e543ffaebf68c9a0c0d64498e03d048d658f8f06bf9a9b6b3ddcb16a6bd8b033689d38055b58baff8eccceb623871e9c23be82606e903f2d71304208\n\n\n### ChainKD2 test vector 2\n\n    Master:\n        seed:     fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542\n        xprv:     f06907ad9298c685a4fd250538605bea7fa387388954e15a90b337c4ac889e467730a16f62d5159c3a0d390a0e4639be86c766ad779c810458adb532164a9211\n        xpub:     55b33d123033131c8642ef736b4b1bf9430f52dbcb3b7d6bbf721040cf504bd57730a16f62d5159c3a0d390a0e4639be86c766ad779c810458adb532164a9211\n        \n    Master/0(N):\n        selector: 00\n        xprv:     2cb4d70521f62eeedb0e2d68a6843431800b9271c83a49a9ba598f85b2229e0446fb34a28f8cc239bfc700c9002aca2d5f2affff27955de947a1b4d3e232b229\n        xpub:     06820e5ee702c54efea0aeea41f89dab5dd82d0797bb79689dee1ebc1ac00a1646fb34a28f8cc239bfc700c9002aca2d5f2affff27955de947a1b4d3e232b229\n    \n    Master/0(N)/2147483647(H):\n        selector: ffffff7f\n        xprv:     98c4c05731fed5f944345bdec859403d26cf8825f358740db2c107f720a8d2704f785675bea750ef52c78e56d973b4d0638ce5b3e76a8957c2d2c45dafb87c95\n        xpub:     a30818e3b50163b0f346eba0dfef70e66041b7de97273c1b8cb0804d4645f1d44f785675bea750ef52c78e56d973b4d0638ce5b3e76a8957c2d2c45dafb87c95\n        \n    Master/0(N)/2147483647(H)/1(N):\n        selector: 01\n        xprv:     67f882c251a541d68460934283f78c38eb94b1d1b85ca64ebbf860bdd63ded0b811476e6e32936d8d6164d9f28ec7a3278b24758433ebe7d74e0db8a56930aaf\n        xpub:     437835c60770e2890bf622df3ee66c07ba8628ed87591fbe0907607888435178811476e6e32936d8d6164d9f28ec7a3278b24758433ebe7d74e0db8a56930aaf\n    \n    Master/0(N)/2147483647(H)/1(N)/2147483646(H):\n        selector: feffff7f\n        xprv:     08cb5d261af0d47b4dadfe4b21b71decc844249892644a3f892d79eb38a3dc4db1dcbf10a891e1c3c1e49e6d6d5bda12049501ddb8121a52d7ed5c6658c71bc0\n        xpub:     80923c7d5bbf37a269c862764b14a53b751a9cb786bce7c3d463d899806014fdb1dcbf10a891e1c3c1e49e6d6d5bda12049501ddb8121a52d7ed5c6658c71bc0\n        \n    Master/0(N)/2147483647(H)/1(N)/2147483646(H)/2(N):\n        selector: 02\n        xprv:     6e9f9333156b5bb074456fdf75a2acb3d67a0b1dce044cf00efd331087719807574d3c263a60a4e40425032a89dd36bbf02fb98ccb9495bceaea1d1ad3d91973\n        xpub:     cd4c4b318b65e0e85b6f00a0ed0c4591c96c6d89d128b0cc90497d39150c2428574d3c263a60a4e40425032a89dd36bbf02fb98ccb9495bceaea1d1ad3d91973\n\n\n## References\n\n1. [CFRG](https://tools.ietf.org/html/draft-irtf-cfrg-eddsa-08)\n2. [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)\n3. [LEB-128](https://developers.google.com/protocol-buffers/docs/encoding#varints)\n"},{"Url":"/docs/1.1/protocol/specifications/consensus.md","Body":"# Federated Consensus Protocol\n\n* [Introduction](#introduction)\n* [Generator state](#generator-state)\n* [Signer state](#signer-state)\n* [Algorithms](#algorithms)\n  * [Initialize generator](#initialize-generator)\n  * [Join new network](#join-new-network)\n  * [Accept transaction](#accept-transaction)\n  * [Generate block](#generate-block)\n  * [Sign block](#sign-block)\n  * [Make initial block](#make-initial-block)\n  * [Make block](#make-block)\n\n## Introduction\n\nThe present version of the protocol uses federated consensus mechanism based on a single *block generator* (elected out of band) and a group of *block signers*.\n\n## Generator state\n\nThe block generator maintains, in addition to its [node state](validation.md#node-state):\n\n* A *pending transaction pool*, or simply a *transaction pool*, that is a set of transactions used to construct each block it generates. Transactions can be added to and removed from the transaction pool.\n* The *last generated block*, to avoid proposing more than one block at the same height.\n* The *generator’s signing key*. All signers recognize the corresponding *verification key* and verify generated blocks using this key before validating and co-signing the block themselves. This key can be replaced by an operator after an out-of-band agreement with other nodes.\n* The *maximum issuance window* (in milliseconds), configurable parameter that limits the maximum time field of a transaction containing issuances. This relieves nodes of having to store transactions in the [issuance memory](validation.md#node-state) indefinitely.\n\nNote that the generator can also be a signer, and if so, it also has [signer state](#signer-state).\n\n\n## Signer state\n\nEach block signer stores, in addition to its node state:\n\n* The *last signed block*. This last signed block can be replaced with a new block in an algorithm below.\n* The *generator’s verification key* used to authenticate the block produced by the generator before validating and signing it.\n* The *signing key* required by the [consensus program](data.md#consensus-program) in the last signed block. The signing key can be replaced by an operator after an out-of-band agreement with other nodes (by updating the consensus program in one of the future blocks).\n\n\n\n## Algorithms\n\nThe algorithms below describe the rules for updating a node’s state. Some of the algorithms are used only by other algorithms defined here. Others are entry points — they are triggered by network activity or user input.\n\nEntry Point                                              | When used\n---------------------------------------------------------|----------------------------------\n[Initialize generator](#initialize-generator)            | A new network is being set up.\n[Join new network](#join-new-network)                    | A new network is being set up.\n[Accept transaction](#accept-transaction)                | Generator receives a transaction.\n[Generate block](#generate-block)                        | Generator produces blocks of transactions at regular intervals.\n[Sign block](#sign-block)                                | Block signers co-sign a block produced by a block generator.\n\n\n### Initialize generator\n\n**Input:** current time.\n\n**Outputs:** none.\n\n**Affects:**\n\n1. current blockchain state,\n2. transaction pool.\n\n**Algorithm:**\n\n1. Create a [consensus program](data.md#consensus-program). The contents of this program are a matter of local policy.\n2. [Make an initial block](#make-initial-block) with the current time and the created consensus program.\n3. Allocate an empty unspent output set.\n4. The initial block and these empty sets together constitute the *initial state*.\n5. Assign the initial state to the current blockchain state.\n6. Create an empty transaction pool.\n\n### Join new network\n\nA new node starts here when joining a new network (with height = 1).\n\n**Input:** block.\n\n**Output:** true or false.\n\n**Affects:** current blockchain state.\n\n**Algorithm:**\n\n1. [Make an initial block](#make-initial-block) with the input block’s timestamp and [consensus program](data.md#consensus-program).\n2. The created block must equal the input block; if not, halt and return false.\n3. Allocate an empty unspent output set.\n4. The initial block and these empty sets together constitute the *initial state*.\n5. Assign the initial state to the current blockchain state.\n6. Return true.\n\n\n### Accept transaction\n\nThe block generator collects transactions to include in each block it generates. When another node or client has prepared a transaction, it sends the transaction to the generator, which follows this algorithm.\n\n**Inputs:**\n\n1. transaction,\n2. current time,\n3. current blockchain state.\n\n**Output:** true or false.\n\n**Affects:** transaction pool.\n\n**Algorithm:**\n\n1. [Validate the transaction](validation.md#validate-transaction) with respect to the current blockchain state, but using system timestamp instead of the latest block timestamp; if invalid, halt and return false.\n2. If the transaction contains at least one [issuance input with asset version 1](data.md#asset-version-1-issuance-commitment) and a non-empty nonce:\n    1. Test that transaction minimum timestamp plus the [maximum issuance window](#generator-state) is greater or equal to the transaction maximum timestamp; if not, halt and return false.\n3. Add the transaction to the transaction pool.\n4. Return true.\n\n### Generate block\n\nThe generator runs this periodically or when the transaction pool reaches a certain size, according to its local policy. It must broadcast the resulting fully-signed block to all other nodes.\n\n**Inputs:**\n\n1. current blockchain state,\n2. transaction pool,\n3. current time,       \n4. last generated block.\n\n**Output:** block.\n\n**Affects:**\n\n1. transaction pool,\n2. last generated block.\n\n**Algorithm:**\n\n1. If the last generated block exists with height greater than the current blockchain state, halt and return it.\n2. [Make Block](#make-block) with the current blockchain state, the transaction pool, and the current time.\n3. For each block signer:\n    1. Send the block and the generator’s [signature](data.md#signature) to the signer [asking the signer to sign the block](#sign-block)\n    2. Receive a [signature](data.md#signature) from the signer.\n    3. Add the signature to the [block witness](data.md#block-witness) program arguments.\n4. Replace the last generated block with the new block.\n5. [Apply the block](validation.md#apply-block) to the current blockchain state, yielding a new state.\n6. Let T be an empty list of transactions.\n7. For each transaction in the transaction pool:\n    1. [Validate the transaction](validation.md#validate-transaction) with respect to the new state; if invalid, discard it and continue to the next.\n    2. Add the transaction to T.\n8. Replace the transaction pool with T.\n9. Return the block.\n\nNote: steps 6-8 are necessary because the transaction pool is not necessarily fully consumed by the new block.\nSee also the note in the [Make Block](#make-block) algorithm.\n\n### Sign block\n\n\n**Inputs:**\n\n1. block,\n2. generator’s signature,\n3. current blockchain state,\n4. last signed block,\n5. signing key,\n6. system time\n\n**Output:** [signature](data.md#signature) or nothing.\n\n**Affects:** last signed block.\n\n**Algorithm:**\n\n1. Test that the height of the input block is strictly greater than the height of the last signed block; if not, halt and return nothing.\n2. Verify the generator’s signature using the generator’s verification key in the current blockchain state. If the signature is invalid, halt and return nothing.\n3. [Validate the block](validation.md#validate-block) with respect to the current blockchain state; if invalid, halt and return nothing.\n4. Check that the block’s [consensus program](data.md#consensus-program) equals the consensus program in the last signed block; if not, halt and return nothing.\n5. Ensure that reserved values and versions are unused. If any of the following conditions are not satisfied, halt and return nothing:\n    1. The block version must equal 1.\n    2. For every transaction in the block:\n        1. Transaction version must equal 1.\n        2. [Transaction common witness](data.md#transaction-common-witness) string must be empty.\n        3. Every [input witness](data.md#transaction-input-witness) must contain only the fields defined in this version of the protocol (no additional data included).\n        4. Every [output witness](data.md#transaction-output-witness) must be empty.\n6. Check that the block's timestamp is less than 2 minutes after the system time. If it is not, halt and return nothing.\n7. Compute the [block hash](data.md#block-id) for the block.\n8. Sign the hash with the signing key, yielding a [signature](data.md#signature).\n9. Replace the last signed block with the input block.\n10. Return the signature.\n\n### Make initial block\n\n**Inputs:**\n\n1. consensus program,\n2. time.\n\n**Output**: a block.\n\n**Algorithm:**\n\n1. Return a block with the following values:\n    1. Version: 1.\n    2. Height: 1.\n    3. Previous block ID: 32 zero bytes.\n    4. Timestamp: the input time.\n    5. [Block commitment](data.md#block-commitment):\n        1. Transactions merkle root: [merkle binary tree hash](data.md#merkle-binary-tree) of the empty list.\n        2. Assets merkle root: [merkle patricia tree hash](data.md#merkle-patricia-tree) of the empty list.\n        3. Consensus program: the input consensus program.\n    6. [Block witness](data.md#block-witness): 0x00 (the empty string).\n    7. Transaction count: 0.\n    8. Transactions: none.\n\n\n### Make block\n\n**Inputs:**\n\n1. blockchain state,\n2. set of transactions,\n3. time.\n\n**Output:** block.\n\n**Algorithm:**\n\n1. Let S be the blockchain state.\n2. Let T be an empty list of transactions.\n3. For each transaction in the set:\n    1. Validate the transaction against S; if it fails, discard the transaction and continue to the next one.\n    2. If local policy prohibits the transaction, discard it and continue to the next one.\n    3. Add the transaction to T.\n    4. Apply the transaction to S, yielding S′.\n    5. Replace S with S′.\n4. Return a block with the following values:\n    1. Version: 1.\n    2. Height: 1 + the height of the blockchain state.\n    3. Previous block ID: the hash of the blockchain state’s block.\n    4. Timestamp: the input time, or the timestamp of the blockchain state increased by 1 millisecond, whichever is greater: `time[n] = max(input_time, time[n-1]+1)`.\n    5. [Block commitment](data.md#block-commitment):\n        1. [Transactions merkle root](data.md#transactions-merkle-root): [merkle binary tree hash](data.md#merkle-binary-tree) of [transaction IDs](data.md#transaction-id) in T.\n        2. [Assets merkle root](data.md#assets-merkle-root): [merkle patricia tree hash](data.md#merkle-patricia-tree) of S.\n        3. Consensus program: the input consensus program.\n    6. [Block witness](data.md#block-witness): 0x01 0x00 (an empty list of program arguments).\n    7. Transaction count: the number of transactions in T.\n    8. Transactions: T.\n\nNote: “local policy” in this section gives the generator the ability to exclude\na transaction for any reason. For example, it might apply a fixed size limit\nto every block, and stop adding transactions once it reaches that size.\n\n\n\n\n"},{"Url":"/docs/1.1/protocol/specifications/data.md","Body":"# Data Model Specification\n\n* [Introduction](#introduction)\n* [Definitions](#definitions)\n  * [Varint](#varint)\n  * [Varint31](#varint31)\n  * [Varint63](#varint63)\n  * [Varstring31](#varstring31)\n  * [Extensible string](#extensible-string)\n  * [Public Key](#public-key)\n  * [Signature](#signature)\n  * [SHA3](#sha3)\n  * [Optional Hash](#optional-hash)\n  * [Block](#block)\n  * [Block Serialization Flags](#block-serialization-flags)\n  * [Block Header](#block-header)\n  * [Block Commitment](#block-commitment)\n  * [Block Witness](#block-witness)\n  * [Block ID](#block-id)\n  * [Transaction](#transaction)\n  * [Transaction Common Fields](#transaction-common-fields)\n  * [Transaction Common Witness](#transaction-common-witness)\n  * [Transaction Input](#transaction-input)\n  * [Transaction Input Commitment](#transaction-input-commitment)\n  * [Issuance Hash](#issuance-hash)\n  * [Transaction Input Witness](#transaction-input-witness)\n  * [Output ID](#output-id)\n  * [Transaction Output](#transaction-output)\n  * [Transaction Output Commitment](#transaction-output-commitment)\n  * [Transaction Output Witness](#transaction-output-witness)\n  * [Transaction Serialization Flags](#transaction-serialization-flags)\n  * [Transaction ID](#transaction-id)\n  * [Transaction Signature Hash](#transaction-signature-hash)\n  * [Program](#program)\n  * [VM Version](#vm-version)\n  * [Consensus Program](#consensus-program)\n  * [Control Program](#control-program)\n  * [Issuance Program](#issuance-program)\n  * [Program Arguments](#program-arguments)\n  * [Asset Version](#asset-version)\n  * [Asset ID](#asset-id)\n  * [Asset Definition](#asset-definition)\n  * [Retired Asset](#retired-asset)\n  * [Transactions Merkle Root](#transactions-merkle-root)\n  * [Assets Merkle Root](#assets-merkle-root)\n  * [Merkle Root](#merkle-root)\n  * [Merkle Binary Tree](#merkle-binary-tree)\n  * [Merkle Patricia Tree](#merkle-patricia-tree)\n* [References](#references)\n\n\n## Introduction\n\nThis document describes the serialization format for the blockchain data structures used in the Chain Protocol.\n\n## Definitions\n\n### Varint\n\n[Little Endian Base 128](https://developers.google.com/protocol-buffers/docs/encoding) encoding for unsigned integers typically used to specify length prefixes for arrays and strings. Values in range [0, 127] are encoded in one byte. Larger values use two or more bytes.\n\n### Varint31\n\nA varint with a maximum allowed value of 0x7fffffff (2\u003csup\u003e31\u003c/sup\u003e – 1) and a minimum of 0. A varint31 fits into a signed 32-bit integer.\n\n### Varint63\n\nA varint with a maximum allowed value of 0x7fffffffffffffff (2\u003csup\u003e63\u003c/sup\u003e – 1) and a minimum of 0. A varint63 fits into a signed 64-bit integer.\n\n### Varstring31\n\nA binary string with a varint31 prefix specifying its length in bytes. So the empty string is encoded as a single byte 0x00, a one-byte string is encoded with two bytes 0x01 0xNN, a two-byte string is 0x02 0xNN 0xMM, etc. The maximum allowed length of the underlying string is 0x7fffffff (2\u003csup\u003e31\u003c/sup\u003e – 1).\n\n### Extensible string\n\nA varstring31 whose content is the concatenation of other encoded data structures, possibly including other varstring31s. Used for values that future versions of the protocol might wish to extend without breaking older clients. Older clients can consume the complete “outer” varstring31 and parse out the subparts they understand while ignoring the suffix that they don’t.\n\n### Public Key\n\nIn this document, a *public key* is the 32-byte binary encoding\nof an Ed25519 (EdDSA) public key, as defined in [CFRG1](https://tools.ietf.org/html/draft-irtf-cfrg-eddsa-05).\n\n### Signature\n\nIn this document, a *signature* is the 64-byte binary encoding\nof an Ed25519 (EdDSA) signature, as defined in [CFRG1](https://tools.ietf.org/html/draft-irtf-cfrg-eddsa-05).\n\n\n### SHA3\n\n*SHA3* refers to the SHA3-256 function as defined in [FIPS202](https://dx.doi.org/10.6028/NIST.FIPS.202) with a fixed-length 32-byte output.\n\nThis hash function is used throughout all data structures and algorithms in this spec,\nwith the exception of SHA-512 (see [FIPS180](http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf)) used internally as function H inside Ed25519 (see [CFRG1](https://tools.ietf.org/html/draft-irtf-cfrg-eddsa-05)).\n\n### Optional Hash\n\nAn *optional hash* is a function that transforms a variable-length binary string to another variable-length binary string using SHA3-256 with a special case for an empty string: it is hashed to an empty string.\n\nInput String      | Optional Hash               | Varstring31-encoded Optional Hash\n------------------|-----------------------------|----------------------------------------\nEmpty string      | Empty string                | One-byte string: 0x00\nNon-empty string  | 32-byte result of SHA3-256  | 33-byte string; first byte equals 0x20\n\n\n\n### Block\n\nField               | Type              | Description\n--------------------|-------------------|----------------------------------------------------------\nSerialization Flags | byte              | See [Block Serialization Flags](#block-serialization-flags).\nVersion             | varint63          | Block version, equals 1.\nHeight              | varint63          | Block serial number.\nPrevious Block ID   | sha3-256          | [Hash](#block-id) of the previous block or all-zero string.\nTimestamp           | varint63          | Time of the block in milliseconds since 00:00:00 UTC Jan 1, 1970.\nBlock Commitment    | Extensible string | Extensible commitment string. See [Block Commitment](#block-commitment).\nBlock Witness       | Extensible string | Extensible witness string. See [Block Witness](#block-witness).\nTransaction Count   | varint31          | Number of transactions that follow.\nTransactions        | [Transaction]     | List of individual [transactions](#transaction).\n\n\n\n### Block Serialization Flags\n\nSerialization flags control what data is in a given block message and how it is encoded. Unused values are reserved for future expansion. Implementations must reject messages using unsupported serialization values.\n\nThe **first (least significant) bit** indicates whether the block includes [witness](#block-witness) data. If this bit is zero, the witness data is omitted entirely.\n\nThe **second bit** indicates whether the block includes [transaction](#transaction) data. If this bit is zero, the transaction count and transactions are omitted entirely.\n\nNon-zero **higher bits** and value 0x02 are reserved for future use.\n\nSerialization Flags Examples | Description\n-----------------------------|---------------------------\n0000 0000                    | Block with neither witness nor transactions. Used in [block ID](#block-id).\n0000 0001                    | Block with witness but without transactions. Also called a “[block header](#block-header)”.\n0000 0011                    | Block with both witness and transactions. Also called simply a “[block](#block)”.\n0000 0010                    | Reserved for future use.\n\n\n\n### Block Header\n\n“Block header” is shorthand for a block serialized with [serialization flags](#block-serialization-flags) 0x01. Header does not contain actual transactions, but contains all commitments and witness data with block signatures.\n\n\n\n### Block Commitment\n\nThe *block commitment* string allows extending blocks with additional data. For instance, a hypothetical future [VM version](#vm-version) might append a hash of an additional state available to the programming environment.\n\nUnknown appended commitments must be ignored. Changes to the format of the commitment string may only append new fields, never remove or change the semantics of the existing ones.\n\nField                                   | Type        | Description\n----------------------------------------|-------------|----------------------------------------------------------\nTransactions Merkle Root                | sha3-256    | Root hash of the [merkle binary hash tree](#merkle-binary-tree) formed by the transaction IDs of all transactions included in the block.\nAssets Merkle Root                      | sha3-256    | Root hash of the [merkle patricia tree](#merkle-patricia-tree) of the set of unspent outputs with asset version 1 after applying the block. See [Assets Merkle Root](#assets-merkle-root) for details.\nNext [Consensus Program](#consensus-program) | varstring31 | Authentication predicate for adding a new block after this one.\n—                                       | —           | Additional fields may be added by future extensions.\n\n\n\n### Block Witness\n\nThe *block witness* string contains cryptographic signatures and other data necessary for block verification. It allows extending blocks with additional witness data in future upgrades excluded from any signatures on this block, but committed to by the blocks that follow.\n\nWitness Field           | Type          | Description\n------------------------|---------------|----------------------------------------------------------\nProgram Arguments Count | varint31      | Number of [program arguments](#program-arguments) that follow.\nProgram Arguments       | [varstring31] | List of [signatures](#signature) and other data satisfying previous block’s [next consensus program](#consensus-program).\n—                       | —             | Additional fields may be added by future extensions.\n\nThe entire witness data string (including any unsupported fields) is excluded from the [block’s ID](#block-id).\n\n\n### Block ID\n\nThe *block ID* (also called *block hash*) is defined as [SHA3-256](#sha3) of the block serialized with 0x00 [serialization flags](#block-serialization-flags). This covers header data excluding the block witness, but including the [transactions’ merkle root](#transactions-merkle-root).\n\n\n### Transaction\n\nA *transaction* comprises the following fields concatenated:\n\nField               | Type          | Description\n--------------------|---------------|----------------------------------------------------------\nSerialization Flags | byte          | See [transaction serialization flags](#transaction-serialization-flags).\nVersion             | varint63      | Transaction version, equals 1.\nCommon Fields       | [Extensible string](#extensible-string) | A [common fields varstring31](#transaction-common-fields).\nCommon Witness      | [Extensible string](#extensible-string) | A [common witness varstring31](#transaction-common-witness).\nInputs Count        | varint31      | Number of transaction inputs that follow.\nInputs              | [TxInput]     | List of [transaction inputs](#transaction-input).\nOutputs Count       | varint31      | Number of transaction outputs that follow.\nOutputs             | [TxOutput]    | List of [transaction outputs](#transaction-output).\nReference Data      | varstring31   | Arbitrary string or its [optional hash](#optional-hash), depending on [serialization flags](#transaction-serialization-flags).\n\n\n### Transaction Common Fields\n\nThis is the extensible set of fields common to all inputs and outputs.\n\nField               | Type          | Description\n--------------------|---------------|----------------------------------------------------------\nMinimum Time        | varint63      | Zero or a block timestamp at which transaction becomes valid.\nMaximum Time        | varint63      | Zero or a block timestamp after which transaction becomes invalid.\n—                   | —             | Additional fields may be added by future extensions.\n\n\n### Transaction Common Witness\n\nThe *transaction common witness* string contains data necessary to verify the entire transaction, but not specific to any particular input or output. Witness string does not affect the *outcome* of the transaction and therefore is excluded from the [transaction ID](#transaction-id).\n\nPresent version of the protocol does not define any fields in the common witness.\n\nField               | Type        | Description\n--------------------|-------------|----------------------------------------------------------\n—                   | —           | Additional fields may be added by future extensions.\n\n\n### Transaction Input\n\nA *transaction input* specifies an asset being issued or an earlier output being spent by the transaction. For extensibility, the concrete mechanism for issuance and spending is specific to each asset version, which is specified in the beginning of the input.\n\nThe [asset version](#asset-version) defines the encoding and semantics of the *input commitment* and *witness* strings that follow. Nodes must ignore spend commitment and witness data if the asset version is unknown. This enables soft fork upgrades to new accounting mechanisms, and leaves individual fields readable by older nodes.\n\nField             | Type                | Description\n------------------|---------------------|----------------------------------------------------------\nAsset Version     | varint63            | Version of the asset being referenced by this input.\nInput Commitment  | Extensible string   | See [Transaction Input Commitment](#transaction-input-commitment).\nReference Data    | varstring31         | Arbitrary string or its [optional hash](#optional-hash), depending on [serialization flags](#transaction-serialization-flags).\nInput Witness     | Extensible string   | Optional [input witness](#transaction-input-witness) data. Absent if [serialization flags](#transaction-serialization-flags) do not have the witness bit set.\n\n\n### Transaction Input Commitment\n\n**Asset Version 1** defines two types of input commitments. The type is specified by a single-byte prefix.\n\n1. **Issuance Commitment:** (type 0x00) introduces new units of an asset defined by its issuance program.\n2. **Spend Commitment:** (type 0x01) references already existing value stored in an unspent output.\n\nNodes must reject transactions with unknown type values for asset version 1.\n\nAn asset version other than 1 is reserved for future expansion. Input commitments for undefined versions must be ignored.\n\n#### Asset Version 1 Issuance Commitment\n\nUnlike spending commitments, each of which is unique because it references a distinct [output ID](#output-id), issuance commitments are not intrinsically unique and must be made so to protect against replay attacks. The field *nonce* contains an arbitrary string that must be distinct from the nonces in other issuances of the same asset ID during the interval between the transaction's minimum and maximum time. Nodes ensure uniqueness of the issuance by remembering the [issuance hash](#issuance-hash) that includes the nonce, asset ID and minimum and maximum timestamps. To make sure that *issuance memory* does not take an unbounded amount of RAM, network enforces the *maximum issuance window* for these timestamps.\n\nIf the transaction has another input that guarantees uniqueness of the entire transaction (e.g. a [spend input](#asset-version-1-spend-commitment)), then the issuance input must be able to opt out of the bounded minimum and maximum timestamps and therefore the uniqueness test for the [issuance hash](#issuance-hash). The empty nonce signals if the input opts out of the uniqueness checks.\n\nSee [Validate Transaction](validation.md#validate-transaction) section for more details on how the network enforces the uniqueness of issuance inputs.\n\nField                 | Type                | Description\n----------------------|---------------------|----------------------------------------------------------\nType                  | byte                | Equals 0x00 indicating the “issuance” type.\nNonce                 | varstring31         | Variable-length string guaranteeing uniqueness of the issuing transaction or of the given issuance.\nAsset ID              | sha3-256            | Global [asset identifier](#asset-id).\nAmount                | varint63            | Amount being issued.\n—                     | —                   | Additional fields may be added by future extensions.\n\n\n#### Asset Version 1 Spend Commitment\n\nField                 | Type                  | Description\n----------------------|-----------------------|----------------------------------------------------------\nType                  | byte                  | Equals 0x01 indicating the “spend” type.\nOutput ID             | sha3-256              | [Output ID](#output-id) that references an output being spent.\nOutput Commitment     | [Output Commitment](#transaction-output-commitment) | Output commitment used as the source for this input or its [SHA3-256](#sha3) hash, depending on [serialization flags](#transaction-serialization-flags).\n—                     | —                     | Additional fields may be added by future extensions.\n\n\n### Issuance Hash\n\nIssuance hash provides a globally unique identifier for an issuance input. It is defined as [SHA3-256](#sha3) of the following structure:\n\nField                   | Type                    | Description\n------------------------|-------------------------|----------------------------------------------------------\nNonce                   | varstring31             | Nonce from the [issuance commitment](#asset-version-1-issuance-commitment).\nAsset ID                | sha3-256                | Global [asset identifier](#asset-id).\nMinimum Time            | varint63                | Minimum time from the [common fields](#transaction-common-fields).\nMaximum Time            | varint63                | Maximum time from the [common fields](#transaction-common-fields).\n\nNote: the timestamp values are used exactly as specified in the [transaction](#transaction-common-fields).\n\n\n### Transaction Input Witness\n\nThe *transaction input witness* string contains [program arguments](#program-arguments) ([cryptographic signatures](#signature) and other data necessary to verify the input). Witness string does not affect the *outcome* of the transaction and therefore is excluded from the [transaction ID](#transaction-id).\n\nThe input witness string can be extended with additional commitments, proofs or validation hints that are excluded from the [transaction ID](#transaction-id).\n\nAsset version 1 defines two witness structures: one for issuances and another one for spends.\n\n\n#### Asset Version 1 Issuance Witness\n\nField                   | Type                    | Description\n------------------------|-------------------------|----------------------------------------------------------\nInitial Block ID        | sha3-256                | Hash of the first block in this blockchain.\nAsset Definition        | varstring31             | Arbitrary string or its [optional hash](#optional-hash), depending on [serialization flags](#transaction-serialization-flags).\nVM Version              | varint63                | [Version of the VM](#vm-version) that executes the issuance program.\nIssuance Program        | varstring31             | Predicate defining the conditions of issue.\nProgram Arguments Count | varint31                | Number of [program arguments](#program-arguments) that follow.\nProgram Arguments       | [varstring31]           | [Signatures](#signature) and other data satisfying the spent output’s predicate. Used to initialize the [data stack](vm1.md#vm-state) of the VM that executes an issuance or an control program.\n—                       | —                       | Additional fields may be added by future extensions.\n\nNote: nodes must verify that the initial block ID and issuance program are valid and match the declared asset ID in the [issuance commitment](#asset-version-1-issuance-commitment).\n\n\n#### Asset Version 1 Spend Witness\n\nField                   | Type                    | Description\n------------------------|-------------------------|----------------------------------------------------------\nProgram Arguments Count | varint31                | Number of [program arguments](#program-arguments) that follow.\nProgram Arguments       | [varstring31]           | [Signatures](#signature) and other data satisfying the spent output’s predicate. Used to initialize the [data stack](vm1.md#vm-state) of the VM that executes an issuance or an control program.\n—                       | —                       | Additional fields may be added by future extensions.\n\n\n### Output ID\n\nAn *output ID* uniquely identifies a single transaction output. It is defined as SHA3-256 hash of the following structure:\n\nField                   | Type                    | Description\n------------------------|-------------------------|----------------------------------------------------------\nTransaction ID          | sha3-256                | [Transaction ID](#transaction-id) of the referenced transaction.\nOutput Index            | varint31                | Index (zero-based) of the [output](#transaction-output) within the transaction.\n\n\n### Transaction Output\n\nA *transaction output* specifies an asset version, an output commitment, and reference data.\n\nAsset version defines encoding and semantics of the output commitment string that follows. Nodes must ignore the output commitment if the asset version is unknown. This allows soft fork upgrades to new accounting mechanisms, and leaves the reference data field readable by older nodes.\n\nField               | Type                    | Description\n--------------------|-------------------------|----------------------------------------------------------\nAsset Version       | varint63                | [Version of the asset](#asset-version) being committed to this output.\nOutput Commitment   | Extensible string       | Transaction [output commitment](#transaction-output-commitment) string.\nReference Data      | varstring31             | Arbitrary string or its optional hash, depending on [serialization flags](#transaction-serialization-flags).\nOutput Witness      | Extensible string       | Arbitrary string containing proofs related to the [output commitment](#transaction-output-commitment). Absent if [serialization flags](#transaction-serialization-flags) do not have the witness bit set.\n\n\n### Transaction Output Commitment\n\nThe *output commitment* encapsulates both the value and the authentication data necessary to spend that value.\n\n#### Asset Version 1 Output Commitment\n\nField           | Type                    | Description\n----------------|-------------------------|----------------------------------------------------------\nAsset ID        | sha3-256                | Global [asset identifier](#asset-id).\nAmount          | varint63                | Number of units of the specified asset.\nVM Version      | varint63                | [Version of the VM](#vm-version) that executes the [control program](#control-program).\nControl Program | varstring31             | Predicate [program](#control-program) to control the specified amount.\n—               | —                       | Additional fields may be added by future extensions.\n\n\n### Transaction Output Witness\n\nLike the input witness data, the *output witness* string contains data necessary for transaction verification, but which does not affect the *outcome* of the transaction and therefore is excluded from the [transaction ID](#transaction-id).\n\nThe output witness string can be extended with additional commitments, proofs or validation hints that are excluded from the [transaction ID](#transaction-id).\n\n**Asset version 1** and **VM version 1** do not use the output witness data which is set to an empty string (encoded as a single byte 0x00 that represents a varstring31 encoding of an empty string). To support future upgrades, nodes must accept and ignore arbitrary data in the output witness string.\n\n### Transaction Serialization Flags\n\nSerialization flags control what and how data is encoded in a given *Transaction* message. Unused values are reserved for future expansion. Implementations must reject messages using unsupported serialization values. This allows changing encoding freely and extending the serialization flags fields to a longer sequence if needed.\n\nThe **first (least significant) bit** indicates whether the transaction includes witness data. If set to zero, the input and output witness fields are absent.\n\nThe **second bit** indicates whether the output commitment from the spent output is present in the [input spend commitment](#asset-version-1-spend-commitment). If set to zero, the output commitment field is replaced by the [SHA3-256](#sha3) hash of the output commitment (hashing raw bytes without length prefix).\n\nThe **third bit** indicates whether transaction reference data and asset definitions are present. If set to zero, the reference data and asset definitions are replaced by their optional hash values.\n\nAll three bits can be used independently. Non-zero **higher bits** are reserved for future use.\n\nSerialization Flags Examples | Description\n-----------------------------|---------------------------------------------------------------------------\n0000 0000                    | Minimal serialization without witness and with hashes of previous output commitment, reference data and asset definitions instead of their actual content.\n0000 0011                    | Minimal serialization needed for full verification. Contains witness fields and [output commitment](#transaction-output-commitment), but with hashes of reference data and asset definitions instead of their actual content.\n0000 0101                    | Non-redundant binary serialization with witness fields, reference data and asset definitions, but with the hash of the output commitment instead of its actual content.\n\n\n### Transaction ID\n\nThe *transaction ID* (also called *txid* or *transaction hash*) is defined as [SHA3-256](#sha3) of the transaction serialized with 0x00 [serialization flags](#transaction-serialization-flags). Thus, reference data is hashed via intermediate hashes and transaction witness data is excluded.\n\n\n### Transaction Signature Hash\n\nA *signature hash* (or *sighash*) corresponding to a given input is a hash of the [transaction ID](#transaction-id) and the index for that input. It is returned by [TXSIGHASH](vm1.md#txsighash), and is designed for use with [CHECKSIG](vm1.md#checksig) and [CHECKMULTISIG](vm1.md#checkmultisig) instructions.\n\nThe transaction signature hash is the [SHA3-256](#sha3) of the following structure:\n\nField                   | Type                                      | Description\n------------------------|-------------------------------------------|----------------------------------------------------------\nTransaction ID          | sha3-256                                  | Current [transaction ID](#transaction-id).\nInput Index             | varint31                                  | Index of a given input encoded as [varint31](#varint31).\n\n\n### Program\n\nA variable-length string of instructions executed by a virtual machine during blockchain verification.\n\n### VM Version\n\nA variable-length integer encoded as [varint63](#varint63) that defines bytecode format and virtual machine semantics for a program. See [VM Versioning](vm1.md#versioning) for more details.\n\n### Consensus Program\n\nThe consensus program is a program declared in the [block commitment](#block-commitment) specifying a predicate for signing the next block after the current one.\n\n\n### Control Program\n\nThe control program is a program specifying a predicate for transferring an asset; this is the asset’s destination. Control programs usually contain a hash of a contract allowing the actual contract code to be supplied later in the program arguments list of a spending transaction (along with authentication data such as digital signatures).\n\n### Issuance Program\n\nThe issuance program is a [program](#program) specifying a predicate for issuing an asset within an [input issuance commitment](#asset-version-1-issuance-commitment). The asset ID is derived from the issuance program, guaranteeing the authenticity of the issuer.\n\n\n### Program Arguments\n\nA list of binary strings in a [transaction input witness](#transaction-input-witness) and [block witness](#block-witness) structures. It typically contains signatures and other data to satisfy the predicate specified by the control program of the output referenced by the current input. Program arguments are used also for authenticating *issuance inputs* where the predicate is defined by an issuance program.\n\n### Asset Version\n\nAn *asset version* is a variable-length integer encoded as [varint63](#varint63). Asset issuance and transfer is defined within the scope of a given asset version. Commitments and witness fields of inputs and outputs with unknown versions are treated as opaque strings. Unassigned versions are left for future extensions.\n\n### Asset ID\n\nGlobally unique identifier of a given asset. Each [asset version](#asset-version) defines its own method to compute the asset ID, but an asset ID is always guaranteed to be unique across all asset versions and across all blockchains.\n\nAsset ID is defined as the [SHA3-256](#sha3) of the following structure:\n\nField                 | Type          | Description\n----------------------|---------------|-------------------------------------------------\nInitial Block ID      | sha3-256      | Hash of the first block in this blockchain.\nVM Version            | varint63      | [Version of the VM](#vm-version) for the issuance program.\nIssuance Program      | varstring31   | Program used in the issuance input.\nAsset Definition Hash | sha3-256      | [SHA3-256](#sha3) hash of the asset definition data.\n\n\n### Asset Definition\n\nAn asset definition is an arbitrary binary string that corresponds to a particular [asset ID](#asset-id). Each asset version may define its own method to declare and commit to asset definitions.\n\n\n### Retired Asset\n\nUnits of an asset can be retired by sending them to a [VM version 1](#vm-version) [control program](#control-program) starting with [FAIL](vm1.md#fail) instruction resulting in a provably unspendable output. The rest of the control program can contain arbitrary instructions.\n\nRetired assets are not included in the [assets merkle root](#assets-merkle-root) and therefore do not occupy any memory in the nodes. One may use a merkle path to the [transactions merkle root](#transactions-merkle-root) to create a compact proof for a retired asset.\n\nNote: many other kinds of control programs may render the output unspendable (e.g. `FALSE` or `0 VERIFY`), but they do not cause the output to be removed from the [assets merkle root](#assets-merkle-root), only programs beginning with `FAIL` do.\n\n### Transactions Merkle Root\n\nRoot hash of the [merkle binary hash tree](#merkle-binary-tree) formed by the [transaction IDs](#transaction-id) of all transactions included in the block.\n\n### Assets Merkle Root\n\nRoot hash of the [merkle patricia tree](#merkle-patricia-tree) formed by unspent outputs with an **asset version 1** after applying the block. Allows bootstrapping nodes from recent blocks and an archived copy of the corresponding merkle patricia tree without processing all historical transactions.\n\nThe tree contains the list of the [Output IDs](#output-id) of all [non-retired](#retired-asset) unspent outputs.\n\n\n### Merkle Root\n\nA top hash of a *merkle tree* (binary or patricia). Merkle roots are used within blocks to commit to a set of transactions and complete state of the blockchain. They are also used in merkleized programs and may also be used for structured reference data commitments.\n\n\n\n### Merkle Binary Tree\n\nThe protocol uses a binary merkle hash tree for efficient proofs of validity. The construction is from [RFC 6962 Section 2.1](https://tools.ietf.org/html/rfc6962#section-2.1), but using SHA3–256 instead of SHA2–256. It is reproduced here, edited to update the hashing algorithm.\n\nThe input to the *merkle binary tree hash* (MBTH) is a list of data entries; these entries will be hashed to form the leaves of the merkle hash tree. The output is a single 32-byte hash value. Given an ordered list of n inputs, `D[n] = {d(0), d(1), ..., d(n-1)}`, the MBTH is thus defined as follows:\n\nThe hash of an empty list is the hash of an empty string:\n\n    MBTH({}) = SHA3-256(\"\")\n\nThe hash of a list with one entry (also known as a leaf hash) is:\n\n    MBTH({d(0)}) = SHA3-256(0x00 || d(0))\n\nFor n \u003e 1, let k be the largest power of two smaller than n (i.e., k \u003c n ≤ 2k). The merkle binary tree hash of an n-element list `D[n]` is then defined recursively as\n\n    MBTH(D[n]) = SHA3-256(0x01 || MBTH(D[0:k]) || MBTH(D[k:n]))\n\nwhere `||` is concatenation and `D[k1:k2]` denotes the list `{d(k1), d(k1+1),..., d(k2-1)}` of length `(k2 - k1)`. (Note that the hash calculations for leaves and nodes differ. This domain separation is required to give second preimage resistance.)\n\nNote that we do not require the length of the input list to be a power of two. The resulting merkle binary tree may thus not be balanced; however, its shape is uniquely determined by the number of leaves.\n\n![Merkle Binary Tree](merkle-binary-tree.png)\n\n\n### Merkle Patricia Tree\n\nThe protocol uses a binary radix tree with variable-length branches to implement a *merkle patricia tree*. This tree structure is used for efficient concurrent updates of the [assets merkle root](#assets-merkle-root) and compact recency proofs for unspent outputs.\n\nThe input to the *merkle patricia tree hash* (MPTH) is a list of data entries; these entries will be hashed to form the leaves of the merkle hash tree. The output is a single 32-byte hash value. The input list must be prefix-free; that is, no element can be a prefix of any other. Given a sorted list of n unique inputs, `D[n] = {d(0), d(1), ..., d(n-1)}`, the MPTH is thus defined as follows:\n\nThe hash of an empty list is a 32-byte all-zero string:\n\n    MPTH({}) = 0x0000000000000000000000000000000000000000000000000000000000000000\n\nThe hash of a list with one entry (also known as a leaf hash) is:\n\n    MPTH({d(0)}) = SHA3-256(0x00 || d(0))\n\nFor n \u003e 1, let the bit string p be the longest common prefix of all items in `D[n]`, and let k be the number of items that have a prefix `p||0` (that is, p concatenated with the single bit 0). The merkle patricia tree hash of an n-element list `D[n]` is then defined recursively as:\n\n    MPTH(D[n]) = SHA3-256(0x01 || MPTH(D[0:k]) || MPTH(D[k:n]))\n\nwhere `||` is concatenation and `D[k1:k2]` denotes the list `{d(k1), d(k1+1),..., d(k2-1)}` of length `(k2 - k1)`. (Note that the hash calculations for leaves and nodes differ. This domain separation is required to give second preimage resistance.)\n\nNote that the resulting merkle patricia tree may not be balanced; however, its shape is uniquely determined by the input data.\n\n![Merkle Patricia Tree](merkle-patricia-tree.png)\n\n## References\n\n* [FIPS180] [“Secure Hash Standard”, United States of America, National Institute of Standards and Technology, Federal Information Processing Standard (FIPS) 180-2](http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf).\n* [FIPS202] [Federal Inf. Process. Stds. (NIST FIPS) - 202 (SHA3)](https://dx.doi.org/10.6028/NIST.FIPS.202)\n* [LEB128] [Little-Endian Base-128 Encoding](https://developers.google.com/protocol-buffers/docs/encoding)\n* [CFRG1] [Edwards-curve Digital Signature Algorithm (EdDSA) draft-irtf-cfrg-eddsa-05](https://tools.ietf.org/html/draft-irtf-cfrg-eddsa-05)\n* [RFC 6962](https://tools.ietf.org/html/rfc6962#section-2.1)\n\n\n\n"},{"Url":"/docs/1.1/protocol/specifications/readme.md","Body":"# Chain Protocol specification\n\n## Introduction\n\nThis is the technical specification for the Chain Protocol. It describes the entities and their relationships, the data structures and encoding formats, and the operations necessary to run a fully functional node in a blockchain network. The reader is assumed to have knowledge of basic cryptographic concepts such as cryptographic hashes and public key cryptography.\n\nA companion document, the [Chain Protocol whitepaper](../papers/whitepaper.md), includes motivation for the design choices, usage notes and other discussion.\n\nChain, Inc. provides production-grade software called [Chain Core](https://chain.com/core) that implements a network node as defined in this specification.\n\n## Documents\n\n* [Data Model Specification](data.md)\n* [Validation Protocol](validation.md)\n* [Consensus Protocol](consensus.md)\n* [Virtual Machine Specification](vm1.md)\n* [ChainKD](chainkd.md) (key derivation scheme)\n"},{"Url":"/docs/1.1/protocol/specifications/txgraph-draft.md","Body":"# Transaction graph structure\n\n## Transaction entry types\n\nAll entries inherit from a common type `AbstractEntry`.\n\n    Header\n    Issuance\n    Spend\n    Output\n    Retirement\n    Mux\n    Data\n    Nonce\n    Predicate\n    TimeRange\n    UnknownEntry = all other types, undefined in the current protocol version\n\n### Entry ID\n\nIdentifier of the entry is based on its type and body. Body is length-prefixed, type is varint-encoded\n\n    entry.id  = HASH(\"entryid:\" || entry.type  || \":\" || entry.body_hash)\n\n\n## Abstract Entry (base type for all concrete entries)\n\n    - type:     String\n    - body:     hashable\n    - witness:  hashable\n\nWhere `hashable` is any type for which a hashing serialization is defined. See [Serialization for hashing](#serialization-for-hashing) description below.\n\n## UnknownEntry\n\n    - type:         String (not statically known)\n    - body_hash:    Hash\n    - witness_hash: Hash\n\n**Rules:**\n\n1. Type string must be transmitted explicitly from newer nodes to older nodes, so that the older nodes can compute the Entry ID with the correct type string.\n\n## TxHeader\n\n    entry {\n        type=\"txheader\"\n        body:\n            version:       Integer\n            results:       List\u003cPointer\u003cOutput|Retirement|UnknownEntry\u003e\u003e\n            data:          Pointer\u003cData|UnknownEntry\u003e\n            mintime:       Integer\n            maxtime:       Integer\n            ext_hash:      Hash\n        witness:\n            ext_hash:      Hash        \n    }\n\n**Rules:**\n\n1. If version is known, all `ext_hash`es must be hashes of empty strings, `UnknownEntry`s are not allowed in `results`.\n2. Results must contain at least one item.\n3. Results must of type `Output|Retirement|UnknownEntry`.\n4. Every result must be present and valid.\n6. Entry `data` must be present and must be of type `Data` or `UnknownEntry`.\n7. mintime must be either zero or a timestamp higher than the timestamp of the block that includes the transaction.\n8. maxtime must be either zero or a timestamp lower than the timestamp of the block that includes the transaction.\n\n\n## Data\n\n    entry {\n        type=\"data1\"\n        body: Hash\n        witness: HASH(empty_string)\n    }\n\n**Rules:**\n\n1. witness must be empty\n2. Note: the body is a hash of the underlying data. The underlying data may not be known. If a transaction author wants to provide the underlying data, it must be done in the transport layer alongisde the actual transaction.\n\n### xxx specify hash function for underlying data (w/\ndomain separation, prob)\n\n\n## Output\n\n    entry {\n        type=\"output1\"\n        body:\n            source:          ValueSource\n            control_program: Program\n            data:            Pointer\u003cData\u003e\n            ext_hash:        Hash\n        witness:\n            ext_hash:        Hash\n    }\n\n**Rules:**\n\n1. Let `preventry` be the `source.ref`.\n2. `preventry` must be present and valid.\n3. Validate `source.amount` is in range.\n4. Need to ensure that this output exclusively consumes the `preventry`'s destination.\n5. If `preventry` is Spend or Issuance:\n    1. Let `dest` be `preventry.destination`.\n6. If `preventry` is Mux:\n    1. Let `dest` be `preventry.destinations[source.position]`. Fail if not found.\n7. Verify previous entry's destination `dest`:\n    1. Verify `dest.ref` == `self.id`.\n    2. Verify `dest.position` == `0`. This is position of value in this output. TBD: this is double-checked by the input.\n8. If tx version is known, all `ext_hash`es must be hashes of empty strings.\n9. Insert `self.id` in utxo set.\n\n## Retirement\n\n    entry {\n        type=\"retirement1\"\n        body:\n            source:         ValueSource\n            data:           Pointer\u003cData\u003e\n            ext_hash:       Hash\n        witness:\n            ext_hash:       Hash\n    }\n\n**Rules:**\n\n1. Let `preventry` be the `source.ref`.\n2. `preventry` must be present and valid.\n3. Validate `source.amount` is in range.\n4. Need to ensure that this output exclusively consumes the `preventry`'s destination.\n5. If `preventry` is Spend or Issuance:\n    1. Let `dest` be `preventry.destination`.\n6. If `preventry` is Mux:\n    1. Let `dest` be `preventry.destinations[source.position]`. Fail if not found.\n7. Verify previous entry's destination `dest`:\n    1. Verify `dest.ref` == `self.id`.\n    2. Verify `dest.position` == `0`. This is position of value in this output. TBD: this is double-checked by the input.\n8. If tx version is known, all `ext_hash`es must be hashes of empty strings.\n\n\n\n## Spend\n\n    entry {\n        type=\"spend1\"\n        body:\n          spent_output: Pointer\u003cOutput\u003e\n          data:         Pointer\u003cData\u003e\n          ext_hash:     Hash\n        witness:\n          destination:  ValueDestination\n          arguments:    String\n          ext_hash:     Hash        \n    }\n\n**Rules:**\n\n1. Validate that `spent_output` is present in tx.\n2. Validate that `spent_output` is present in UTXO set.\n3. Validate that `destination.ref` has been validated (visited). TBD: !!! figure out what that actually means.\n4. If `destination.ref` is a Output or Retirement `nextentry`:\n    1. Validate that `destination.position` == `0` (this is value's position in the output). TBD: maybe move this to Output.\n    2. Let `src` be `nextentry.source`.\n5. If `destination.ref` is a Mux `nextentry`:\n    1. Let `src` be `nextentry.sources[destination.position]`. Fail if not present.\n6. Validate next entry’s source `src`:\n    1. Validate that `src.ref` == `self.id`.\n    2. Validate that `src.position` == `0` (this is value's position in the spend).\n    3. Validate that `src.value` == `self.spent_output.source.value`.\n7. The `spent_output.program` must evaluate to `true` with given `arguments`.\n8. Remove `spent_output` from UTXO set.\n\nNB: `spent_output` is not validated, as it was already validated in the transaction that added it to the UTXO.\n\n\n## Issuance\n\n    entry {\n        type=\"issuance1\"\n        body:\n          anchor:           Pointer\u003cNonce|Spend\u003e\n          value:            AssetAmount\n          data:             Pointer\u003cData\u003e\n          ext_hash:         Hash\n        witness:\n          destination:      ValueDestination\n          initial_block_id: Hash\n          asset_definition: Pointer\u003cData\u003e\n          issuance_program: Program\n          arguments:        String\n          ext_hash:         Hash\n    }\n\n**Rules:**\n\n1. Check that `value.asset_id == HASH(initial_block_id, asset_definition, issuance_program)`.\n2. The `issuance_program` must evaluate to `true` with given `arguments`.\n3. Validate that `destination.ref` has been validated (visited). TBD: !!! figure out what that actually means.\n4. If `destination.ref` is a Output or Retirement `nextentry`:\n    1. Validate that `destination.position` == `0` (this is value's position in the output). TBD: maybe move this to Output.\n    2. Let `src` be `nextentry.source`.\n5. If `destination.ref` is a Mux `nextentry`:\n    1. Let `src` be `nextentry.sources[destination.position]`. Fail if not present.\n6. Validate next entry’s source `src`:\n    1. Validate that `src.ref` == `self.id`.\n    2. Validate that `src.position` == `0` (this is value's position in the input).\n    3. Validate that `src.value` == `self.value`.\n\n\n\n## Mux\n\n    entry {\n        type=\"mux1\"\n        body:        \n            sources:      List\u003cValueSource\u003e\n            ext_hash:     Hash\n        witness:          \n            destinations: List\u003cValueDestination\u003e\n            ext_hash:     Hash\n    }\n\n\n**Rules:**\n\n1. Each `source` must be unique in this entry.\n2. Each item in `destinations` must be unique in this entry.\n3. For each item `dest` in `destinations` at position `i`:  \n    1. Validate that `dest.ref` has been validated (visited). TBD !!!!\n    2. If `dest.ref` is a Output or Retirement `nextentry`:\n        1. Validate that `dest.position` == `0` (this is value's position in the output). TBD: maybe move this to Output.\n        2. Let `src` be `nextentry.source`.\n    3. If `dest.ref` is a Mux `nextentry`:\n        1. Let `src` be `nextentry.sources[dest.position]`. Fail if not present.\n    4. Validate next entry’s source `src`:    \n        1. Validate that `src.ref` == `self.id`.\n        2. Validate that `src.position` == `i` (this is value's position in this mux's destinations list).\n        3. Validate that `src.value` == `dest.value`.\n        4. Pull the AssetAmount `a` from that `src` and assign it to the `dest`.\n4. For each asset ID in the `sources` and `destinations`:\n    1. Sum the amounts of that asset ID in `sources` and the amounts of that asset ID in `destinations`.\n    2. Test that both the `sources` and `destinations` sums are less than 2^63.\n    3. Test that the `sources` sum equals the `destinations` sum.\n    4. Check that there is at least one `source` with that asset ID.\n\n\n\n\n## ValueSource\n\n    struct {\n        ref:      Pointer\u003cIssuance|Spend|Mux\u003e\n        value:    AssetAmount\n        position: Integer\n    }\n\n**Rules:**\n\n1. Let `entry, src, position` be the current entry, the value source being checked and its position in the entry's sources list.\n2. Let `preventry` be the entry referenced by `src.ref`.\n3. Let `prevdst` be the value destination located by `preventry.destinations[src.position]`.\n4. Verify that `prevdst.ref` equals `entry.id`.\n5. Verify that `prevdst.position` equals `position`.\n6. Verify that `prevdst.value` equals `src.value`.\n\n## ValueDestination\n\n    struct {\n        ref:       Pointer\u003cOutput|Retirement|Mux\u003e\n        value:     AssetAmount\n        position:  Integer\n    }\n\n1. Let `entry, dst, position` be the current entry, the value destination being checked and its position in the entry's destinations list.\n2. Let `nextentry` be the entry referenced by `dst.ref`.\n3. Let `nextsrc` be the value source located by `nextentry.sources[dst.position]`.\n4. Verify that `nextsrc.ref` equals `entry.id`.\n5. Verify that `nextsrc.position` equals `position`.\n6. Verify that `nextsrc.value` equals `dst.value`.\n\n\n## Nonce\n\n    entry {\n        type=\"nonce1\"\n        body:\n          program:    Program\n          timerange:  Pointer\u003cTimeRange\u003e\n          ext_hash:   Hash\n        witness:\n          arguments:  String\n          ext_hash:   Hash\n    }\n\n**Rules:**\n\n1. If tx version is known, the ext fields must be empty.\n2. The ID of the nonce entry must be globally unique on the blockchain.\n3. The `program` must evaluate to `true` with given `arguments`.\n\n\n## TimeRange\n\n    entry {\n        type=\"timerange\"\n        body:\n            mintime:  Integer\n            maxtime:  Integer\n            ext_hash: Hash\n        witness:\n            ext_hash: Hash\n    }\n\n**Rules:**\n\n1. `mintime` must be equal to or less than the `txheader.mintime` specified in the transaction header.\n2. `maxtime` must be equal to or greater than the `txheader.maxtime` specified in the transaction header.\n\n\n## AssetAmount\n\nThis is not a separate entry, but an inlined struct.\n\n    Struct {\n        assetID: Hash\n        amount:  Integer\n    }\n\n## Program\n\nThis is not a separate entry, but an inlined struct that carries VM version and the program code in VM-specific encoding.\n\n    Struct {\n        vm_version: Integer\n        code:       String\n    }\n\n## Pointer\n\nPointer is:\n\n1. encoded as `Hash`,\n2. identifies another entry by its ID,\n3. restricts the possible acceptable types.\n\nPointer can be `nil`, in which case it is represented by all-zero 32-byte hash `0x000000...`.\n\n## Serialization for hashing\n\nPrimitives:\n\n    Byte\n    Hash\n    Integer\n    String\n    List\n    Struct\n\n* `Byte` is encoded as 1 byte.\n* `Hash` is encoded as 32 bytes.\n* `Integer` is encoded as LEB128, with 63-bit limit.\n* `String` is encoded as LEB128 length prefix with 31-bit limit followed by raw bytes.\n* `List` is encoded as LEB128 length prefix with 31-bit limit followed by serialized items, one by one (`Byte|Hash|Integer|String|List|Struct|ExtStruct`) as defined by the schema.\n* `Struct` is encoded as concatenation of all its serialized fields.\n* `ExtStruct` is encoded as concatenation of top fields with first `exthash` with a recursive rule for `exthash`. See below.\n\nCommon types:\n\n    Pointer = Hash (identifies another entry)\n    Program = Struct{vm_version: Integer, code: String}\n\n\n\n## ExtStruct\n\nExtensible struct contains flat list of fields and the last field is the extension hash.\n\nThe remaining fields are committed to that extension hash. They are defined in flat namespace in a protobuf definition, but for the hashing purposes we group them recursively under another ExtStruct instance:\n\n    ExtStruct {\n        fields...\n        exthash: Hash\n        ext: ExtStruct\n    }\n\n    exthash == HASH(ext)\n    HASH(ExtStruct) == HASH(serialized-fields || exthash)\n\nOld clients ignore the extended fields (`ext`) and only see the first fields they understand plus the `exthash`.\n\nIf the extensibility is not allowed (e.g. when tx version is known), the last `exthash` must be a hash of an empty string.\n\n**Examples:**\n\nV1 schema:\n\n    entry {\n        a\n        b\n        exthash\n    }\n    ID = H(a || b || exthash1)\n\nV2 schema:\n\n    {\n        a\n        b\n        exthash1\n        c\n        d\n        exthash2\n    }\n    exthash1 = H(c || d || exthash2)\n    ID = H(a || b || exthash1)\n\nNote: when V2 data is encoded and sent to V1, V1 client drops `(c,d,exthash2)` fields and only uses `a,b,exthash1` fields to compute the ID. Which turns out the same as for V2 client.\n\nV3 schema:\n\n    {\n        a\n        b\n        exthash1\n        c\n        d\n        exthash2\n        e\n        f\n        exthash3\n    }  \n    exthash2 = H(e || f || exthash3)\n    exthash1 = H(c || d || exthash2)\n    ID = H(a || b || exthash1)\n\nThe scheme is applied recursively for the subsequent updates.\n\n\n\n## Translation Layer\n\n### OldTx -\u003e NewTx\n\nThis is a first intermediate step that allows keeping old SDK, old tx index and data structures within Core, but refactoring how txs and outputs are hashed for UTXO set and merkle root in block headers.\n\n1. Let `oldtx` be the transaction in old format.\n2. Let `newtx` be a new instance of `TxHeader` entry.\n3. Let `container` be the container for all entries.\n4. Set `newtx.version` to `oldtx.version`.\n5. If `oldtx.data` is non-empty:\n    1. Let `refdata` be a new `Data` entry.\n    2. Set `refdata.body` to `tx.data`.\n    3. Set `newtx.data` to `refdata.id`.\n    4. Add `refdata` to the `container`.\n6. Set `newtx.mintime` to `oldtx.mintime`.\n7. Set `newtx.maxtime` to `oldtx.maxtime`.\n8. Let `mux` be a new `Mux` entry.\n9. For each old input `oldinp`:\n    1. If the old input is issuance:\n        1. Let `is` be a new `Issuance` entry.\n        2. Set `is.value` to `AssetAmount { oldinp.assetid, oldinp.amount }`.\n        3. If `nonce` is empty:\n            1. Set `is.anchor` to the ID of the first new input. (If no input was mapped yet, go back to this step when such input is added.)\n        4. If `nonce` is non-empty:\n            1. Let `a` be a new `Nonce` entry.\n            2. Set `a.program` to (VM1, `PUSHDATA(nonce) DROP ASSET PUSHDATA(oldinp.assetid) EQUAL`. (The program pushes the nonce onto the stack then drops it, then calls the ASSET opcode, pushes the hardcoded old asset ID onto the stack, and checks that they are equal.)\n            3. Let `tr` be a new `TimeRange` entry.\n            4. Set `tr.mintime` to `oldtx.mintime`.\n            5. Set `tr.maxtime` to `oldtx.maxtime`.\n            6. Set `a.timerange` to `tr.id`.\n            7. Set `is.anchor` to `a.id`.\n            8. Add `a` to `container`.\n            9. Add `tr` to `container`.\n        5. Set `is.initial_block_id` to `oldinp.initial_block_id`.\n        6. Set `is.issuance_program` to `oldinp.issuance_program` (with its VM version).\n        7. If `oldinp.asset_definition` is non-empty:\n            1. Let `adef` be a new `Data` entry.\n            2. Set `adef.body` to `oldinp.asset_definition`.\n            3. Set `is.asset_definition` to `adef.id`.\n            4. Add `adef` to `container`.\n        8. If `oldinp.asset_definition` is empty:\n            1. Set `is.asset_definition` to a nil pointer `0x000000...`.\n        9. Create `ValueSource` struct `src`:\n            1. Set `src.ref` to `is.id`.\n            2. Set `src.position` to 0.\n            3. Set `src.value` to `is.value`.\n            4. Add `src` to `mux.sources`.\n        10. Add `is` to `container`.\n    2. If the old input is a spend:\n        1. Let `inp` be a new `Spend` entry.\n        2. Set `inp.spent_output` to `oldinp.output_id`.\n        3. Set `inp.data` to a nil pointer `0x00000...`.\n        4. Create `ValueSource` struct `src`:\n            1. Set `src.ref` to `inp.id`.\n            2. Set `src.position` to 0.\n            3. Set `src.value` to `AssetAmount{ oldinp.spent_output.(assetid,amount) } `.\n            4. Add `src` to `mux.sources`.\n        5. Add `inp` to `container`.\n11. For each output `oldout` at index `i`:\n    1. If the `oldout` contains a retirement program:\n        1. Let `destentry` be a new `Retirement` entry.\n    2. If the `oldout` is not a retirement:\n        1. Let `destentry` be a new `Output` entry.\n        2. Set `destentry.control_program` to `oldout.control_program` (with its VM version).\n    3. Create `ValueSource` struct `src`:\n        1. Set `src.ref` to `mux.id`.\n        2. Set `src.position` to `i`.\n        3. Set `src.value` to `AssetAmount { oldout.asset_id, oldout.amount }`.\n        4. Set `destentry.source` to `src`.\n    4. If `oldout.data` is non-empty:\n        1. Let `data` be a new `Data` entry.\n        2. Set `data.body` to `oldout.data`.\n        3. Set `destentry.data` to `data.id`.\n        4. Add `data` to `container`.\n    5. Add `destentry` to `container`.\n    6. Add `destentry` to `newtx.results`.\n\n\n### OldTxID -\u003e NewTxID\n\n1. Map old tx to `newtx`.\n2. Return new tx's header ID as NewTxID.\n\n### OldWitTxID -\u003e NewWitTxID\n\n1. Map old tx to new tx.\n2. Return new tx's header ID as NewWitTxID. This is the same as NewTxID.\n\n### OldOutputID -\u003e NewOutputID\n\nWhen indexing old tx's outputs:\n\n1. Map old tx to new tx.\n2. Take corresponding new output.\n3. Compute its entry ID which will be NewOutputID.\n4. Use this new output ID to identify unspent outputs in the DB.\n\n### OldUnspentID -\u003e NewUnspentID\n\nWhen inserting old tx's outputs into UTXO merkle set:\n\n1. Map old tx to new tx.\n2. Take corresponding new output.\n3. Compute its entry ID which will be NewUnspentID. (This is the same as NewOutputID.)\n4. Use this new unspent ID to insert into UTXO merkle set.\n\n\n### OldIssuanceHash -\u003e NewIssuanceHash\n\n1. Map old tx to new tx.\n2. For each nonce entry in the new tx:\n    1. check its time range is within network-defined limits (not unbounded).\n    2. Use this entry ID as NewIssuanceHash\n    3. Insert new issuance hash in the current _issuance memory_ annotated with expiration date based on `nonce.timerange.maxtime`.\n\n### OldSigHash -\u003e NewSigHash\n\n1. Map old tx to new tx.\n2. For each entry where a program is evaluated (Spend, Issuance or Nonce):\n    1. Compute `sighash = HASH(txid || entryid)`.\n\n\n\n### NewTx -\u003e OldTx\n\nThis is a second intermediate step that allows keeping old SDK, but refactoring how txs are represented and stored internally in Core.\n\nTODO: ...\n\n\n## Compression\n\n1. Serialization prefix indicates the format version that specifies how things are serialized and compressed.\n2. Replace hashes with varint offsets, reconstruct hashes in real time and then verify that top hash matches the source (e.g. merkle tree item)\n3. Replace some repeated elements such as initial block id with indices too.\n\n### 3. VM mapping\n\nThis shows how the implementation of each of the VM instructions need to be changed. Ones that say \"no change\" will work as already implemented on the OLD data structure.\n\n* CHECKOUTPUT:   no change\n* ASSET:         no change\n* AMOUNT:        no change\n* PROGRAM:       no change\n* MINTIME:       no change\n* MAXTIME:       no change\n* INDEX:         no change\n* NONCE:         eliminated\n* TXREFDATAHASH: `newtx.refdatahash()`\n* REFDATAHASH:   `newcurrentinput.refdatahash()`\n* TXSIGHASH:     `hash(newcurrentinput.id() || newtx.id())`\n* OUTPUTID:      `newcurrentinput.spent_output.id()`\n\n\nNew opcodes:\n\n* ENTRYID:       `currententry.id()`\n* NONCE:         `currentissuance.anchor.id()` (fails if the entry is not an issuance)\n\n\n### 4. Eliminating witness hash\n\nFor simplicity and flexibility, we are removing the commitments to both the transaction witnesses and the block witness.\n\n1. The [transactions Merkle root](https://chain.com/docs/1.1/protocol/specifications/data#transactions-merkle-root) should be calculated based on the transaction IDs, rather than the transaction witness hashes. The code for calculating the transaction witness hashes can be eliminated.\n\n2. `Block ID` (which is the ID included in the next block, and which currently includes the hash of the block witness) should be computed instead to be identical to how the block signature hash is currently computed (i.e., it should use 0x00 serialization flags).\n\n\n### 5. Block header format\n\nThe new slightly different serialization format (i.e. the type prefix and extension hash format) should be applied to the block header as well. We are also removing the block witness from the block ID, as discussed above. Finally, we should flatten the confusing \"block commitment\" and simply make it three separate fields in the block header.\n\n#### BlockHeader entry\n\n    entry {\n        type=\"blockheader\"\n        body:\n            version:                Integer\n            height:                 Integer\n            previous_block_id:      Pointer\u003cBlockHeader\u003e\n            timestamp:              Integer\n            transactions:           MerkleTree\u003cPointer\u003cTxHeader\u003e\u003e\n            assets:                 PatriciaTree\u003cPointer\u003cOutput\u003e\u003e\n            next_consensus_program: String\n            ext_hash:               Hash\n        witness:\n            ext_hash:               Hash        \n    }\n\nThe `MerkleTree` and `PatriciaTree` types are just 32-byte hashes representing the root of those respective trees.\n\n#### OldBlockHeader -\u003e NewBlockHeader\n\nThis generates a new BlockHeader data structure, for hashing purposes, from an old block.\n\n1. Let `oldblock` be the block in old format.\n2. Let `newblock` be a new instance of `BlockHeader` entry.\n3. Set `newblock.version` to `oldblock.version`.\n4. Set `newblock.height` to `oldblock.height`.\n5. Set `newblock.previous_block_id` to `oldblock.previous_block_id`.\n6. Set `newblock.timestamp` to `oldblock.timestamp`.\n7. Set `newblock.transactions` to `oldblock.block_commitment.transactions` (i.e. the root of the Merkle tree). Note that this Merkle tree should have been calculated using the new transaction ID.\n7. Set `newblock.assets` to `oldblock.block_commitment.assets` (i.e. the root of the Patricia tree). Note that this Patricia tree should have been calculated using the new Output IDs.\n8. Set `newblock.next_consensus_program` to `oldblock.block_commitment.next_consensus_program`\n\n#### VM mapping\n\nPROGRAM:       same\nNEXTPROGRAM:   same\nBLOCKTIME:     same\nBLOCKSIGHASH:  newblock.id()\n"},{"Url":"/docs/1.1/protocol/specifications/validation.md","Body":"# Blockchain Validation Protocol\n\n* [Introduction](#introduction)\n* [General requirements](#general-requirements)\n* [Node state](#node-state)\n* [Algorithms](#algorithms)\n  * [Join new network](#join-new-network)\n  * [Join existing network](#join-existing-network)\n  * [Make initial block](#make-initial-block)\n  * [Accept block](#accept-block)\n  * [Check block is well-formed](#check-block-is-well-formed)\n  * [Validate block](#validate-block)\n  * [Validate transaction](#validate-transaction)\n  * [Validate transaction input](#validate-transaction-input)\n  * [Check transaction is well-formed](#check-transaction-is-well-formed)\n  * [Apply block](#apply-block)\n  * [Apply transaction](#apply-transaction)\n  * [Evaluate predicate](#evaluate-predicate)\n\n\n## Introduction\n\nThis document describes all the algorithms involved in participating as a node in a blockchain network, including their interfaces and requirements for persistent state.\n\n## General requirements\n\n### Interfaces\n\nEach algorithm specifies its interface to the outside world under the labels *inputs*, *outputs*, *references*, and *affects*. *Input* is data that must be explicitly provided to the algorithm by its invoking context (either another algorithm or a user). *Output* is data that is explicitly returned from the algorithm to its invoking context. *References* lists elements of the persistent state (described above) that might be read. *Affects* lists elements of the persistent state that can be modified.\n\n### Optimization\n\nA conforming implementation must behave as if it is following the algorithms described below. However, for the sake of efficiency or convenience, it is permitted to take other actions instead as long as they yield the same result. For example, a conforming implementation might \"memoize\" the result of a computation rather than recomputing it multiple times, or it might perform the steps of an algorithm in a different but equivalent order.\n\n### Serializability\n\nA conforming implementation must be serializable with respect to these algorithms. That is, it can execute them concurrently in parallel, but it must produce the same output and side effects as if they had run serially in some order.\n\nThis requirement also implies that all side effects together must be atomic for each algorithm.\n\n### Node state\n\nAll nodes store a *current blockchain state*, which can be replaced with a new blockchain state.\n\nA *blockchain state* comprises:\n\n* A [block header](data.md#block-header).\n* A *timestamp* equal to the timestamp in the [block header](data.md#block-header).\n* The set of [output IDs](data.md#output-id) representing [non-retired](data.md#retired-asset) unspent outputs in the block’s [assets merkle tree](data.md#assets-merkle-root).\n* An *issuance memory*: a set of (issuance hash, expiration timestamp) pairs. It records recent issuance inputs in the state in order to detect duplicates.\n\n\n## Algorithms\n\nThe algorithms below describe the rules for updating a node’s state. Some of the algorithms are used only by other algorithms defined here. Others are entry points — they are triggered by network activity or user input.\n\nEntry Point                                              | When used\n---------------------------------------------------------|----------------------------------\n[Join New Network](#join-new-network)                    | A new network is being set up.\n[Join Existing Network](#join-existing-network)          | Adding a new node to an already existing network.\n[Accept Block](#accept-block)                            | Nodes receive a fully-signed block, validate it and apply it to their state.\n\n\n\n### Join new network\n\nA new node starts here when joining a new network (with height = 1).\n\n**Inputs:**\n\n1. consensus program,\n2. time.\n\n**Output:** true or false.\n\n**Affects:** current blockchain state.\n\n**Algorithm:**\n\n1. [Make an initial block](#make-initial-block) with the input block’s timestamp and [consensus program](data.md#consensus-program).\n2. The created block must equal the input block; if not, halt and return false.\n3. Allocate an empty unspent output set.\n4. The initial block and these empty sets together constitute the *initial state*.\n5. Assign the initial state to the current blockchain state.\n6. Return true.\n\n\n### Join existing network\n\nA new node starts here when joining a running network (with height \u003e 1). In that case, it does not validate all historical blocks, and the correctness of the blockchain state must be established out of band, for example, by comparing the [block ID](data.md#block-id) to a known-good value.\n\n**Input:** blockchain state.\n\n**Output:** true or false.\n\n**Affects:** current blockchain state.\n\n**Algorithm:**\n\n1. Compute the [assets merkle root](data.md#assets-merkle-root) of the state.\n2. The block commitment in the input state must contain the computed assets merkle root; if not, halt and return false.\n3. Assign the input state to the current blockchain state.\n4. Return true.\n\n\n### Make initial block\n\n**Inputs:**\n\n1. consensus program,\n2. time.\n\n**Output**: block.\n\n**Algorithm:**\n\n1. Return a block with the following values:\n    1. Version: 1.\n    2. Height: 1.\n    3. Previous block ID: 32 zero bytes.\n    4. Timestamp: the input time.\n    5. [Block commitment](data.md#block-commitment):\n        1. Transactions merkle root: [merkle binary tree hash](data.md#merkle-binary-tree) of the empty list.\n        2. Assets merkle root: [merkle patricia tree hash](data.md#merkle-patricia-tree) of the empty list.\n        3. Consensus program: the input consensus program.\n    6. [Block witness](data.md#block-witness): 0x00 (the empty string).\n    7. Transaction count: 0.\n    8. Transactions: none.\n\n\n\n### Accept block\n\n**Inputs:**\n\n1. block,\n2. current blockchain state.\n\n**Output:** true or false.\n\n**Affects:** Current blockchain state.\n\n**Algorithm:**\n\n1. [Evaluate](#evaluate-predicate) the [consensus program](data.md#consensus-program) of the blockchain state as a predicate using VM version 1 with the program arguments of the block witness initializing the data stack.\n2. [Validate the block](#validate-block) with respect to the current blockchain state; if invalid, halt and return false.\n3. [Apply the block](#apply-block) to the current blockchain state, yielding a new state.\n4. Replace the current blockchain state with the new state.\n5. Return true.\n\n\n\n### Check block is well-formed\n\n**Input:** block.\n\n**Output:** true or false.\n\n**Algorithm:**\n\n1. Test that the block can be parsed as a [block data structure](data.md#block); if not, halt and return false.\n2. Test that the block contains the list of transactions (e.g. serialized with [flags](data.md#block-serialization-flags) 0x03); otherwise, halt and return false.\n3. For each transaction in the block, test that the [transaction is well-formed](#check-transaction-is-well-formed); if any are not, halt and return false.\n4. Compute the [transactions merkle root](data.md#transactions-merkle-root) for the block.\n5. Test that the computed merkle tree hash equals the value recorded in the block’s commitment; if not, halt and return false.\n6. Return true.\n\n\n### Validate block\n\n**Inputs:**\n\n1. block,\n2. blockchain state.\n\n**Output:** true or false.\n\n**Algorithm:**\n\n1. Test that the [block is well-formed](#check-block-is-well-formed); if not, halt and return false.\n2. Test that the block’s version is greater or equal the block version in the blockchain state; if not, halt and return false.\n3. Test that the block contains the [block witness](data.md#block-witness) and the list of transactions (e.g. serialized with [flags](data.md#block-serialization-flags) 0x03); otherwise, halt and return false.\n4. If the block’s version is 1:\n    * Test that the [block commitment](data.md#block-commitment) contains only the fields defined in this version of the protocol; if it contains additional fields, halt and return false.\n    * Test that the [block witness](data.md#block-witness) contains only a program arguments field; if it contains additional fields, halt and return false.\n5. Test that the block’s [height](data.md#block) is one greater than the height of the blockchain state; if not, halt and return false.\n6. Test that the block’s [previous block ID](data.md#block) is equal to the [block ID](data.md#block-id) of the state; if not, halt and return false.\n7. Test that the block’s timestamp is greater than the timestamp of the blockchain state; if not, halt and return false.\n8. Let S be the input blockchain state.\n9. For each transaction in the block, in order:\n    1. [Validate the transaction](#validate-transaction) with respect to S; if invalid, halt and return false.\n    2. [Apply the transaction](#apply-transaction) to S, yielding a new state S′.\n    3. Test that [assets merkle root](data.md#assets-merkle-root) of S′ is equal to the assets merkle root declared in the block commitment; if not, halt and return false.\n    4. Replace S with S′.\n10. Return true.\n\n\n\n### Validate transaction\n\nA transaction is said to be *valid* with respect to a particular blockchain state if it is well formed and if the outputs it attempts to spend exist in the state, and it satisfies the predicates in those outputs. The transaction may or may not be valid with respect to a different blockchain state.\n\n**Inputs:**\n\n1. transaction,\n2. blockchain state.\n\n**Output:** true or false.\n\n**Algorithm:**\n\n1. Test that the [transaction is well-formed](#check-transaction-is-well-formed); if not, halt and return false.\n2. If the block version in the blockchain state is 1:\n    1. Test that transaction version equals 1. If it is not, halt and return false.\n3. If the transaction minimum time is greater than zero:\n    1. Test that the timestamp of the blockchain state is greater than or equal to the transaction minimum time; if not, halt and return false.\n4. If the transaction maximum time is greater than zero:\n    1. Test that the timestamp of the blockchain state is less than or equal to the transaction maximum time; if not, halt and return false.\n5. If all inputs in transaction are [issuance with asset version 1](data.md#asset-version-1-issuance-commitment), test if at least one of them has a non-empty nonce. If all have empty nonces, halt and return false.\n    * Note: this means that transaction uniqueness is guaranteed not only by spending inputs and issuance inputs with non-empty nonce, but also by future inputs of unknown asset versions. The future asset versions will provide rules enforcing transaction uniqueness.\n6. For each [issuance input with asset version 1](data.md#asset-version-1-issuance-commitment) and a non-empty nonce, test the following conditions. If any condition is not satisfied, halt and return false:\n    1. Both transaction minimum and maximum timestamps are not zero.\n    2. State’s timestamp is greater or equal to the transaction minimum timestamp.\n    3. State’s timestamp is less or equal to the transaction maximum timestamp.\n    4. Input’s [issuance hash](data.md#issuance-hash) does not appear in the state’s issuance memory.\n7. For every input in the transaction with asset version equal 1, [validate that input](#validate-transaction-input) with respect to the blockchain state; if invalid, halt and return false.\n8. Return true.\n\n\n\n### Validate transaction input\n\n**Inputs:**\n\n1. transaction input with asset version 1,\n2. blockchain state.\n\n**Output:** true or false.\n\n**Algorithm:**\n\n1. If the input is an *issuance*:\n    1. Test that the *initial block ID* declared in the witness matches the initial block ID of the current blockchain; if not, halt and return false.\n    2. Compute [asset ID](data.md#asset-id) from the initial block ID, asset version 1, and the *VM version* and *issuance program* declared in the witness. If the resulting asset ID is not equal to the declared asset ID in the issuance commitment, halt and return false.\n    3. [Evaluate](#evaluate-predicate) its [issuance program](data.md#issuance-program), for the VM version specified in the issuance commitment and with the [input witness](data.md#transaction-input-witness) [program arguments](data.md#program-arguments); if execution fails, halt and return false.\n2. If the input is a *spend*:\n    1. Check if the state contains the input’s [output ID](data.md#output-id). If the output ID does not exist in the state, halt and return false.\n    2. [Evaluate](#evaluate-predicate) the previous output’s control program, for the VM version specified in the previous output and with the [input witness](data.md#transaction-input-witness) program arguments.\n    3. If the evaluation returns false, halt and return false.\n3. Return true.\n\n\n### Check transaction is well-formed\n\n**Input:** transaction.\n\n**Output:** true or false.\n\n**Algorithm:**\n\n1. Test that the transaction can be parsed as a [transaction data structure](data.md#transaction); if not, halt and return false.\n2. Test that the transaction has at least one input; if not, halt and return false.\n3. Ensure that each [input commitment](data.md#transaction-input-commitment) appears only once; if there is a duplicate, halt and return false.\n4. If the transaction maximum time is greater than zero test that it is greater than or equal to the minimum time; if not, halt and return false.\n5. If transaction version equals 1, check each of the following conditions. If any are not satisfied, halt and return false:\n    1. [Transaction common fields](data.md#transaction-common-fields) string must contain only the fields defined in this version of the protocol (no additional data included).\n    2. Every [input](data.md#transaction-input) [asset version](data.md#asset-version) must equal 1.\n    3. Every [output](data.md#transaction-output) [asset version](data.md#asset-version) must equal 1.\n    4. For each input, test that the [input commitment](data.md#transaction-input-commitment) contains only the fields defined in this version of the protocol (no additional data included).\n    5. For each output, test that the [output commitment](data.md#transaction-output-commitment) contains only the fields defined in this version of the protocol (no additional data included); if not, halt and return false.\n    6. Test that all VM versions in the transaction are 1 (including the VM version in the [issuance input witness](data.md#asset-version-1-issuance-witness)); if not, halt and return false.\n    7. Every control program must not contain any [expansion opcodes](vm1.md#expansion-opcodes).\n    8. Note: unknown suffixes (additional fields) in [transaction common witness](data.md#transaction-common-witness), [input witnesses](data.md#transaction-input-witness) and [output witnesses](data.md#transaction-output-witness) are not checked here; they are permitted.\n6. For inputs and outputs with asset version 1:\n    1. For each asset on these inputs and outputs:\n        1. Sum the input amounts of that asset and sum the output amounts of that asset.\n        2. Test that both input and output sums are less than 2\u003csup\u003e63\u003c/sup\u003e; if not, halt and return false.\n        3. Test that the input sum equals the output sum; if not, halt and return false.\n        4. Check that there is at least one input with that asset ID; if not, halt and return false.\n7. Return true.\n\nNote: requirement for the input and output sums to be below 2\u003csup\u003e63\u003c/sup\u003e implies that all intermediate sums and individual amounts must also be below 2\u003csup\u003e63\u003c/sup\u003e which simplifies implementation that uses native 64-bit unsigned integers.\n\n\n\n### Apply block\n\n**Inputs:**\n\n1. block,\n2. blockchain state.\n\n**Output:** blockchain state.\n\n**Algorithm:**\n\n1. Let S be the input blockchain state.\n2. For each transaction in the block:\n    1. [Apply the transaction](#apply-transaction) to S, yielding a new state S′.\n    2. Replace S with S′.\n3. Replace the block header in S with the input block header, yielding a new state S′.\n4. Replace S with S′.\n5. Remove elements of the issuance memory in S where the expiration timestamp is less than the block’s timestamp, yielding a new state S′.\n6. Return S′.\n\n### Apply Transaction\n\n**Inputs:**\n\n1. transaction,\n2. blockchain state.\n\n**Output:** blockchain state.\n\n**Algorithm:**\n\n1. For each spend input with asset version 1 in the transaction:\n    1. Delete the previous [output ID](data.md#output-id) from S, yielding a new state S′.\n    2. Replace S with S′.\n2. For each output with asset version 1 in the transaction:\n    1. Add that output’s [output ID](data.md#output-id) to S, yielding a new state S′.\n    2. Replace S with S′.\n3. For all [asset version 1 issuance inputs](data.md#asset-version-1-issuance-commitment) with non-empty *nonce* string:\n    1. Compute the [issuance hash](data.md#issuance-hash) H.\n    2. Add (H, transaction maximum timestamp) to the issuance memory in S, yielding a new state S′.\n    3. Replace S with S′.\n4. Return S.\n\n\n### Evaluate predicate\n\n**Inputs:**\n\n1. VM version,\n2. program,\n3. list of program arguments.\n\n**Output:** true or false.\n\n**Algorithm:**\n\n1. If the [VM version](vm1.md#versioning) is \u003e 1, halt and return true.\n2. [Create a VM with initial state](vm1.md#vm-state).\n3. [Prepare VM](vm1.md#prepare-vm).\n4. Set the VM’s program to the predicate program and execute [Verify Predicate](vm1.md#verify-predicate) operation. If it fails, halt and return false.\n5. Return true.\n\n\n"},{"Url":"/docs/1.1/protocol/specifications/vm1.md","Body":"# Virtual Machine Specification\n\n* [Introduction](#introduction)\n* [Versioning](#versioning)\n* [Program format](#program-format)\n* [Execution context](#execution-context)\n* [VM state](#vm-state)\n* [Operations](#operations)\n* [Instruction cost](#instruction-cost)\n* [Value types](#value-types)\n* [Failure conditions](#failure-conditions)\n* [Instructions](#instructions)\n  * [Instructions pushing data on stack](#instructions-pushing-data-on-stack)\n  * [Control flow operators](#control-flow-operators)\n  * [Stack control operators](#stack-control-operators)\n  * [Splice operators](#splice-operators)\n  * [Bitwise operators](#bitwise-operators)\n  * [Logical and numeric operators](#logical-and-numeric-operators)\n  * [Cryptographic instructions](#cryptographic-instructions)\n  * [Introspection instructions](#introspection-instructions)\n  * [Expansion opcodes](#expansion-opcodes)\n* [References](#references)\n\n\n## Introduction\n\nThe Chain Protocol uses a bytecode language to express short programs used to authenticate blockchain activity. Programs are used in [two contexts](#execution-context): transactions and blocks.\n\nPrograms are executed in a stack-based [virtual machine](#vm-state).\n\n* First, the program arguments are pushed on the stack one after the other (so that the last argument is on the top of the stack).\n* Then the VM executes the actual predicate program (control program, issuance program or consensus program) encoded as a sequence of **opcodes**.\n* If execution halts early (because of a disabled opcode, [FAIL](#fail), a [VERIFY](#verify) failure, or exceeding the run limit), validation fails.\n* If execution completes successfully, the top stack value is inspected. If it’s zero, validation fails, otherwise validation succeeds.\n\nEach instruction has a built-in [run cost](#instruction-cost) that counts against a built-in *run limit* to protect the network from resource exhaustion. Currently, the protocol [mandates](#vm-state) a specific run limit. Future VM versions will provide more fine-grained control over run limit by operators and users of the network.\n\n## Versioning\n\nVirtual machines for control and issuance programs inside transactions are versioned to enable future improvements using varint-encoded version number in the commitment strings where these programs are specified. Program arguments are not explicitly versioned, their semantics are defined by the VM version of the associated issuance and control program.\n\nNodes ignore programs with unknown versions, treating them like “anyone can issue/spend.” To discourage use of unassigned versions, block signers refuse to include transactions that use unassigned VM versions.\n\nBlocks do not specify VM version explicitly. [Consensus programs](data.md#consensus-program) use VM version 1 with additional [block-context restrictions](#block-context) applied to some instructions. Upgrades to block authentication can be made via additional fields in the block commitment string.\n\n\n## Program format\n\nA program comprises a sequence of zero or more **instructions**. Each instruction contains a one-byte **opcode** followed by zero or more **continuation bytes**, determined by the operation. Data in this format is informally known as **bytecode**.\n\nInstructions that push arbitrary data onto the stack use one of the [PUSHDATA](#pushdata) opcode followed by a variable-length binary string to be placed on stack. The length of the string is either encoded within the opcode itself, or prepended to the string. \n\nAll other instructions are encoded simply by a single-byte opcode. The protocol reserves unassigned opcodes for future extensions.\n\n\n## Execution context\n\nA program executes in a context, either a *block* or a *transaction*. Some instructions have different meaning based on the context.\n\nTransactions use [control programs](data.md#control-program) to define predicates governing spending of an asset in the next transaction, *issuance programs* for predicates authenticating issuance of an asset, and *program arguments* to provide input data for the predicates in output and issuance programs.\n\nBlocks use [consensus programs](data.md#consensus-program) to define predicates for signing the next block and *program arguments* to provide input data for the predicate in the previous block. Consensus programs have restricted functionality and do not use version tags. Some instructions (such as [ASSET](#asset) or [CHECKOUTPUT](#checkoutput)) that do not make sense within a context of signing a block are disabled and cause an immediate validation failure.\n\n### Block context\n\nBlock context is defined by the block necessary for [BLOCKHASH](#blockhash), [NEXTPROGRAM](#nextprogram) and [BLOCKTIME](#blocktime) execution.\n\nInstruction [PROGRAM](#program) behaves differently than in transaction context.\n\nExecution of any of the following instructions results in immediate failure:\n\n* [TXSIGHASH](#txsighash)\n* [CHECKOUTPUT](#checkoutput)\n* [ASSET](#asset)\n* [AMOUNT](#amount)\n* [MINTIME](#mintime)\n* [MAXTIME](#maxtime)\n* [TXREFDATAHASH](#txrefdatahash)\n* [REFDATAHASH](#refdatahash)\n* [INDEX](#index)\n* [OUTPUTID](#outputid)\n* [NONCE](#nonce)\n\n\n### Transaction context\n\nTransaction context is defined by the pair of the entire transaction and the index of one of its inputs indicating the “current input”.\n\nExecution of any of the following instructions results in immediate failure:\n\n* [BLOCKHASH](#blockhash)\n* [NEXTPROGRAM](#nextprogram)\n* [BLOCKTIME](#blocktime)\n\n\n## VM state\n\n**VM State** is a tuple consisting of:\n\n1. Program\n2. Program Counter (PC)\n3. Data Stack\n4. Alt Stack\n5. Run Limit\n6. Execution Context:\n    a. Block\n    b. (Transaction, Input Index)\n\n**Initial State** has empty stacks, uninitialized program, PC set to zero, and *run limit* set to 10,000.\n\n**Program** is a sequence of instructions, encoded as bytecode.\n\n**PC** is a 32-bit unsigned integer used as a pointer to an opcode within a program.\n\n**Data Stack** and **Alt Stack** are stacks of binary strings.\n\n**Run Limit** is a built-in 64-bit integer specifying remaining total cost of execution. Run limit is decreased by the cost of each instruction and also affected by data added to and removed from the data stack and alt stack. Every byte added to either stack costs 1 unit, and every byte removed from either stack refunds 1 unit. (This includes explicit additions and removals by stack-manipulating instructions such as PUSHDATA and DROP, and also implicit additions and removals as when other instructions consume arguments and produce results.)\n\n**Execution Context** is either a [block context](#block-context) or [transaction context](#transaction-context).\n\n\n## Operations\n\nThe VM has two high-level operations: [Prepare VM](#prepare-vm) and [Verify Predicate](#verify-predicate).\n\n### Prepare VM\n\nPlaces program arguments on the data stack one after another so that last argument is on the top of the stack. Additions to the stack are counted against the run limit using the [standard memory cost](#standard-memory-cost) function.\n\n### Verify predicate\n\nInitializes VM with a predicate program (e.g. a [control program](data.md#control-program)) and begins its execution with PC set to zero.\n\nAt the beginning of each execution step, the PC is checked. If it is less than the length of the program, VM reads the opcode at that byte position in the program and executes a corresponding instruction. Instructions are executed as described in the [Instructions](#instructions) section. The run limit is decreased or increased according to the instruction’s *run cost*. If the instruction’s run cost exceeds the current run limit, the instruction is not executed and execution fails immediately.\n\nIf the PC is equal to or greater than the length of the program at the beginning of an execution step, execution is complete, and the top value of the data stack is checked and interpreted as a boolean. If it is `false`, or if the data stack is empty, verification fails; otherwise, verification succeeds. (Note: The data stack may contain any number of elements when execution finishes; there is no \"clean stack\" requirement. The alt stack also can be non-empty upon completion.)\n\nAfter each step, the PC is incremented by the size of the current instruction.\n\n\n## Instruction cost\n\nEvery instruction has a cost that affects VM *run limit*. Total instruction cost consists of *execution cost* and *memory cost*. Execution cost always reduces remaining run limit, while memory usage cost can be refunded (increasing the run limit) when previously used memory is released during VM execution.\n\n### Execution cost\n\nEvery instruction has a constant or variable execution cost. Simple instructions such as [ADD](#add) have constant execution cost. More complex instructions like [SHA3](data.md#sha3) or [CHECKSIG](#checksig) have cost depending on amount of data that must be processed.\n\nIn order to account for spikes in memory usage some instructions (e.g. [CAT](#cat)) define a cost and a refund: before execution begins the cost is applied to the run limit, then after completion refund is applied together with run limit changes due to memory usage.\n\n### Memory cost\n\nMemory cost is incurred when additional memory is allocated. This cost is fully refundable when the memory is released. Most operations allocate and release memory by using the data stack, but some others also use the alt stack ([TOALTSTACK](#toaltstack), [FROMALTSTACK](#fromaltstack)) and the system memory for new VM instances ([CHECKPREDICATE](#checkpredicate)).\n\n### Standard memory cost\n\nMost instructions use only the data stack by removing some items and then placing some items back on the stack. For these operations, we define the *standard memory cost* applied as follows:\n\n1. Instruction’s memory cost value is set to zero.\n2. For each item removed from the data stack, instruction’s memory cost is decreased by 8+L where L is the length of the item in bytes.\n3. For each item added to the data stack the cost is increased by 8+L where L is the length of the item in bytes.\n\n\n## Value types\n\nAll items on the data and alt stacks are binary strings. Some instructions accept or return items of other types. When values of those types are pushed to or popped from the data stack, they are coerced to and from strings in accordance with the rules specified below.\n\nIn the stack diagrams accompanying the definition of each operation, `x` and `y` denote [numbers](#vm-number), `m` and `n` denote non-negative [numbers](#vm-number), and `p` and `q` denote [booleans](#vm-boolean). If coercion fails (or if stack items designated as `m` or `n` coerce to negative numbers), the operation fails.\n\n### VM String\n\nAn ordered sequence of 0 or more bytes.\n\nIn this document, single bytes are represented in hexadecimal form with a `0x` base prefix, i.e. `0x00` or `0xff`.\n\nIn this document, strings are represented as sequences of unprefixed hexadecimal bytes, separated by spaces, and enclosed in double quotation marks, i.e. `\"\"`, `\"01\"`, or `\"ff ff\"`.\n\n### VM Boolean\n\nA boolean value (`true` or `false`).\n\n#### String to Boolean\n\nAny string can be coerced to a boolean.\n\nStrings coerce to `true` if and only if they contain any non-zero bytes. Therefore, for example, `\"\"`, `\"00\"`, and `\"00 00\"` coerce to `false`.\n\n#### Boolean to String\n\n`false` coerces to an empty string `\"\"` (the same representation as the number 0), `true` coerces to a one-byte string `\"01\"` (the same representation as the number 1).\n\n### VM Number\n\nAn integer greater than or equal to –2\u003csup\u003e63\u003c/sup\u003e, and less than 2\u003csup\u003e63\u003c/sup\u003e.\n\nCertain arithmetic operations use conservative bounds checks (explicitly specified below) on their inputs to prevent the output from being outside the legal range. If one of these bounds checks fails, execution fails.\n\n#### String to Number\n\n1. If the string is longer than 8 bytes, fail execution.\n2. If the string is shorter than 8 bytes, right-pad it by appending `0x00` bytes to get an 8-byte string.\n3. Interpret the 8-byte string as a [little-endian](https://en.wikipedia.org/wiki/Endianness#Little-endian) 64-bit integer, using [two's complement representation](https://en.wikipedia.org/wiki/Two%27s_complement).\n\n#### Number to String\n\n1. Create an 8-byte string matching the representation of the number as a [little-endian](https://en.wikipedia.org/wiki/Endianness#Little-endian) 64-bit integer, using [two's complement representation](https://en.wikipedia.org/wiki/Two%27s_complement) for negative integers.\n2. Trim the string by removing any `0x00` bytes from the right side.\n\n\n\nValue          | String (hexadecimal)        | Size in bytes\n---------------|-----------------------------|------------------\n0              | `“”`                        | 0\n1              | `“01”`                      | 1\n–1             | `“ff ff ff ff ff ff ff ff”` | 8\n2^63 - 1 (max) | `“ff ff ff ff ff ff ff 7f”` | 8\n-2^63 (min)    | `“00 00 00 00 00 00 00 80”` | 8\n\n## Failure conditions\n\nValidation fails when:\n\n* an instruction is executed that expects more elements on the stack than are present (see stack diagrams below under [Instructions](#instructions))\n* a [VERIFY](#verify) instruction fails\n* a [FAIL](#fail) instruction is executed\n* the run limit is below the value required by the current instruction\n* an invalid encoding is detected for keys or [signatures](data.md#signature)\n* coercion fails for [numbers](#vm-number)\n* a bounds check fails for one of the [splice](#splice-operators) or [numeric](#logical-and-numeric-operators) instructions\n* the program execution finishes with an empty data stack\n* the program execution finishes with a [false](#vm-boolean) item on the top of the data stack\n* an instruction specifies that it fails (see below)\n\n\n## Instructions\n\nThis section specifies the behavior of every instruction. Each instruction has a name and a run cost that modifies the VM’s run limit.\n\nThe cost of an instruction may be fixed or variable based on the amount of data being processed. In the tables below, the notation L or L\u003csub\u003ex\u003c/sub\u003e is used to indicate the length in bytes of a given binary string. Positive cost increases reduces (“consumes”) run limit, negative cost increases (“refunds”) run limit.\n\nWhen the instruction cost is specified as a single value, it is applied to the run limit *before* the instruction is executed. If two values represent a cost (such as `1; -1` or `1; standard memory cost`) that means that the first value is applied *before* executing the instruction and the second value is applied *after*.\n\nExecution immediately halts if the run limit is insufficient to apply the cost of the instruction. In such case, the run limit is left unchanged (instead of becoming negative) and the execution halts. If the instruction defines two cost values (before and after the execution), and the first one did not cause the VM to halt, then its effects are not reversed. E.g. if the instruction cost is defined as `2;6` and the run limit is 5, then the first cost (2) is applied successfully (run limit becomes 3) and the second cost (6) halts execution leaving the run limit at 3. This value then can be refunded to the parent VM of a [CHECKPREDICATE](#checkpredicate) instruction.\n\nStack diagrams tell how top items of the data stack are replaced with new items. E.g. a stack diagram `(a b → c d)` says that the topmost item `b` and preceding item `a` are removed from the data stack and items `c` and `d` are pushed one after another.\n\n### Instructions pushing data on stack\n\n#### FALSE\n\nAlias: `OP_0`.\n\nCode  | Stack Diagram     | Cost\n------|-------------------|-----------------------------------------------------\n0x00  | (∅ → 0)           | 1 + [standard memory cost](#standard-memory-cost)\n\nPushes an empty string (the [VM number](#vm-number) 0) to the data stack.\n\n\n#### PUSHDATA\n\nCode          | Stack Diagram   | Cost\n--------------|-----------------|-----------------------------------------------------\n0x01 to 0x4e  | (∅ → a)         | 1 + [standard memory cost](#standard-memory-cost)\n\nEach opcode **0x00 ≤ n ≤ 0x4b** is followed by `n` bytes of data to be pushed onto the data stack as a single [VM string](#vm-string). So opcode 0x01 is followed by 1 byte of data, 0x09 by 9 bytes, and so on up to 0x4b (75 bytes).\n\nOpcode **0x4c** is followed by a 1-byte length prefix encoding a length `n`, then `n` bytes of data to push (supports up to 255 bytes).\n\nOpcode **0x4d** is followed by a 2-byte little-endian length prefix encoding a length `n`, then `n` bytes of data to push (supports up to 65535 bytes).\n\nOpcode **0x4e** is followed by a 4-byte little-endian length prefix encoding a length `n`, then `n` bytes of data to push (supports up to 4294967295 bytes).\n\nEach of these operations fails if they are not followed by the expected number of bytes of data.\n\n#### 1NEGATE\n\nCode  | Stack Diagram   | Cost\n------|-----------------|-----------------------------------------------------\n0x4f  | (∅ → –1)        | 1 + [standard memory cost](#standard-memory-cost)\n\nPushes `\"ff ff ff ff ff ff ff ff\"` (the [VM number](#vm-number) -1) onto the data stack.\n\n\n#### OP\\_1 to OP\\_16\n\nName | Code  | Stack Diagram  | Cost                                              | Description\n-----|-------|----------------|---------------------------------------------------|---------------\nOP_1 | 0x51  | (∅ → 1)        | 1 + [standard memory cost](#standard-memory-cost) | Pushes [number](#vm-number) 1 on the data stack.\nOP_2 | 0x52  | (∅ → 2)        | 1 + [standard memory cost](#standard-memory-cost) | Pushes [number](#vm-number) 2 on the data stack.\nOP_3 | 0x53  | (∅ → 3)        | 1 + [standard memory cost](#standard-memory-cost) | Pushes [number](#vm-number) 3 on the data stack.\nOP_4 | 0x54  | (∅ → 4)        | 1 + [standard memory cost](#standard-memory-cost) | Pushes [number](#vm-number) 4 on the data stack.\nOP_5 | 0x55  | (∅ → 5)        | 1 + [standard memory cost](#standard-memory-cost) | Pushes [number](#vm-number) 5 on the data stack.\nOP_6 | 0x56  | (∅ → 6)        | 1 + [standard memory cost](#standard-memory-cost) | Pushes [number](#vm-number) 6 on the data stack.\nOP_7 | 0x57  | (∅ → 7)        | 1 + [standard memory cost](#standard-memory-cost) | Pushes [number](#vm-number) 7 on the data stack.\nOP_8 | 0x58  | (∅ → 8)        | 1 + [standard memory cost](#standard-memory-cost) | Pushes [number](#vm-number) 8 on the data stack.\nOP_9 | 0x59  | (∅ → 9)        | 1 + [standard memory cost](#standard-memory-cost) | Pushes [number](#vm-number) 9 on the data stack.\nOP_10 | 0x5a | (∅ → 10)       | 1 + [standard memory cost](#standard-memory-cost) | Pushes [number](#vm-number) 10 on the data stack.\nOP_11 | 0x5b | (∅ → 11)       | 1 + [standard memory cost](#standard-memory-cost) | Pushes [number](#vm-number) 11 on the data stack.\nOP_12 | 0x5c | (∅ → 12)       | 1 + [standard memory cost](#standard-memory-cost) | Pushes [number](#vm-number) 12 on the data stack.\nOP_13 | 0x5d | (∅ → 13)       | 1 + [standard memory cost](#standard-memory-cost) | Pushes [number](#vm-number) 13 on the data stack.\nOP_14 | 0x5e | (∅ → 14)       | 1 + [standard memory cost](#standard-memory-cost) | Pushes [number](#vm-number) 14 on the data stack.\nOP_15 | 0x5f | (∅ → 15)       | 1 + [standard memory cost](#standard-memory-cost) | Pushes [number](#vm-number) 15 on the data stack.\nOP_16 | 0x60 | (∅ → 16)       | 1 + [standard memory cost](#standard-memory-cost) | Pushes [number](#vm-number) 16 on the data stack.\n\n\n\n### Control Flow Operators\n\n#### JUMP\n\nCode  | Stack Diagram     | Cost\n------|-------------------|----------------------------\n0x63  | (∅ → ∅)           | 1\n\nFollowed by a 4-byte unsigned integer `address`.\n\nSets the PC to `address`.\n\nFails if not followed by 4 bytes.\n\n\n#### JUMPIF\n\nCode  | Stack Diagram     | Cost\n------|-------------------|----------------------------\n0x64  | (p → ∅)           | 1; [standard memory cost](#standard-memory-cost)\n\nFollowed by a 4-byte unsigned integer `address`.\n\nPops a [boolean](#vm-boolean) from the data stack. If it is `true`, sets the PC to `address`. If it is `false`, does nothing.\n\nFails if not followed by 4 bytes.\n\n\n#### VERIFY\n\nCode  | Stack Diagram     | Cost\n------|-------------------|----------------------------\n0x69  | (p → ∅)           | 1; [standard memory cost](#standard-memory-cost)\n\nFails execution if the top item on the data stack is [false](#vm-boolean). Otherwise, removes the top item.\n\n\n#### FAIL\n\nCode  | Stack Diagram     | Cost\n------|-------------------|----------------------------\n0x6a  | (∅ → ∅)           | 1\n\nFails execution unconditionally.\n\n\n\n#### CHECKPREDICATE\n\nCode  | Stack Diagram            | Cost\n------|--------------------------|----------------------------\n0xc0  | (n predicate limit → q)  | 256 + limit; [standard memory cost](#standard-memory-cost) – 256 + 64 – leftover\n\nIf the remaining run limit is less than 256, execution fails immediately.\n\n1. Pops 3 items from the data stack: `limit`, `predicate` and `n`.\n2. Coerces `limit` to an [integer](#vm-number).\n3. Coerces `n` to an [integer](#vm-number).\n4. If `limit` equals zero, sets it to the VM's remaining run limit minus 256.\n5. Reduces VM’s run limit by `256 + limit`.\n6. Instantiates a new VM instance (“child VM”) with its run limit set to `limit`.\n7. Moves the top `n` items from the parent VM’s data stack to the child VM’s data stack without incurring run limit refund or charge of their [standard memory cost](#standard-memory-cost) in either VM. The order of the moved items is unchanged. The memory cost of these items will be refunded when the child VM pops them, or when the child VM is destroyed and its parent VM is refunded.\n8. Child VM evaluates the predicate and pushes `true` to the parent VM data stack if the evaluation did not fail and the child VM’s data stack is non-empty with a `true` value on top (this implements the same semantics as for the top-level [verify predicate](#verify-predicate) operation). It pushes `false` otherwise. Note that the parent VM does not fail when the child VM exhausts its run limit or otherwise fails.\n9. After the child VM finishes execution (normally or due to a failure), the parent VM’s run limit is refunded with a `leftover` value computed as a sum of the following values:\n    1. Remaining run limit of the child VM.\n    2. [Standard memory cost](#standard-memory-cost) of all items left on the child VM’s data stack.\n    3. [Standard memory cost](#standard-memory-cost) of all items left on the child VM’s alt stack.\n10. The total post-execution cost is then calculated as a sum of the following values:\n    1. Refund of the [standard memory cost](#standard-memory-cost) of the top three items on the parent’s data stack (`limit`, `predicate`, `n`).\n    2. –256 (refunds cost of allocating memory for the child VM).\n    3. +64 (cost of creating the child VM).\n    4. `–leftover` (refund for the unused run limit and released memory within the child VM).\n\nFailure conditions:\n\n* `n` is not a non-negative [number](#vm-number), or\n* there are less than `n+3` items on the data stack (including `n`, `predicate`, `limit`), or\n* `limit` is not a non-negative [number](#vm-number), or\n* the run limit is less than 256, or\n* the run limit is less than `256+limit`.\n\n\n### Stack control operators\n\n\n#### TOALTSTACK\n\nCode  | Stack Diagram      | Cost\n------|--------------------|----------------------------\n0x6b  | (a → ∅)            | 2\n\nMoves the top item from the data stack to the alt stack.\n\n\n#### FROMALTSTACK\n\nCode  | Stack Diagram      | Cost\n------|--------------------|----------------------------\n0x6c  | (∅ → a)            | 2\n\nMoves the top item from the alt stack to the data stack.\n\nFails if the alt stack is empty.\n\n\n#### 2DROP\n\nCode  | Stack Diagram   | Cost\n------|-----------------|----------------------------\n0x6d  | (a b → ∅)       | 2 + [standard memory cost](#standard-memory-cost)\n\nRemoves top 2 items from the data stack.\n\n\n#### 2DUP\n\nCode  | Stack Diagram         | Cost\n------|-----------------------|----------------------------\n0x6e  | (a b → a b a b)       | 2 + [standard memory cost](#standard-memory-cost)\n\nDuplicates top 2 items on the data stack.\n\n\n#### 3DUP\n\nCode  | Stack Diagram         | Cost\n------|-----------------------|----------------------------\n0x6f  | (a b c → a b c a b c) | 3 + [standard memory cost](#standard-memory-cost)\n\nDuplicates top 3 items on the data stack.\n\n\n#### 2OVER\n\nCode  | Stack Diagram           | Cost\n------|-------------------------|----------------------------\n0x70  | (a b c d → a b c d a b) | 2 + [standard memory cost](#standard-memory-cost)\n\nDuplicates two items below the top two items on the data stack.\n\n\n#### 2ROT\n\nCode  | Stack Diagram               | Cost\n------|-----------------------------|----------------------------\n0x71  | (a b c d e f → c d e f a b) | 2\n\nMoves 2 items below the top 4 items on the data stack to the top of the stack.\n\n\n#### 2SWAP\n\nCode  | Stack Diagram               | Cost\n------|-----------------------------|----------------------------\n0x72  | (a b c d → c d a b)         | 2\n\nMoves 2 items below the top 2 items on the data stack to the top of the stack.\n\n\n#### IFDUP\n\nCode  | Stack Diagram               | Cost\n------|-----------------------------|----------------------------\n0x73  | (a → a \\| a a)              | 1 + [standard memory cost](#standard-memory-cost)\n\nDuplicates the top item only if it’s not [false](#vm-boolean).\n\n\n#### DEPTH\n\nCode  | Stack Diagram               | Cost\n------|-----------------------------|----------------------------\n0x74  | (∅ → x)                     | 1; [standard memory cost](#standard-memory-cost)\n\nAdds the size of the data stack encoded as a [VM number](#vm-number).\n\n\n#### DROP\n\nCode  | Stack Diagram               | Cost\n------|-----------------------------|----------------------------\n0x75  | (a → ∅)                     | 1; [standard memory cost](#standard-memory-cost)\n\nRemoves the top item from the data stack.\n\n\n#### DUP\n\nCode  | Stack Diagram               | Cost\n------|-----------------------------|----------------------------\n0x76  | (a → a a)                   | 1 + [standard memory cost](#standard-memory-cost)\n\nDuplicates the top item on the data stack.\n\n\n#### NIP\n\nCode  | Stack Diagram               | Cost\n------|-----------------------------|----------------------------\n0x77  | (a b → b)                   | 1 + [standard memory cost](#standard-memory-cost)\n\nRemoves the item below the top one on the data stack.\n\n\n#### OVER\n\nCode  | Stack Diagram               | Cost\n------|-----------------------------|----------------------------\n0x78  | (a b → a b a)               | 1 + [standard memory cost](#standard-memory-cost)\n\nCopies the second from the top item to the top of the data stack.\n\n\n#### PICK\n\nCode  | Stack Diagram               | Cost\n------|-----------------------------|----------------------------\n0x79  | (a\u003csub\u003en\u003c/sub\u003e ... a\u003csub\u003e1\u003c/sub\u003e a\u003csub\u003e0\u003c/sub\u003e n → a\u003csub\u003en\u003c/sub\u003e ... a\u003csub\u003e1\u003c/sub\u003e a\u003csub\u003e0\u003c/sub\u003e a\u003csub\u003en\u003c/sub\u003e)  | 2 + [standard memory cost](#standard-memory-cost)\n\nCopies `n+2`th item from the top to the top of the data stack.\n\nFails if the top item is not a valid non-negative number or there are fewer than `n+2` items on the stack.\n\n\n#### ROLL\n\nCode  | Stack Diagram               | Cost\n------|-----------------------------|----------------------------\n0x7a  | (a\u003csub\u003en\u003c/sub\u003e ... a\u003csub\u003e1\u003c/sub\u003e a\u003csub\u003e0\u003c/sub\u003e n → a\u003csub\u003en-1\u003c/sub\u003e ... a\u003csub\u003e1\u003c/sub\u003e a\u003csub\u003e0\u003c/sub\u003e a\u003csub\u003en\u003c/sub\u003e)  | 2 + [standard memory cost](#standard-memory-cost)\n\nMoves `n+2`th item from the top to the top of the data stack.\n\nFails if the top item is not a valid non-negative number or there are fewer than `n+2` items on the stack.\n\n\n#### ROT\n\nCode  | Stack Diagram               | Cost\n------|-----------------------------|----------------------------\n0x7b  | (a b c → b c a)             | 2\n\nMoves the third item from the top to the top of the data stack.\n\n\n#### SWAP\n\nCode  | Stack Diagram               | Cost\n------|-----------------------------|----------------------------\n0x7c  | (a b → b a)                 | 1\n\nSwaps top two items on the data stack.\n\n\n#### TUCK\n\nCode  | Stack Diagram               | Cost\n------|-----------------------------|----------------------------\n0x7d  | (a b → b a b)               | 1 + [standard memory cost](#standard-memory-cost)\n\nTucks the second item from the top of the data stack with two copies of the top item.\n\n\n\n### Splice operators\n\n\n#### CAT\n\nCode  | Stack Diagram               | Cost\n------|-----------------------------|----------------------------\n0x7e  | (“a” “b” → “ab”)            | 4 + L\u003csub\u003ea\u003c/sub\u003e + L\u003csub\u003eb\u003c/sub\u003e; –(L\u003csub\u003ea\u003c/sub\u003e + L\u003csub\u003eb\u003c/sub\u003e) + [standard memory cost](#standard-memory-cost)\n\nConcatenates top two items on the data stack.\n\n\n#### SUBSTR\n\nCode  | Stack Diagram                    | Cost\n------|----------------------------------|----------------------------\n0x7f  | (string m n → substring) | 4 + size; –size + [standard memory cost](#standard-memory-cost)\n\nExtracts a substring of `string` of a given size `n` at a given offset `m`.\n\nFailure conditions:\n\n* `n` is not a [VM number](#vm-number), or\n* `n` is negative, or\n* `n` is greater than the byte size of the `string`, or\n* `m` is not a [VM number](#vm-number), or\n* `m` is not in range of [0, L\u003csub\u003estring\u003c/sub\u003e – size].\n\n\n#### LEFT\n\nCode  | Stack Diagram                   | Cost\n------|---------------------------------|----------------------------\n0x80  | (string n → prefix)          | 4 + size; –size + [standard memory cost](#standard-memory-cost)\n\nExtracts a prefix of `string` with the given size `n`.\n\nFailure conditions:\n\n* `n` is not a [VM number](#vm-number), or\n* `n` is negative, or\n* `n` is greater than the byte size of the `string`.\n\n#### RIGHT\n\nCode  | Stack Diagram                   | Cost\n------|---------------------------------|----------------------------\n0x81  | (string n → suffix)          | 4 + size; –size + [standard memory cost](#standard-memory-cost)\n\nExtracts a suffix of `string` with the given size `n`.\n\nFailure conditions:\n\n* `n` is negative, or\n* `n` is greater than the byte size of the `string`.\n\n\n#### SIZE\n\nCode  | Stack Diagram                   | Cost\n------|---------------------------------|----------------------------\n0x82  | (string → string n)          | 1; [standard memory cost](#standard-memory-cost)\n\nPushes the size of `string` encoded as a [number](#vm-number) `n` without removing `string` from the data stack.\n\n\n#### CATPUSHDATA\n\nCode  | Stack Diagram                | Cost\n------|------------------------------|----------------------------\n0x89  | (“a” “b” → “a pushdata(b)”)  | 4 + L\u003csub\u003ea\u003c/sub\u003e + L\u003csub\u003eb\u003c/sub\u003e; –(L\u003csub\u003ea\u003c/sub\u003e + L\u003csub\u003eb\u003c/sub\u003e) + [standard memory cost](#standard-memory-cost)\n\nAppends second string encoded as the most compact [PUSHDATA](#pushdata) instruction. This is used for building new programs piecewise.\n\n\n\n\n### Bitwise operators\n\n\n#### INVERT\n\nCode  | Stack Diagram                | Cost\n------|------------------------------|----------------------------\n0x83  | (a → ~a)                     | 1 + L\u003csub\u003ex\u003c/sub\u003e\n\nInverts bits in the first item on the data stack.\n\n\n#### AND\n\nCode  | Stack Diagram                | Cost\n------|------------------------------|----------------------------\n0x84  | (a b → a\u0026b)                  | 1 + min(L\u003csub\u003ea\u003c/sub\u003e,L\u003csub\u003eb\u003c/sub\u003e); [standard memory cost](#standard-memory-cost)\n\nBitwise AND operation. Longer item is truncated, keeping the prefix.\n\n\n#### OR\n\nCode  | Stack Diagram                | Cost\n------|------------------------------|----------------------------\n0x85  | (a b → a\\|b)                 | 1 + max(L\u003csub\u003ea\u003c/sub\u003e,L\u003csub\u003eb\u003c/sub\u003e); [standard memory cost](#standard-memory-cost)\n\nBitwise OR operation. Shorter item is zero-padded to the right.\n\n\n#### XOR\n\nCode  | Stack Diagram                | Cost\n------|------------------------------|----------------------------\n0x86  | (a b → a^b)                  | 1 + max(L\u003csub\u003ea\u003c/sub\u003e,L\u003csub\u003eb\u003c/sub\u003e); [standard memory cost](#standard-memory-cost)\n\nBitwise XOR operation. Shorter item is zero-padded to the right.\n\n\n#### EQUAL\n\nCode  | Stack Diagram                | Cost\n------|------------------------------|----------------------------\n0x87  | (a b → a == b)                 | 1 + min(L\u003csub\u003ea\u003c/sub\u003e,L\u003csub\u003eb\u003c/sub\u003e); [standard memory cost](#standard-memory-cost)\n\nPops two strings from the stack and compares them byte-by-byte. Pushes [true](#vm-boolean) if the strings are equal, [false](#vm-boolean) otherwise.\n\n\n#### EQUALVERIFY\n\nCode  | Stack Diagram                | Cost\n------|------------------------------|----------------------------\n0x88  | (a b → ∅)                    | 1 + min(L\u003csub\u003ea\u003c/sub\u003e,L\u003csub\u003eb\u003c/sub\u003e); [standard memory cost](#standard-memory-cost)\n\nSame as [EQUAL](#equal) [VERIFY](#verify). Pops two strings from the stack, compares them byte-by-byte, and fails execution if they are not equal.\n\n\n\n### Logical and numeric operators\n\n\n#### 1ADD\n\nCode  | Stack Diagram   | Cost\n------|-----------------|----------------------------\n0x8b  | (x → x+1)       | 2; [standard memory cost](#standard-memory-cost)\n\nPops a [number](#vm-number) from the data stack, adds 1 to it, and pushes the result to the data stack.\n\nFails if either of `x` or `x+1` is not a valid [VM number](#vm-number).\n\n\n#### 1SUB\n\nCode  | Stack Diagram   | Cost\n------|-----------------|----------------------------\n0x8c  | (x → x–1)       | 2; [standard memory cost](#standard-memory-cost)\n\nPops a [number](#vm-number) from the data stack, subtracts 1 from it, and pushes the result to the data stack.\n\nFails if either of `x` or `x-1` is not a valid [VM number](#vm-number).\n\n\n#### NEGATE\n\nCode  | Stack Diagram   | Cost\n------|-----------------|----------------------------\n0x8f  | (x → –x)        | 2; [standard memory cost](#standard-memory-cost)\n\nPops a [number](#vm-number) from the data stack, negates it, and pushes the result to the data stack.\n\nFails if either of `x` or `-x` is not a valid [VM number](#vm-number).\n\n#### ABS\n\nCode  | Stack Diagram   | Cost\n------|-----------------|----------------------------\n0x90  | (x → abs(x))    | 2; [standard memory cost](#standard-memory-cost)\n\nPops a [number](#vm-number) from the data stack, negates it if it is less than 0, and pushes the result to the data stack.\n\nFails if either of `x` or `abs(x)` is not a valid [VM number](#vm-number).\n\n\n#### NOT\n\nCode  | Stack Diagram   | Cost\n------|-----------------|----------------------------\n0x91  | (p → ~p)    | 2; [standard memory cost](#standard-memory-cost)\n\nPops a [boolean](#vm-boolean) from the data stack, negates it, and pushes the result to the data stack.\n\n\n#### 0NOTEQUAL\n\nCode  | Stack Diagram   | Cost\n------|-----------------|----------------------------\n0x92  | (x → x ≠ 0)     | 2; [standard memory cost](#standard-memory-cost)\n\nPops a [number](#vm-number) from the data stack, and results in `false` if the number is equal to 0 and `true` otherwise. Pushes the result to the data stack.\n\nFails if `x` is not a valid [VM number](#vm-number).\n\n\n#### ADD\n\nCode  | Stack Diagram   | Cost\n------|-----------------|----------------------------\n0x93  | (x y → x+y)     | 2; [standard memory cost](#standard-memory-cost)\n\nPops two [numbers](#vm-number) from the data stack, adds them, and pushes the result to the data stack.\n\nFails if any of `x`, `y`, or `x+y` is not a valid [VM number](#vm-number).\n\n\n#### SUB\n\nCode  | Stack Diagram   | Cost\n------|-----------------|----------------------------\n0x94  | (x y → x–y)     | 2; [standard memory cost](#standard-memory-cost)\n\nPops two [numbers](#vm-number) from the data stack, takes their difference, and pushes the result to the data stack.\n\nFails if any of `x`, `y`, or `x-y` is not a valid [VM number](#vm-number).\n\n\n#### MUL\n\nCode  | Stack Diagram   | Cost\n------|-----------------|----------------------------\n0x95  | (x y → x·y)     | 8; [standard memory cost](#standard-memory-cost)\n\nPops two [numbers](#vm-number) from the data stack, multiplies them, and pushes the result to the data stack.\n\nFails if any of `x`, `y`, or `x·y` is not a valid [VM number](#vm-number).\n\n\n#### DIV\n\nCode  | Stack Diagram   | Cost\n------|-----------------|----------------------------\n0x96  | (x y → x/y)     | 8; [standard memory cost](#standard-memory-cost)\n\nPops two [numbers](#vm-number) from the data stack, divides them rounding toward zero to an integer, and pushes the result to the data stack.\n\nFails if either of `x` or `y` is not a valid [VM number](#vm-number), or if `y` is zero.\n\n\n#### MOD\n\nCode  | Stack Diagram   | Cost\n------|-----------------|----------------------------\n0x97  | (x y → x mod y) | 8; [standard memory cost](#standard-memory-cost)\n\nPops two [numbers](#vm-number) from their data stack, determines the remainder of `x` divided by `y`, and pushes the result to the data stack. A non-zero result has the same sign as the divisor.\n\nExample     | Result\n------------|--------\n12 mod 10   | 2\n–12 mod 10  | 8\n12 mod –10  | –8\n–12 mod –10 | –2\n\nFails if either of `x` or `y` is not a valid [VM number](#vm-number), or if `y` is zero.\n\n\n\n#### LSHIFT\n\nCode  | Stack Diagram   | Cost\n------|-----------------|----------------------------\n0x98  | (x y → x \u003c\u003c y)  | 8; [standard memory cost](#standard-memory-cost)\n\nPops two [numbers](#vm-number) from the data stack, multiplies `x` by `2**y` (i.e., an arithmetic left shift with sign extension), coerces the result to a [string](#vm-string), and pushes it to the data stack.\n\nExample     | Result\n------------|--------\n5 \u003c\u003c 1      | 10\n5 \u003c\u003c 2      | 20\n-5 \u003c\u003c 1     | -10\n\nFails if any of `x`, `y` or `x * 2**y`is not a valid [VM number](#vm-number), or if `y` is less than zero.\n\n\n#### RSHIFT\n\nCode  | Stack Diagram   | Cost\n------|-----------------|----------------------------\n0x99  | (x y → x \u003e\u003e y)  | 8; [standard memory cost](#standard-memory-cost)\n\nPops two [numbers](#vm-number) from the data stack, divides `x` by `2**y` rounding to an integer toward negative infinity (i.e., an arithmetic right shift with sign extension), and pushes the result to the stack.\n\nExample     | Result\n------------|--------\n10 \u003e\u003e 1     | 5\n10 \u003e\u003e 2     | 2\n1 \u003e\u003e 1      | 0\n-1 \u003e\u003e 1     | -1\n-10 \u003e\u003e 2    | -3\n\nFails if either of `x` or `y` is not a valid [VM number](#vm-number), or if `y` is less than zero.\n\n\n\n#### BOOLAND\n\nCode  | Stack Diagram   | Cost\n------|-----------------|----------------------------\n0x9a  | (p q → p \u0026\u0026 q)  | 2; [standard memory cost](#standard-memory-cost)\n\nPops two [booleans](#vm-boolean) from the data stack. Pushes `true` to the data stack if both are `true`, and pushes `false` otherwise.\n\n\n#### BOOLOR\n\nCode  | Stack Diagram     | Cost\n------|-------------------|----------------------------\n0x9b  | (p q → p \\|\\| q)  | 2; [standard memory cost](#standard-memory-cost)\n\nPops two [booleans](#vm-boolean) from the data stack. Pushes `false` to the data stack if both are `false` and pushes `true` otherwise.\n\n\n#### NUMEQUAL\n\nCode  | Stack Diagram   | Cost\n------|-----------------|----------------------------\n0x9c  | (x y → x == y)  | 2; [standard memory cost](#standard-memory-cost)\n\nPops two [numbers](#vm-number) from the data stack. Pushes `true` to the data stack if they are equal and pushes `false` otherwise.\n\nNote that two strings representing the same number may differ due to redundant leading zeros.\n\nFails if either of `x` or `y` is not a valid [VM number](#vm-number).\n\n\n#### NUMEQUALVERIFY\n\nCode  | Stack Diagram   | Cost\n------|-----------------|----------------------------\n0x9d  | (x y → ∅)       | 2; [standard memory cost](#standard-memory-cost)\n\nEquivalent to [NUMEQUAL](#numequal) [VERIFY](#verify).\n\nPops two [numbers](#vm-number) from the data stack, and fails if they are not equal.\n\nFails if either of `x` or `y` is not a valid [VM number](#vm-number), or if they are not numerically equal.\n\n\n#### NUMNOTEQUAL\n\nCode  | Stack Diagram   | Cost\n------|-----------------|----------------------------\n0x9e  | (x y → x ≠ y)   | 2; [standard memory cost](#standard-memory-cost)\n\nPops two [numbers](#vm-number) from the data stack, results in `false` if they are equal and in `true` otherwise, and pushes the result to the data stack.\n\nNote that two strings representing the same number may differ due to redundant leading zeros.\n\nFails if either of `x` or `y` is not a valid [VM number](#vm-number).\n\n\n#### LESSTHAN\n\nCode  | Stack Diagram   | Cost\n------|-----------------|----------------------------\n0x9f  | (x y → x \u003c y)   | 2; [standard memory cost](#standard-memory-cost)\n\nPops two [numbers](#vm-number) from the data stack, results in `true` if `x` is less than `y` and `false` otherwise, and pushes the result to the data stack.\n\nFails if either of `x` or `y` is not a valid [VM number](#vm-number).\n\n\n#### GREATERTHAN\n\nCode  | Stack Diagram   | Cost\n------|-----------------|----------------------------\n0xa0  | (x y → x \u003e y)   | 2; [standard memory cost](#standard-memory-cost)\n\nPops two [numbers](#vm-number) from the data stack, results in `true` if `x` is greater than `y` and in `false` otherwise, and pushes the result to the data stack.\n\nFails if either of `x` or `y` is not a valid [VM number](#vm-number).\n\n\n#### LESSTHANOREQUAL\n\nCode  | Stack Diagram   | Cost\n------|-----------------|----------------------------\n0xa1  | (x y → x ≤ y)   | 2; [standard memory cost](#standard-memory-cost)\n\nPops two [numbers](#vm-number) from the data stack, results in `true` if `x` is less than or equal to `y` and in `false` otherwise, and pushes the result to the data stack.\n\nFails if either of `x` or `y` is not a valid [VM number](#vm-number).\n\n#### GREATERTHANOREQUAL\n\nCode  | Stack Diagram   | Cost\n------|-----------------|----------------------------\n0xa2  | (x y → x ≥ y)   | 2; [standard memory cost](#standard-memory-cost)\n\nPops two [numbers](#vm-number) from the data stack, results in `true` if `x` is greater than or equal to `y` and in `false` otherwise, and pushes the result to the data stack.\n\nFails if either of `x` or `y` is not a valid [VM number](#vm-number).\n\n\n#### MIN\n\nCode  | Stack Diagram    | Cost\n------|------------------|----------------------------\n0xa3  | (x y → min(x,y)) | 2; [standard memory cost](#standard-memory-cost)\n\nPops two [numbers](#vm-number) from the data stack, results in `x` if `x` is less than or equal to `y` and in `y` otherwise, and pushes the result to the data stack.\n\nFails if either of `x` or `y` is not a valid [VM number](#vm-number).\n\n\n#### MAX\n\nCode  | Stack Diagram    | Cost\n------|------------------|----------------------------\n0xa4  | (x y → max(x,y)) | 2; [standard memory cost](#standard-memory-cost)\n\nPops two [numbers](#vm-number) from the stack, results in `x` if `x` is greater than or equal to `y` and in `y` otherwise, and pushes the result to the data stack.\n\nFails if any of `x`, `y`, or `z` is not a valid [VM number](#vm-number).\n\n\n#### WITHIN\n\nCode  | Stack Diagram               | Cost\n------|-----------------------------|----------------------------\n0xa5  | (x y z → y ≤ x \u003c z) | 4; [standard memory cost](#standard-memory-cost)\n\nPops two [numbers](#vm-number) from the stack, results in [true](#vm-boolean) if `x` is greater or equal to the mininum value `y` and less than the maximum value `z`, and pushes the result to the stack.\n\nFails if any of `x`, `y`, or `z` is not a valid [VM number](#vm-number).\n\n\n### Cryptographic instructions\n\n\n#### SHA256\n\nCode  | Stack Diagram                  | Cost\n------|--------------------------------|-----------------------------------------------------\n0xa8  | (a → SHA-256(a))               | max(64, 4·L\u003csub\u003ea\u003c/sub\u003e) + [standard memory cost](#standard-memory-cost)\n\nReplaces top stack item with its [SHA-256](https://en.wikipedia.org/wiki/SHA-2) hash value.\n\n\n#### SHA3 Instruction\n\nCode  | Stack Diagram                  | Cost\n------|--------------------------------|-----------------------------------------------------\n0xaa  | (a → SHA3-256(a))              | max(64, 4·L\u003csub\u003ex\u003c/sub\u003e) + [standard memory cost](#standard-memory-cost)\n\nReplaces top stack item with its [SHA3-256](data.md#sha3) hash value.\n\n\n#### CHECKSIG\n\nCode  | Stack Diagram                  | Cost\n------|--------------------------------|-----------------------------------------------------\n0xac  | (sig hash pubkey → q)          | 1024; [standard memory cost](#standard-memory-cost)\n\nPops the top three items on the data stack, verifies the [signature](data.md#signature) `sig` of the `hash` with a given public key `pubkey` and pushes `true` if the signature is valid; pushes `false` if it is not.\n\nFails if `hash` is not a 32-byte string.\n\n\n#### CHECKMULTISIG\n\nCode  | Stack Diagram                  | Cost\n------|--------------------------------|-----------------------------------------------------\n0xad  | (sig\u003csub\u003em-1\u003c/sub\u003e ... sig\u003csub\u003e0\u003c/sub\u003e hash pubkey\u003csub\u003en-1\u003c/sub\u003e ... pubkey\u003csub\u003e0\u003c/sub\u003e m n → q)  | 1024·n; [standard memory cost](#standard-memory-cost)\n\n1. Pops non-negative [numbers](#vm-number) `n` and `m` from the data stack.\n2. If `n` is positive, verifies that `m` is also positive.\n3. Pops `n` public keys.\n4. Pops `hash` from the data stack.\n5. Pops `m` signatures.\n6. Verifies [signatures](data.md#signature) one by one against the public keys and the given `hash`. Signatures must be in the same order as public keys and no two signatures are verified with the same public key.\n7. Pushes `true` if all of the signatures are valid, and `false` otherwise.\n\nFailure conditions:\n\n* there are fewer than `m+n+3` items on the data stack, or\n* the top item (`n`) is not a number, or\n* `n` is negative, or\n* the second from the top item (`m`) is not a number, or\n* `m` is negative, or\n* `m` is greater than `n`, or\n* `m` is zero and `n` is positive.\n\n\n\n#### TXSIGHASH\n\nCode  | Stack Diagram                  | Cost\n------|--------------------------------|-----------------------------------------------------\n0xae  | (∅ → hash)                     | 256 + [standard memory cost](#standard-memory-cost)\n\nComputes the [transaction signature hash](data.md#transaction-signature-hash) corresponding to the current input.\n\nTypically used with [CHECKSIG](#checksig) or [CHECKMULTISIG](#checkmultisig).\n\nFails if executed in the [block context](#block-context).\n\n\n#### BLOCKHASH\n\nCode  | Stack Diagram                  | Cost\n------|--------------------------------|-----------------------------------------------------\n0xaf  | (∅ → hash)                     | 4·L\u003csub\u003ehashed data\u003c/sub\u003e + [standard memory cost](#standard-memory-cost)\n\nReturns the [block ID](data.md#block-id).\n\nTypically used with [CHECKSIG](#checksig) or [CHECKMULTISIG](#checkmultisig).\n\nFails if executed in the [transaction context](#transaction-context).\n\n\n\n\n\n### Introspection instructions\n\nThe following instructions are defined within a [transaction context](#execution-context). In the block context these instructions cause VM to halt immediately and return false.\n\nNote: [standard memory cost](#standard-memory-cost) is applied *after* the instruction is executed in order to determine the exact size of the encoded data (this also applies to [ASSET](#asset), even though the result is always 32 bytes long).\n\n\n#### CHECKOUTPUT\n\nCode  | Stack Diagram                                        | Cost\n------|------------------------------------------------------|-----------------------------------------------------\n0xc1  | (index refdatahash amount assetid version prog → q)  | 16; [standard memory cost](#standard-memory-cost)\n\n1. Pops 6 items from the data stack: `index`, `refdatahash`, `amount`, `assetid`, `version`, `prog`.\n2. Fails if `index` is negative or not a valid [number](#vm-number).\n3. Fails if the number of outputs is less or equal to `index`.\n4. Fails if `amount` and `version` are not non-negative [numbers](#vm-number).\n5. Finds a transaction output at the given `index`.\n6. If the output satisfies all of the following conditions pushes [true](#vm-boolean) on the data stack; otherwise pushes [false](#vm-boolean):\n    1. control program equals `prog`,\n    2. VM version equals `version`,\n    3. asset ID equals `assetid`,\n    4. amount equals `amount`,\n    5. `refdatahash` is an empty string or it matches the [SHA3-256](data.md#sha3) hash of the reference data.\n\nFails if executed in the [block context](#block-context).\n\n\n#### ASSET\n\nCode  | Stack Diagram  | Cost\n------|----------------|-----------------------------------------------------\n0xc2  | (∅ → assetid)   | 1; [standard memory cost](#standard-memory-cost)\n\nPushes the asset ID assigned to the current input on the data stack.\n\nFails if executed in the [block context](#block-context).\n\n\n#### AMOUNT\n\nCode  | Stack Diagram  | Cost\n------|----------------|-----------------------------------------------------\n0xc3  | (∅ → amount)    | 1; [standard memory cost](#standard-memory-cost)\n\nPushes the amount assigned to the current input on the data stack.\n\nFails if executed in the [block context](#block-context).\n\n\n#### PROGRAM\n\nCode  | Stack Diagram  | Cost\n------|----------------|-----------------------------------------------------\n0xc4  | (∅ → program)   | 1; [standard memory cost](#standard-memory-cost)\n\n1. In [transaction context](#transaction-context):\n  * For spend inputs: pushes the control program from the output being spent.\n  * For issuance inputs: pushes the issuance program.\n2. In [block context](#block-context):\n  * Pushes the current [consensus program](data.md#consensus-program) being executed (that is specified in the previous block header).\n\n\n#### MINTIME\n\nCode  | Stack Diagram  | Cost\n------|----------------|-----------------------------------------------------\n0xc5  | (∅ → timestamp) | 1; [standard memory cost](#standard-memory-cost)\n\nPushes the transaction minimum time in milliseconds on the data stack.\nIf the value is greater than 2\u003csup\u003e63\u003c/sup\u003e–1, pushes 2\u003csup\u003e63\u003c/sup\u003e–1 (encoded as [VM number](#vm-number) 0xffffffffffffff7f).\n\nFails if executed in the [block context](#block-context).\n\n#### MAXTIME\n\nCode  | Stack Diagram   | Cost\n------|-----------------|-----------------------------------------------------\n0xc6  | (∅ → timestamp) | 1; [standard memory cost](#standard-memory-cost)\n\nPushes the transaction maximum time in milliseconds on the data stack.\nIf the value is zero or greater than 2\u003csup\u003e63\u003c/sup\u003e–1, pushes 2\u003csup\u003e63\u003c/sup\u003e–1 (encoded as [VM number](#vm-number) 0xffffffffffffff7f).\n\nFails if executed in the [block context](#block-context).\n\n#### TXREFDATAHASH\n\nCode  | Stack Diagram   | Cost\n------|-----------------|-----------------------------------------------------\n0xc7  | (∅ → hash)      | 1; [standard memory cost](#standard-memory-cost)\n\nPushes the SHA3-256 hash of the [transaction](data.md#transaction)'s reference data.\n\nFails if executed in the [block context](#block-context).\n\n\n#### REFDATAHASH\n\nCode  | Stack Diagram   | Cost\n------|-----------------|-----------------------------------------------------\n0xc8  | (∅ → hash)      | 1; [standard memory cost](#standard-memory-cost)\n\nPushes the SHA3-256 hash of the current [input](data.md#transaction-input)'s reference data.\n\nFails if executed in the [block context](#block-context).\n\n\n#### INDEX\n\nCode  | Stack Diagram   | Cost\n------|-----------------|-----------------------------------------------------\n0xc9  | (∅ → index)     | 1; [standard memory cost](#standard-memory-cost)\n\nPushes the index of the current input on the data stack.\n\nFails if executed in the [block context](#block-context).\n\n\n#### OUTPUTID\n\nCode  | Stack Diagram   | Cost\n------|-----------------|-----------------------------------------------------\n0xcb  | (∅ → outputid)  | 1; [standard memory cost](#standard-memory-cost)\n\nPushes the [output ID](data.md#output-id) on the data stack.\n\nFails if the current input is an [issuance input](data.md#transaction-input-commitment).\n\nFails if executed in the [block context](#block-context).\n\n\n#### NONCE\n\nCode  | Stack Diagram   | Cost\n------|-----------------|-----------------------------------------------------\n0xcc  | (∅ → nonce)     | 1; [standard memory cost](#standard-memory-cost)\n\nPushes the nonce declared in the current input's [issuance commitment](data.md#asset-version-1-issuance-commitment) on the data stack.\n\nFails if the current input is not an [issuance input](data.md#transaction-input-commitment).\n\nFails if executed in the [block context](#block-context).\n\n\n#### NEXTPROGRAM\n\nCode  | Stack Diagram  | Cost\n------|----------------|-----------------------------------------------------\n0xcd  | (∅ → program)   | 1; [standard memory cost](#standard-memory-cost)\n\nPushes the [next consensus program](data.md#consensus-program) specified in the current block header.\n\nFails if executed in the [transaction context](#transaction-context).\n\n\n#### BLOCKTIME\n\nCode  | Stack Diagram   | Cost\n------|-----------------|-----------------------------------------------------\n0xce  | (∅ → timestamp) | 1; [standard memory cost](#standard-memory-cost)\n\nPushes the block timestamp in milliseconds on the data stack.\n\nFails if executed in the [transaction context](#transaction-context).\n\n\n\n### Expansion opcodes\n\nCode  | Stack Diagram   | Cost\n------|-----------------|-----------------------------------------------------\n0x50, 0x61, 0x62, 0x65, 0x66, 0x67, 0x68, 0x8a, 0x8d, 0x8e, 0xa6, 0xa7, 0xa9, 0xab, 0xb0..0xbf, 0xca, 0xcd..0xcf, 0xd0..0xff  | (∅ → ∅)     | 1\n\nThe unassigned codes are reserved for future expansion and have no effect on the state of the VM apart from reducing run limit by 1.\n\n\n\n\n\n# References\n\n* [FIPS180] [\"Secure Hash Standard\", United States of America, National Institute of Standards and Technology, Federal Information Processing Standard (FIPS) 180-2](http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf).\n* [FIPS202] [Federal Inf. Process. Stds. (NIST FIPS) - 202 (SHA3)](https://dx.doi.org/10.6028/NIST.FIPS.202)\n* [LEB128] [Little-Endian Base-128 Encoding](https://developers.google.com/protocol-buffers/docs/encoding)\n* [CFRG1] [Edwards-curve Digital Signature Algorithm (EdDSA) draft-irtf-cfrg-eddsa-05](https://tools.ietf.org/html/draft-irtf-cfrg-eddsa-05)\n* [RFC 6962](https://tools.ietf.org/html/rfc6962#section-2.1)\n\n\n"},]